/**
 ******************************************************************************
 * @addtogroup OpenPilotModules OpenPilot Modules
 * @{
 * @addtogroup BatteryModule Battery Module
 * @brief Measures battery voltage and current
 * Updates the FlightBatteryState object
 * @{
 *
 * @file       battery.c
 * @author     The OpenPilot Team, http://www.openpilot.org Copyright (C) 2010.
 * @brief      Module to read the battery Voltage and Current periodically and set alarms appropriately.
 *
 * @see        The GNU Public License (GPL) Version 3
 *
 *****************************************************************************/
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

/**
 * Output object: FlightBatteryState
 *
 * This module will periodically generate information on the battery state.
 *
 * UAVObjects are automatically generated by the UAVObjectGenerator from
 * the object definition XML file.
 *
 * Modules have no API, all communication to other modules is done through UAVObjects.
 * However modules may use the API exposed by shared libraries.
 * See the OpenPilot wiki for more details.
 * http://www.openpilot.org/OpenPilot_Application_Architecture
 *
 */


/*
 * dahmicha
 *
 * Ich habe das Modul PX2Buzzer kopiert und versuche jetzt das ganze so abzuändern, dass
 * ein anständiges PWM signal generiert wird. Ich werde die Funktionen von PIOS buzzer
 * verwenden.
 *
 *
 */

#include "openpilot.h"
#include "stm32F2xx.h"
#include "stdlib.h" //itoa

#if 1//#ifdef PIOS_INCLUDE_BUZZER

//
// Configuration
//
#define STACK_SIZE_BYTES		1024
#define PWM_TASK_PRIORITY	(tskIDLE_PRIORITY + 0)
#define CYCLE_LENGTH			40
#define NUM_MELODIES			3
#define MAX_MELODY_LENGTH		100

//#define ENABLE_DEBUG_MSG

#ifdef ENABLE_DEBUG_MSG
#define DEBUG_PORT			PIOS_COM_GPS
#define DEBUG_MSG(format, ...) PIOS_COM_SendFormattedString(DEBUG_PORT, format, ## __VA_ARGS__)
#else
#define DEBUG_MSG(format, ...)
#endif


// Private variables
static xTaskHandle buzzerTaskHandle;

// Private functions
static void PWMTask(void *parameters);

static void setPWM(TIM_TypeDef * timer, uint16_t TIM_Channel, uint16_t dc_interval);//chstocke
static void setServo(int16_t dutyCycle, bool direction);//chstocke
//static int16_t readPoti();//chstocke
//static void pregler(uint16_t poti_soll);

/**
 * Initialize the module, called on startup
 * \returns 0 on success or -1 if initialization failed
 */

int32_t PWMInitialize(void)
{
	// AD einlesen initialisieren
	PIOS_ADC_Init();
	// dahmicha: PWM initialisieren (analog zu PIOS_Buzzer_Init())
	PIOS_Buzzer_Init();

	GPIO_InitTypeDef GPIO_PWMStruct;
	TIM_TimeBaseInitTypeDef TIM_TimeBase_PWMStruct;
	TIM_OCInitTypeDef TIM_OC_PWMStruct;

	GPIO_InitTypeDef GPIO_PWMStruct0;
	TIM_TimeBaseInitTypeDef TIM_TimeBase_PWMStruct0;
	TIM_OCInitTypeDef TIM_OC_PWMStruct0;

	GPIO_PWMStruct.GPIO_Pin   = GPIO_Pin_1;
	GPIO_PWMStruct.GPIO_Mode  = GPIO_Mode_AF;
	GPIO_PWMStruct.GPIO_Speed = GPIO_Speed_2MHz;
	GPIO_PWMStruct.GPIO_OType = GPIO_OType_PP;
	GPIO_PWMStruct.GPIO_PuPd  = GPIO_PuPd_NOPULL;

	TIM_TimeBase_PWMStruct.TIM_Prescaler = ((PIOS_MASTER_CLOCK /2) / 20000000) - 1;	// TIM5 Frequency is 20 MHz
	TIM_TimeBase_PWMStruct.TIM_CounterMode = TIM_CounterMode_CenterAligned1;
	TIM_TimeBase_PWMStruct.TIM_ClockDivision = TIM_CKD_DIV1;
	TIM_TimeBase_PWMStruct.TIM_Period = 57333;
	TIM_TimeBase_PWMStruct.TIM_RepetitionCounter = 0;

	TIM_OC_PWMStruct.TIM_OCMode = TIM_OCMode_PWM1;
	TIM_OC_PWMStruct.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OC_PWMStruct.TIM_Pulse = 57333/2;
	TIM_OC_PWMStruct.TIM_OCPolarity = TIM_OCPolarity_High;
	TIM_OC_PWMStruct.TIM_OutputNState = TIM_OutputNState_Disable;	//not used (only TIM1 & TIM8)
	TIM_OC_PWMStruct.TIM_OCNPolarity = TIM_OCPolarity_High;			//not used (only TIM1 & TIM8)
	TIM_OC_PWMStruct.TIM_OCIdleState = TIM_OCIdleState_Reset;		//not used (only TIM1 & TIM8)
	TIM_OC_PWMStruct.TIM_OCNIdleState = TIM_OCNIdleState_Reset;		//not used (only TIM1 & TIM8)

	GPIO_PWMStruct0 = GPIO_PWMStruct;//chstocke
	TIM_TimeBase_PWMStruct0 = TIM_TimeBase_PWMStruct;//chstocke
	TIM_OC_PWMStruct0 = TIM_OC_PWMStruct;//chstocke

	GPIO_PWMStruct0.GPIO_Pin   = GPIO_Pin_0;//chstocke


	// dahmicha: Timer definieren
	TIM_TypeDef * timer;
	timer = TIM5;

	// dahmicha: enable GPIO
	GPIO_Init(GPIOA, &GPIO_PWMStruct);
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource1, GPIO_AF_TIM5);
	GPIO_Init(GPIOA, &GPIO_PWMStruct0);//chstocke
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource0, GPIO_AF_TIM5);//chstocke

	// dahmicha: enable Time Base
	TIM_TimeBaseInit(timer,  &TIM_TimeBase_PWMStruct);

	// dahmicha: Hier kann man einfach den Channel wechseln (einfach TIM_Channel_2 ersetzen)
	switch(TIM_Channel_1) {
		case TIM_Channel_1:
			TIM_OC1Init(timer, &TIM_OC_PWMStruct);
			TIM_OC1PreloadConfig(timer, TIM_OCPreload_Enable);
			break;
		case TIM_Channel_2:
			TIM_OC2Init(timer, &TIM_OC_PWMStruct);
			TIM_OC2PreloadConfig(timer, TIM_OCPreload_Enable);
			break;
		case TIM_Channel_3:
			TIM_OC3Init(timer, &TIM_OC_PWMStruct);
			TIM_OC3PreloadConfig(timer, TIM_OCPreload_Enable);
			break;
		case TIM_Channel_4:
			TIM_OC4Init(timer, &TIM_OC_PWMStruct);
			TIM_OC4PreloadConfig(timer, TIM_OCPreload_Enable);
			break;
	}
	//chstocke
	switch(TIM_Channel_2) {
		case TIM_Channel_1:
			TIM_OC1Init(timer, &TIM_OC_PWMStruct);
			TIM_OC1PreloadConfig(timer, TIM_OCPreload_Enable);
			break;
		case TIM_Channel_2:
			TIM_OC2Init(timer, &TIM_OC_PWMStruct);
			TIM_OC2PreloadConfig(timer, TIM_OCPreload_Enable);
			break;
		case TIM_Channel_3:
			TIM_OC3Init(timer, &TIM_OC_PWMStruct);
			TIM_OC3PreloadConfig(timer, TIM_OCPreload_Enable);
			break;
		case TIM_Channel_4:
			TIM_OC4Init(timer, &TIM_OC_PWMStruct);
			TIM_OC4PreloadConfig(timer, TIM_OCPreload_Enable);
			break;
	}

	TIM_ARRPreloadConfig(timer, ENABLE);

	// dahmicha: Task wird erstellt
	xTaskCreate(PWMTask, (signed char *)"PWM", STACK_SIZE_BYTES/4, NULL, PWM_TASK_PRIORITY, &buzzerTaskHandle);
	return 0;
}

MODULE_INITCALL(PWMInitialize, 0)

//print to USART
void send_string(const char *str)
 {
     while (*str)
     {
         while(USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET);
         USART_SendData(USART2, *str++);
     }
 }

//chstocke
bool LEFT = 0;
bool RIGHT = 1;

void setServo(int16_t dutyCycle, bool direction) {
	uint16_t tim_interval = 57334;
	uint16_t dc_interval = tim_interval*dutyCycle/100;

	//limit dutyCycle
//	if (dutyCycle > 100) {
//		dutyCycle = 100;
//	}
//	else if (dutyCycle < 0) {
//		dutyCycle = 0;
//	}

	if (direction == LEFT) {
		//turn left
		setPWM(TIM5, TIM_Channel_1, dc_interval);
		setPWM(TIM5, TIM_Channel_2, 0);
	} else if (direction == RIGHT) {
		//turn right
		setPWM(TIM5, TIM_Channel_1, 0);
		setPWM(TIM5, TIM_Channel_2, dc_interval);
	}
}

//chstocke
void setPWM(TIM_TypeDef * timer, uint16_t TIM_Channel, uint16_t dc_interval) {
	switch(TIM_Channel) {
		case TIM_Channel_1:
			TIM_SetCompare1(timer, dc_interval);
			break;
		case TIM_Channel_2:
			TIM_SetCompare2(timer, dc_interval);
			break;
		case TIM_Channel_3:
			TIM_SetCompare3(timer, dc_interval);
			break;
		case TIM_Channel_4:
			TIM_SetCompare4(timer, dc_interval);
			break;
	}
}

// itoa //

size_t strlen(const char *);
char *strrev(char *);

char *itoa(int n, char *s, int b) {
	static char digits[] = "0123456789abcdefghijklmnopqrstuvwxyz";
	int i=0, sign;

	if ((sign = n) < 0)
		n = -n;

	do {
		s[i++] = digits[n % b];
	} while ((n /= b) > 0);

	if (sign < 0)
		s[i++] = '-';
	s[i] = '\0';

	return strrev(s);
}

size_t strlen(const char *string) {
	const char *s;

	s = string;
	while (*s)
		s++;
	return s - string;
}

char *strrev(char *str) {
	char *p1, *p2;

	if (!str || !*str)
		return str;

	for (p1 = str, p2 = str + strlen(str) - 1; p2 > p1; ++p1, --p2) {
		*p1 ^= *p2;
		*p2 ^= *p1;
		*p1 ^= *p2;
	}

	return str;
}

int16_t potivalue;
char buf[5];
int16_t readPoti() {
	potivalue = PIOS_ADC_PinGet(1)/20+15;

//	itoa(potivalue, buf, 10);
//	send_string(buf);
	return potivalue;
}
int16_t SERVO_LMAX = 90;
int16_t SERVO_RMAX = 10;

void pregler(uint16_t poti_soll){
	//Maximale Steuerungsgrenzen setzen
	if(poti_soll>SERVO_LMAX){
		poti_soll=SERVO_LMAX;
	}
	if(poti_soll<SERVO_RMAX){
		poti_soll=SERVO_RMAX;
	}
	double k = 1.5;
	bool direction;
	int16_t fehler;
	fehler = poti_soll - readPoti();//=>negativer Fehler, falls Poti links des Sollwertes liegt, sonst positiv.
	if(fehler>=0){//Poti ist rechts des Sollwertes
		direction=LEFT;
	}else{
		direction=RIGHT;
	}
	//digiout(k*fehler);
	setServo(k*abs(fehler),direction);
}

/**
 * Module thread, should not return.
 */
static void PWMTask(void *parameters)
{


	// dahmicha: Hier kann man die Frequenz und den Duty Cicle vom PWM einstellen
	// dahmicha: 57334 enspricht einer Breite von 5.73ms, hier kann also die Frequenz gesetzt werden

	uint16_t tim_interval = 57334;

//	bool channel_bool = 0;

	TIM_TypeDef * timer;
	timer = TIM5;


//	char ch = 'a';

	for(;;){

	pregler(50);
//		potivalue = PIOS_ADC_PinGet(1)/20+15;
//		setServo(potivalue, LEFT);

	//	ch = (char)potivalue;
//	hi = num >> 32;
//	lo = num & 0xFFFFFFFF;

	//chstocke

//
//	 send_string("hello");

	// dahmicha: Duty Cicle zwischen 0 und 100
//	uint16_t dutyCicle;

//	dutyCicle = potivalue/10-70;
//	dutyCicle = 50;

//	dutyCicle++;
//	if(dutyCicle == 100) {
//		dutyCicle = 0;
//	}
//	if(potivalue == 0)
//		{dutyCicle = 30;}
//	else if(potivalue < 0.001)
//		{dutyCicle = 50;}
//	else
//		{dutyCicle = 10;}


	//uint16_t dc_interval=tim_interval*dutyCicle/100;

	TIM_SetAutoreload(timer, tim_interval);

	//TIM_SetCompare1(timer, dc_interval);
	//public void setDutyCycle(string channel)

//	if (channel_bool == 0)  {
//		setServo(60, 0);
//		ch = 'b';
//		channel_bool = 1;
//	} else if (channel_bool == 1) {
//		setServo(60, 1);
//		ch = 'c';
//		channel_bool = 0;
//	}

	// PIOS_Buzzer_Ctrl(1);
	PIOS_DELAY_WaitmS(50);
	TIM_Cmd(timer, ENABLE);
	}

}
#endif
