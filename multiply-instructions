
build/fw_px2fmu/fw_px2fmu.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000605c  08008000  08008000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .istack       00000400  20000000  20000000  00018000  2**2
                  ALLOC
  2 .data         00000038  20000400  0800e05c  00010400  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000186  20000438  0800e094  00010438  2**2
                  ALLOC
  4 .heap         0001fa40  200005be  0800e21a  00010438  2**0
                  ALLOC
  5 .comment      0000003a  00000000  00000000  00010438  2**0
                  CONTENTS, READONLY
  6 .ARM.attributes 00000037  00000000  00000000  00010472  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 000028c0  00000000  00000000  000104b0  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00022e2f  00000000  00000000  00012d70  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00007f20  00000000  00000000  00035b9f  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00010fd3  00000000  00000000  0003dabf  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00007640  00000000  00000000  0004ea94  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    0000c032  00000000  00000000  000560d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000d978  00000000  00000000  00062106  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00002140  00000000  00000000  0006fa7e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08008000 <cpu_vectors>:
 8008000:	00 04 00 20 05 87 00 08 9d 87 00 08 59 85 00 08     ... ........Y...
 8008010:	9d 87 00 08 95 85 00 08 d1 85 00 08 00 00 00 00     ................
	...
 800802c:	dd c9 00 08 9d 87 00 08 00 00 00 00 55 cb 00 08     ............U...
 800803c:	91 cb 00 08                                         ....

08008040 <io_vectors>:
 8008040:	b1 87 00 08 b1 87 00 08 b1 87 00 08 b1 87 00 08     ................
 8008050:	b1 87 00 08 b1 87 00 08 25 90 00 08 91 90 00 08     ........%.......
 8008060:	b1 87 00 08 b1 87 00 08 b1 87 00 08 b1 87 00 08     ................
 8008070:	b1 87 00 08 b1 87 00 08 b1 87 00 08 b1 87 00 08     ................
 8008080:	b1 87 00 08 b1 87 00 08 b1 87 00 08 b1 87 00 08     ................
 8008090:	b1 87 00 08 b1 87 00 08 b1 87 00 08 b1 87 00 08     ................
 80080a0:	b1 87 00 08 b1 87 00 08 b1 87 00 08 b1 87 00 08     ................
 80080b0:	b1 87 00 08 b1 87 00 08 b1 87 00 08 b1 87 00 08     ................
 80080c0:	b1 87 00 08 b1 87 00 08 b1 87 00 08 b1 87 00 08     ................
 80080d0:	b1 87 00 08 3d 8c 00 08 75 8c 00 08 ad 8c 00 08     ....=...u.......
 80080e0:	b1 87 00 08 b1 87 00 08 b1 87 00 08 b1 87 00 08     ................
 80080f0:	b1 87 00 08 b1 87 00 08 b1 87 00 08 b1 87 00 08     ................
 8008100:	b1 87 00 08 b1 87 00 08 b1 87 00 08 b1 87 00 08     ................
 8008110:	e5 8c 00 08 1d 8d 00 08 b1 87 00 08 b1 87 00 08     ................
 8008120:	b1 87 00 08 b1 87 00 08 b1 87 00 08 b1 87 00 08     ................
 8008130:	b1 87 00 08 b1 87 00 08 b1 87 00 08 b1 87 00 08     ................
 8008140:	b1 87 00 08 b1 87 00 08 b1 87 00 08 b1 87 00 08     ................
 8008150:	b1 87 00 08 b1 87 00 08 b1 87 00 08 55 8d 00 08     ............U...
 8008160:	b1 87 00 08 b1 87 00 08 b1 87 00 08 b1 87 00 08     ................
 8008170:	b1 87 00 08 b1 87 00 08 b1 87 00 08 b1 87 00 08     ................
 8008180:	b1 87 00 08                                         ....

08008184 <vApplicationStackOverflowHook>:

/**
 * Called by the RTOS when a stack overflow is detected.
 */
void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed portCHAR *pcTaskName )
{
 8008184:	b510      	push	{r4, lr}
 8008186:	b082      	sub	sp, #8
 8008188:	4674      	mov	r4, lr
 800818a:	9001      	str	r0, [sp, #4]
 800818c:	9100      	str	r1, [sp, #0]
 800818e:	4623      	mov	r3, r4
 8008190:	f248 1085 	movw	r0, #33157	; 0x8185
 8008194:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008198:	4619      	mov	r1, r3
 800819a:	f004 fd35 	bl	800cc08 <__cyg_profile_func_enter>
	PIOS_DEBUG_Panic("STACK OVERFLOW");
 800819e:	f64d 2044 	movw	r0, #55876	; 0xda44
 80081a2:	f6c0 0000 	movt	r0, #2048	; 0x800
 80081a6:	f000 ff23 	bl	8008ff0 <PIOS_DEBUG_Panic>
 80081aa:	4623      	mov	r3, r4
 80081ac:	f248 1085 	movw	r0, #33157	; 0x8185
 80081b0:	f6c0 0000 	movt	r0, #2048	; 0x800
 80081b4:	4619      	mov	r1, r3
 80081b6:	f004 fd35 	bl	800cc24 <__cyg_profile_func_exit>
}
 80081ba:	b002      	add	sp, #8
 80081bc:	bd10      	pop	{r4, pc}
 80081be:	bf00      	nop

080081c0 <main>:
// Variables
static uint32_t idleCounter = 0;
static uint32_t idleCounterClear = 0;

int main()
{
 80081c0:	b530      	push	{r4, r5, lr}
 80081c2:	b085      	sub	sp, #20
 80081c4:	4674      	mov	r4, lr
 80081c6:	4623      	mov	r3, r4
 80081c8:	f248 10c1 	movw	r0, #33217	; 0x81c1
 80081cc:	f6c0 0000 	movt	r0, #2048	; 0x800
 80081d0:	4619      	mov	r1, r3
 80081d2:	f004 fd19 	bl	800cc08 <__cyg_profile_func_enter>
	/* initialise the heap */
	vPortInitialiseBlocks();
 80081d6:	f005 fad7 	bl	800d788 <vPortInitialiseBlocks>

	PIOS_SYS_Init();
 80081da:	f000 faf3 	bl	80087c4 <PIOS_SYS_Init>

	// Create test task
	xTaskCreate(testTask, (signed portCHAR *)"Test", 1000 , NULL, 1, NULL);
 80081de:	f04f 0301 	mov.w	r3, #1
 80081e2:	9300      	str	r3, [sp, #0]
 80081e4:	f04f 0300 	mov.w	r3, #0
 80081e8:	9301      	str	r3, [sp, #4]
 80081ea:	f04f 0300 	mov.w	r3, #0
 80081ee:	9302      	str	r3, [sp, #8]
 80081f0:	f04f 0300 	mov.w	r3, #0
 80081f4:	9303      	str	r3, [sp, #12]
 80081f6:	f248 2085 	movw	r0, #33413	; 0x8285
 80081fa:	f6c0 0000 	movt	r0, #2048	; 0x800
 80081fe:	f64d 2154 	movw	r1, #55892	; 0xda54
 8008202:	f6c0 0100 	movt	r1, #2048	; 0x800
 8008206:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800820a:	f04f 0300 	mov.w	r3, #0
 800820e:	f002 ff29 	bl	800b064 <xTaskGenericCreate>

	// Start the FreeRTOS scheduler
	vTaskStartScheduler();
 8008212:	f003 f84f 	bl	800b2b4 <vTaskStartScheduler>
	return 0;
 8008216:	f04f 0500 	mov.w	r5, #0
 800821a:	4623      	mov	r3, r4
 800821c:	f248 10c1 	movw	r0, #33217	; 0x81c1
 8008220:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008224:	4619      	mov	r1, r3
 8008226:	f004 fcfd 	bl	800cc24 <__cyg_profile_func_exit>
 800822a:	462b      	mov	r3, r5
}
 800822c:	4618      	mov	r0, r3
 800822e:	b005      	add	sp, #20
 8008230:	bd30      	pop	{r4, r5, pc}
 8008232:	bf00      	nop

08008234 <multiply>:

static float multiply(float a, float b)
{
 8008234:	b510      	push	{r4, lr}
 8008236:	ed2d 8b02 	vpush	{d8}
 800823a:	b082      	sub	sp, #8
 800823c:	4674      	mov	r4, lr
 800823e:	ed8d 0a01 	vstr	s0, [sp, #4]
 8008242:	edcd 0a00 	vstr	s1, [sp]
 8008246:	4623      	mov	r3, r4
 8008248:	f248 2035 	movw	r0, #33333	; 0x8235
 800824c:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008250:	4619      	mov	r1, r3
 8008252:	f004 fcd9 	bl	800cc08 <__cyg_profile_func_enter>
	return a*b;
 8008256:	ed9d 7a01 	vldr	s14, [sp, #4]
 800825a:	eddd 7a00 	vldr	s15, [sp]
 800825e:	ee27 8a27 	vmul.f32	s16, s14, s15
 8008262:	4623      	mov	r3, r4
 8008264:	f248 2035 	movw	r0, #33333	; 0x8235
 8008268:	f6c0 0000 	movt	r0, #2048	; 0x800
 800826c:	4619      	mov	r1, r3
 800826e:	f004 fcd9 	bl	800cc24 <__cyg_profile_func_exit>
 8008272:	eef0 7a48 	vmov.f32	s15, s16
}
 8008276:	eeb0 0a67 	vmov.f32	s0, s15
 800827a:	b002      	add	sp, #8
 800827c:	ecbd 8b02 	vpop	{d8}
 8008280:	bd10      	pop	{r4, pc}
 8008282:	bf00      	nop

08008284 <testTask>:

static void testTask(void *pvParameters)
{
 8008284:	b500      	push	{lr}
 8008286:	b087      	sub	sp, #28
 8008288:	4673      	mov	r3, lr
 800828a:	9001      	str	r0, [sp, #4]
 800828c:	f248 2085 	movw	r0, #33413	; 0x8285
 8008290:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008294:	4619      	mov	r1, r3
 8008296:	f004 fcb7 	bl	800cc08 <__cyg_profile_func_enter>
	float a = 0.002f;
 800829a:	4b10      	ldr	r3, [pc, #64]	; (80082dc <testTask+0x58>)
 800829c:	9304      	str	r3, [sp, #16]
	float b = 0.001f;
 800829e:	4b10      	ldr	r3, [pc, #64]	; (80082e0 <testTask+0x5c>)
 80082a0:	9303      	str	r3, [sp, #12]
	float c = 0.011f;
 80082a2:	4b10      	ldr	r3, [pc, #64]	; (80082e4 <testTask+0x60>)
 80082a4:	9305      	str	r3, [sp, #20]

	while (1)
	{
		// Delay until enough required test duration
		vTaskDelay( BENCHMARK_DURATION_MS / portTICK_RATE_MS );
 80082a6:	f04f 0005 	mov.w	r0, #5
 80082aa:	f002 ffc7 	bl	800b23c <vTaskDelay>

		// Calculate counts per second, set breakpoint here
		c += multiply(a, b);
 80082ae:	ed9d 0a04 	vldr	s0, [sp, #16]
 80082b2:	eddd 0a03 	vldr	s1, [sp, #12]
 80082b6:	f7ff ffbd 	bl	8008234 <multiply>
 80082ba:	eef0 7a40 	vmov.f32	s15, s0
 80082be:	ed9d 7a05 	vldr	s14, [sp, #20]
 80082c2:	ee77 7a27 	vadd.f32	s15, s14, s15
 80082c6:	edcd 7a05 	vstr	s15, [sp, #20]

		// Reset and start again - do not clear idleCounter directly!
		// SET BREAKPOINT HERE and read the countsPerSecond variable
		// this should be used to update IDLE_COUNTS_PER_SEC_AT_NO_LOAD in systemmod.c
		idleCounterClear = 1;
 80082ca:	f240 433c 	movw	r3, #1084	; 0x43c
 80082ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80082d2:	f04f 0201 	mov.w	r2, #1
 80082d6:	601a      	str	r2, [r3, #0]
	}
 80082d8:	e7e5      	b.n	80082a6 <testTask+0x22>
 80082da:	bf00      	nop
 80082dc:	3b03126f 	.word	0x3b03126f
 80082e0:	3a83126f 	.word	0x3a83126f
 80082e4:	3c343958 	.word	0x3c343958

080082e8 <vApplicationIdleHook>:
}

void vApplicationIdleHook(void)
{
 80082e8:	b510      	push	{r4, lr}
 80082ea:	4674      	mov	r4, lr
 80082ec:	4623      	mov	r3, r4
 80082ee:	f248 20e9 	movw	r0, #33513	; 0x82e9
 80082f2:	f6c0 0000 	movt	r0, #2048	; 0x800
 80082f6:	4619      	mov	r1, r3
 80082f8:	f004 fc86 	bl	800cc08 <__cyg_profile_func_enter>
	/* Called when the scheduler has no tasks to run */
	if (idleCounterClear == 0)
 80082fc:	f240 433c 	movw	r3, #1084	; 0x43c
 8008300:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008304:	681b      	ldr	r3, [r3, #0]
 8008306:	2b00      	cmp	r3, #0
 8008308:	d10c      	bne.n	8008324 <vApplicationIdleHook+0x3c>
	{
		++idleCounter;
 800830a:	f240 4338 	movw	r3, #1080	; 0x438
 800830e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008312:	681b      	ldr	r3, [r3, #0]
 8008314:	f103 0201 	add.w	r2, r3, #1
 8008318:	f240 4338 	movw	r3, #1080	; 0x438
 800831c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008320:	601a      	str	r2, [r3, #0]
 8008322:	e00d      	b.n	8008340 <vApplicationIdleHook+0x58>
	}
	else
	{
		idleCounter = 0;
 8008324:	f240 4338 	movw	r3, #1080	; 0x438
 8008328:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800832c:	f04f 0200 	mov.w	r2, #0
 8008330:	601a      	str	r2, [r3, #0]
		idleCounterClear = 0;
 8008332:	f240 433c 	movw	r3, #1084	; 0x43c
 8008336:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800833a:	f04f 0200 	mov.w	r2, #0
 800833e:	601a      	str	r2, [r3, #0]
 8008340:	4623      	mov	r3, r4
 8008342:	f248 20e9 	movw	r0, #33513	; 0x82e9
 8008346:	f6c0 0000 	movt	r0, #2048	; 0x800
 800834a:	4619      	mov	r1, r3
 800834c:	f004 fc6a 	bl	800cc24 <__cyg_profile_func_exit>
	}
}
 8008350:	bd10      	pop	{r4, pc}
 8008352:	bf00      	nop

08008354 <dbg_write>:
#define NVIC_DBG_DATA_R		(*((volatile unsigned short *)0xE000EDF8))

#define	BUSY	1

void dbg_write(unsigned long dcc_data)
{
 8008354:	b510      	push	{r4, lr}
 8008356:	b084      	sub	sp, #16
 8008358:	4674      	mov	r4, lr
 800835a:	9001      	str	r0, [sp, #4]
 800835c:	4623      	mov	r3, r4
 800835e:	f248 3055 	movw	r0, #33621	; 0x8355
 8008362:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008366:	4619      	mov	r1, r3
 8008368:	f004 fc4e 	bl	800cc08 <__cyg_profile_func_enter>
	int len = 4;
 800836c:	f04f 0304 	mov.w	r3, #4
 8008370:	9303      	str	r3, [sp, #12]

	while (len--)
 8008372:	e01c      	b.n	80083ae <dbg_write+0x5a>
	{
		/* wait for data ready */
		while (NVIC_DBG_DATA_R & BUSY);
 8008374:	bf00      	nop
 8008376:	f64e 53f8 	movw	r3, #60920	; 0xedf8
 800837a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800837e:	881b      	ldrh	r3, [r3, #0]
 8008380:	b29b      	uxth	r3, r3
 8008382:	f003 0301 	and.w	r3, r3, #1
 8008386:	b2db      	uxtb	r3, r3
 8008388:	2b00      	cmp	r3, #0
 800838a:	d1f4      	bne.n	8008376 <dbg_write+0x22>

		/* write our data and set write flag - tell host there is data*/
		NVIC_DBG_DATA_R = (unsigned short)(((dcc_data & 0xff) << 8) | BUSY);
 800838c:	f64e 53f8 	movw	r3, #60920	; 0xedf8
 8008390:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8008394:	9a01      	ldr	r2, [sp, #4]
 8008396:	b292      	uxth	r2, r2
 8008398:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800839c:	b292      	uxth	r2, r2
 800839e:	f042 0201 	orr.w	r2, r2, #1
 80083a2:	b292      	uxth	r2, r2
 80083a4:	801a      	strh	r2, [r3, #0]
		dcc_data >>= 8;
 80083a6:	9b01      	ldr	r3, [sp, #4]
 80083a8:	ea4f 2313 	mov.w	r3, r3, lsr #8
 80083ac:	9301      	str	r3, [sp, #4]

void dbg_write(unsigned long dcc_data)
{
	int len = 4;

	while (len--)
 80083ae:	9b03      	ldr	r3, [sp, #12]
 80083b0:	2b00      	cmp	r3, #0
 80083b2:	bf0c      	ite	eq
 80083b4:	2300      	moveq	r3, #0
 80083b6:	2301      	movne	r3, #1
 80083b8:	b2db      	uxtb	r3, r3
 80083ba:	9a03      	ldr	r2, [sp, #12]
 80083bc:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
 80083c0:	9203      	str	r2, [sp, #12]
 80083c2:	2b00      	cmp	r3, #0
 80083c4:	d1d6      	bne.n	8008374 <dbg_write+0x20>
 80083c6:	4623      	mov	r3, r4
 80083c8:	f248 3055 	movw	r0, #33621	; 0x8355
 80083cc:	f6c0 0000 	movt	r0, #2048	; 0x800
 80083d0:	4619      	mov	r1, r3
 80083d2:	f004 fc27 	bl	800cc24 <__cyg_profile_func_exit>

		/* write our data and set write flag - tell host there is data*/
		NVIC_DBG_DATA_R = (unsigned short)(((dcc_data & 0xff) << 8) | BUSY);
		dcc_data >>= 8;
	}
}
 80083d6:	b004      	add	sp, #16
 80083d8:	bd10      	pop	{r4, pc}
 80083da:	bf00      	nop

080083dc <dbg_write_str>:
		len -= 4;
	}
}

void dbg_write_str(const char *msg)
{
 80083dc:	b510      	push	{r4, lr}
 80083de:	b084      	sub	sp, #16
 80083e0:	4674      	mov	r4, lr
 80083e2:	9001      	str	r0, [sp, #4]
 80083e4:	4623      	mov	r3, r4
 80083e6:	f248 30dd 	movw	r0, #33757	; 0x83dd
 80083ea:	f6c0 0000 	movt	r0, #2048	; 0x800
 80083ee:	4619      	mov	r1, r3
 80083f0:	f004 fc0a 	bl	800cc08 <__cyg_profile_func_enter>
	long len;
	unsigned long dcc_data;

	for (len = 0; msg[len] && (len < 65536); len++);
 80083f4:	f04f 0300 	mov.w	r3, #0
 80083f8:	9303      	str	r3, [sp, #12]
 80083fa:	e003      	b.n	8008404 <dbg_write_str+0x28>
 80083fc:	9b03      	ldr	r3, [sp, #12]
 80083fe:	f103 0301 	add.w	r3, r3, #1
 8008402:	9303      	str	r3, [sp, #12]
 8008404:	9b03      	ldr	r3, [sp, #12]
 8008406:	9a01      	ldr	r2, [sp, #4]
 8008408:	18d3      	adds	r3, r2, r3
 800840a:	781b      	ldrb	r3, [r3, #0]
 800840c:	2b00      	cmp	r3, #0
 800840e:	d004      	beq.n	800841a <dbg_write_str+0x3e>
 8008410:	9a03      	ldr	r2, [sp, #12]
 8008412:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8008416:	429a      	cmp	r2, r3
 8008418:	ddf0      	ble.n	80083fc <dbg_write_str+0x20>

	dbg_write(TARGET_REQ_DEBUGMSG_ASCII | ((len & 0xffff) << 16));
 800841a:	9b03      	ldr	r3, [sp, #12]
 800841c:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8008420:	f043 0301 	orr.w	r3, r3, #1
 8008424:	4618      	mov	r0, r3
 8008426:	f7ff ff95 	bl	8008354 <dbg_write>

	while (len > 0)
 800842a:	e035      	b.n	8008498 <dbg_write_str+0xbc>
	{
		dcc_data = msg[0]
 800842c:	9b01      	ldr	r3, [sp, #4]
 800842e:	781b      	ldrb	r3, [r3, #0]
			| ((len > 1) ? msg[1] << 8 : 0x00)
 8008430:	461a      	mov	r2, r3
 8008432:	9b03      	ldr	r3, [sp, #12]
 8008434:	2b01      	cmp	r3, #1
 8008436:	dd06      	ble.n	8008446 <dbg_write_str+0x6a>
 8008438:	9b01      	ldr	r3, [sp, #4]
 800843a:	f103 0301 	add.w	r3, r3, #1
 800843e:	781b      	ldrb	r3, [r3, #0]
 8008440:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8008444:	e001      	b.n	800844a <dbg_write_str+0x6e>
 8008446:	f04f 0300 	mov.w	r3, #0
 800844a:	431a      	orrs	r2, r3
			| ((len > 2) ? msg[2] << 16 : 0x00)
 800844c:	9b03      	ldr	r3, [sp, #12]
 800844e:	2b02      	cmp	r3, #2
 8008450:	dd06      	ble.n	8008460 <dbg_write_str+0x84>
 8008452:	9b01      	ldr	r3, [sp, #4]
 8008454:	f103 0302 	add.w	r3, r3, #2
 8008458:	781b      	ldrb	r3, [r3, #0]
 800845a:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800845e:	e001      	b.n	8008464 <dbg_write_str+0x88>
 8008460:	f04f 0300 	mov.w	r3, #0
 8008464:	431a      	orrs	r2, r3
			| ((len > 3) ? msg[3] << 24 : 0x00);
 8008466:	9b03      	ldr	r3, [sp, #12]
 8008468:	2b03      	cmp	r3, #3
 800846a:	dd06      	ble.n	800847a <dbg_write_str+0x9e>
 800846c:	9b01      	ldr	r3, [sp, #4]
 800846e:	f103 0303 	add.w	r3, r3, #3
 8008472:	781b      	ldrb	r3, [r3, #0]
 8008474:	ea4f 6303 	mov.w	r3, r3, lsl #24
 8008478:	e001      	b.n	800847e <dbg_write_str+0xa2>
 800847a:	f04f 0300 	mov.w	r3, #0
 800847e:	4313      	orrs	r3, r2

	dbg_write(TARGET_REQ_DEBUGMSG_ASCII | ((len & 0xffff) << 16));

	while (len > 0)
	{
		dcc_data = msg[0]
 8008480:	9302      	str	r3, [sp, #8]
			| ((len > 1) ? msg[1] << 8 : 0x00)
			| ((len > 2) ? msg[2] << 16 : 0x00)
			| ((len > 3) ? msg[3] << 24 : 0x00);
		dbg_write(dcc_data);
 8008482:	9802      	ldr	r0, [sp, #8]
 8008484:	f7ff ff66 	bl	8008354 <dbg_write>

		msg += 4;
 8008488:	9b01      	ldr	r3, [sp, #4]
 800848a:	f103 0304 	add.w	r3, r3, #4
 800848e:	9301      	str	r3, [sp, #4]
		len -= 4;
 8008490:	9b03      	ldr	r3, [sp, #12]
 8008492:	f1a3 0304 	sub.w	r3, r3, #4
 8008496:	9303      	str	r3, [sp, #12]

	for (len = 0; msg[len] && (len < 65536); len++);

	dbg_write(TARGET_REQ_DEBUGMSG_ASCII | ((len & 0xffff) << 16));

	while (len > 0)
 8008498:	9b03      	ldr	r3, [sp, #12]
 800849a:	2b00      	cmp	r3, #0
 800849c:	dcc6      	bgt.n	800842c <dbg_write_str+0x50>
 800849e:	4623      	mov	r3, r4
 80084a0:	f248 30dd 	movw	r0, #33757	; 0x83dd
 80084a4:	f6c0 0000 	movt	r0, #2048	; 0x800
 80084a8:	4619      	mov	r1, r3
 80084aa:	f004 fbbb 	bl	800cc24 <__cyg_profile_func_exit>
		dbg_write(dcc_data);

		msg += 4;
		len -= 4;
	}
}
 80084ae:	b004      	add	sp, #16
 80084b0:	bd10      	pop	{r4, pc}
 80084b2:	bf00      	nop

080084b4 <dbg_write_char>:

void dbg_write_char(char msg)
{
 80084b4:	b510      	push	{r4, lr}
 80084b6:	b082      	sub	sp, #8
 80084b8:	4674      	mov	r4, lr
 80084ba:	4603      	mov	r3, r0
 80084bc:	f88d 3007 	strb.w	r3, [sp, #7]
 80084c0:	4623      	mov	r3, r4
 80084c2:	f248 40b5 	movw	r0, #33973	; 0x84b5
 80084c6:	f6c0 0000 	movt	r0, #2048	; 0x800
 80084ca:	4619      	mov	r1, r3
 80084cc:	f004 fb9c 	bl	800cc08 <__cyg_profile_func_enter>
	dbg_write(TARGET_REQ_DEBUGCHAR | ((msg & 0xff) << 16));
 80084d0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80084d4:	ea4f 4303 	mov.w	r3, r3, lsl #16
 80084d8:	f043 0302 	orr.w	r3, r3, #2
 80084dc:	4618      	mov	r0, r3
 80084de:	f7ff ff39 	bl	8008354 <dbg_write>
 80084e2:	4623      	mov	r3, r4
 80084e4:	f248 40b5 	movw	r0, #33973	; 0x84b5
 80084e8:	f6c0 0000 	movt	r0, #2048	; 0x800
 80084ec:	4619      	mov	r1, r3
 80084ee:	f004 fb99 	bl	800cc24 <__cyg_profile_func_exit>
}
 80084f2:	b002      	add	sp, #8
 80084f4:	bd10      	pop	{r4, pc}
 80084f6:	bf00      	nop

080084f8 <dbg_write_hex32>:

void dbg_write_hex32(const unsigned long val)
{
 80084f8:	b510      	push	{r4, lr}
 80084fa:	b084      	sub	sp, #16
 80084fc:	4674      	mov	r4, lr
 80084fe:	9001      	str	r0, [sp, #4]
 8008500:	4623      	mov	r3, r4
 8008502:	f248 40f9 	movw	r0, #34041	; 0x84f9
 8008506:	f6c0 0000 	movt	r0, #2048	; 0x800
 800850a:	4619      	mov	r1, r3
 800850c:	f004 fb7c 	bl	800cc08 <__cyg_profile_func_enter>
	static const char hextab[] = {
			'0', '1', '2', '3', '4', '5', '6', '7',
			'8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
	};

	for (int shift = 28; shift >= 0; shift -= 4)
 8008510:	f04f 031c 	mov.w	r3, #28
 8008514:	9303      	str	r3, [sp, #12]
 8008516:	e011      	b.n	800853c <dbg_write_hex32+0x44>
		dbg_write_char(hextab[(val >> shift) & 0xf]);
 8008518:	9a01      	ldr	r2, [sp, #4]
 800851a:	9b03      	ldr	r3, [sp, #12]
 800851c:	fa22 f303 	lsr.w	r3, r2, r3
 8008520:	f003 020f 	and.w	r2, r3, #15
 8008524:	f64d 235c 	movw	r3, #55900	; 0xda5c
 8008528:	f6c0 0300 	movt	r3, #2048	; 0x800
 800852c:	5c9b      	ldrb	r3, [r3, r2]
 800852e:	4618      	mov	r0, r3
 8008530:	f7ff ffc0 	bl	80084b4 <dbg_write_char>
	static const char hextab[] = {
			'0', '1', '2', '3', '4', '5', '6', '7',
			'8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
	};

	for (int shift = 28; shift >= 0; shift -= 4)
 8008534:	9b03      	ldr	r3, [sp, #12]
 8008536:	f1a3 0304 	sub.w	r3, r3, #4
 800853a:	9303      	str	r3, [sp, #12]
 800853c:	9b03      	ldr	r3, [sp, #12]
 800853e:	2b00      	cmp	r3, #0
 8008540:	daea      	bge.n	8008518 <dbg_write_hex32+0x20>
 8008542:	4623      	mov	r3, r4
 8008544:	f248 40f9 	movw	r0, #34041	; 0x84f9
 8008548:	f6c0 0000 	movt	r0, #2048	; 0x800
 800854c:	4619      	mov	r1, r3
 800854e:	f004 fb69 	bl	800cc24 <__cyg_profile_func_exit>
		dbg_write_char(hextab[(val >> shift) & 0xf]);
}
 8008552:	b004      	add	sp, #16
 8008554:	bd10      	pop	{r4, pc}
 8008556:	bf00      	nop

08008558 <HardFault_Handler>:
	uint32_t	lr;
	uint32_t	pc;
	uint32_t	psr;
};

FAULT_TRAMPOLINE(HardFault);
 8008558:	4674      	mov	r4, lr
 800855a:	4623      	mov	r3, r4
 800855c:	f248 5059 	movw	r0, #34137	; 0x8559
 8008560:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008564:	4619      	mov	r1, r3
 8008566:	f004 fb4f 	bl	800cc08 <__cyg_profile_func_enter>
 800856a:	2004      	movs	r0, #4
 800856c:	4671      	mov	r1, lr
 800856e:	4208      	tst	r0, r1
 8008570:	d003      	beq.n	800857a <HardFault_Handler+0x22>
 8008572:	f3ef 8009 	mrs	r0, PSP
 8008576:	f000 b849 	b.w	800860c <HardFault_Handler2>
 800857a:	f3ef 8008 	mrs	r0, MSP
 800857e:	f000 b845 	b.w	800860c <HardFault_Handler2>
 8008582:	1c23      	adds	r3, r4, #0
 8008584:	f248 5059 	movw	r0, #34137	; 0x8559
 8008588:	f6c0 0000 	movt	r0, #2048	; 0x800
 800858c:	1c19      	adds	r1, r3, #0
 800858e:	f004 fb49 	bl	800cc24 <__cyg_profile_func_exit>
 8008592:	bf00      	nop

08008594 <BusFault_Handler>:
FAULT_TRAMPOLINE(BusFault);
 8008594:	4674      	mov	r4, lr
 8008596:	1c23      	adds	r3, r4, #0
 8008598:	f248 5095 	movw	r0, #34197	; 0x8595
 800859c:	f6c0 0000 	movt	r0, #2048	; 0x800
 80085a0:	1c19      	adds	r1, r3, #0
 80085a2:	f004 fb31 	bl	800cc08 <__cyg_profile_func_enter>
 80085a6:	2004      	movs	r0, #4
 80085a8:	4671      	mov	r1, lr
 80085aa:	4208      	tst	r0, r1
 80085ac:	d003      	beq.n	80085b6 <BusFault_Handler+0x22>
 80085ae:	f3ef 8009 	mrs	r0, PSP
 80085b2:	f000 b851 	b.w	8008658 <BusFault_Handler2>
 80085b6:	f3ef 8008 	mrs	r0, MSP
 80085ba:	f000 b84d 	b.w	8008658 <BusFault_Handler2>
 80085be:	1c23      	adds	r3, r4, #0
 80085c0:	f248 5095 	movw	r0, #34197	; 0x8595
 80085c4:	f6c0 0000 	movt	r0, #2048	; 0x800
 80085c8:	1c19      	adds	r1, r3, #0
 80085ca:	f004 fb2b 	bl	800cc24 <__cyg_profile_func_exit>
 80085ce:	bf00      	nop

080085d0 <UsageFault_Handler>:
FAULT_TRAMPOLINE(UsageFault);
 80085d0:	4674      	mov	r4, lr
 80085d2:	1c23      	adds	r3, r4, #0
 80085d4:	f248 50d1 	movw	r0, #34257	; 0x85d1
 80085d8:	f6c0 0000 	movt	r0, #2048	; 0x800
 80085dc:	1c19      	adds	r1, r3, #0
 80085de:	f004 fb13 	bl	800cc08 <__cyg_profile_func_enter>
 80085e2:	2004      	movs	r0, #4
 80085e4:	4671      	mov	r1, lr
 80085e6:	4208      	tst	r0, r1
 80085e8:	d003      	beq.n	80085f2 <UsageFault_Handler+0x22>
 80085ea:	f3ef 8009 	mrs	r0, PSP
 80085ee:	f000 b863 	b.w	80086b8 <UsageFault_Handler2>
 80085f2:	f3ef 8008 	mrs	r0, MSP
 80085f6:	f000 b85f 	b.w	80086b8 <UsageFault_Handler2>
 80085fa:	1c23      	adds	r3, r4, #0
 80085fc:	f248 50d1 	movw	r0, #34257	; 0x85d1
 8008600:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008604:	1c19      	adds	r1, r3, #0
 8008606:	f004 fb0d 	bl	800cc24 <__cyg_profile_func_exit>
 800860a:	bf00      	nop

0800860c <HardFault_Handler2>:
/* this is a hackaround to avoid an issue where dereferencing SCB seems to result in bad codegen and a link error */
#define SCB_REG(_reg)	(*(uint32_t *)&(SCB->_reg))

void
HardFault_Handler2(struct cm3_frame *frame)
{
 800860c:	b500      	push	{lr}
 800860e:	b083      	sub	sp, #12
 8008610:	4673      	mov	r3, lr
 8008612:	9001      	str	r0, [sp, #4]
 8008614:	f248 600d 	movw	r0, #34317	; 0x860d
 8008618:	f6c0 0000 	movt	r0, #2048	; 0x800
 800861c:	1c19      	adds	r1, r3, #0
 800861e:	f004 faf3 	bl	800cc08 <__cyg_profile_func_enter>
	dbg_write_str("\nHARD FAULT");
 8008622:	f64d 206c 	movw	r0, #55916	; 0xda6c
 8008626:	f6c0 0000 	movt	r0, #2048	; 0x800
 800862a:	f7ff fed7 	bl	80083dc <dbg_write_str>
	dbg_write_hex32(frame->pc);
 800862e:	9b01      	ldr	r3, [sp, #4]
 8008630:	699b      	ldr	r3, [r3, #24]
 8008632:	1c18      	adds	r0, r3, #0
 8008634:	f7ff ff60 	bl	80084f8 <dbg_write_hex32>
	dbg_write_char('\n');
 8008638:	200a      	movs	r0, #10
 800863a:	f7ff ff3b 	bl	80084b4 <dbg_write_char>
	dbg_write_hex32(SCB_REG(HFSR));
 800863e:	f64e 532c 	movw	r3, #60716	; 0xed2c
 8008642:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8008646:	681b      	ldr	r3, [r3, #0]
 8008648:	1c18      	adds	r0, r3, #0
 800864a:	f7ff ff55 	bl	80084f8 <dbg_write_hex32>
	dbg_write_char('\n');
 800864e:	200a      	movs	r0, #10
 8008650:	f7ff ff30 	bl	80084b4 <dbg_write_char>
	for (;;);
 8008654:	e7fe      	b.n	8008654 <HardFault_Handler2+0x48>
 8008656:	bf00      	nop

08008658 <BusFault_Handler2>:
}

void
BusFault_Handler2(struct cm3_frame *frame)
{
 8008658:	b500      	push	{lr}
 800865a:	b083      	sub	sp, #12
 800865c:	4673      	mov	r3, lr
 800865e:	9001      	str	r0, [sp, #4]
 8008660:	f248 6059 	movw	r0, #34393	; 0x8659
 8008664:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008668:	1c19      	adds	r1, r3, #0
 800866a:	f004 facd 	bl	800cc08 <__cyg_profile_func_enter>
	dbg_write_str("\nBUS FAULT");
 800866e:	f64d 2078 	movw	r0, #55928	; 0xda78
 8008672:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008676:	f7ff feb1 	bl	80083dc <dbg_write_str>
	dbg_write_hex32(frame->pc);
 800867a:	9b01      	ldr	r3, [sp, #4]
 800867c:	699b      	ldr	r3, [r3, #24]
 800867e:	1c18      	adds	r0, r3, #0
 8008680:	f7ff ff3a 	bl	80084f8 <dbg_write_hex32>
	dbg_write_char('\n');
 8008684:	200a      	movs	r0, #10
 8008686:	f7ff ff15 	bl	80084b4 <dbg_write_char>
	dbg_write_hex32(SCB_REG(CFSR));
 800868a:	f64e 5328 	movw	r3, #60712	; 0xed28
 800868e:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8008692:	681b      	ldr	r3, [r3, #0]
 8008694:	1c18      	adds	r0, r3, #0
 8008696:	f7ff ff2f 	bl	80084f8 <dbg_write_hex32>
	dbg_write_char('\n');
 800869a:	200a      	movs	r0, #10
 800869c:	f7ff ff0a 	bl	80084b4 <dbg_write_char>
	dbg_write_hex32(SCB_REG(BFAR));
 80086a0:	f64e 5338 	movw	r3, #60728	; 0xed38
 80086a4:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80086a8:	681b      	ldr	r3, [r3, #0]
 80086aa:	1c18      	adds	r0, r3, #0
 80086ac:	f7ff ff24 	bl	80084f8 <dbg_write_hex32>
	dbg_write_char('\n');
 80086b0:	200a      	movs	r0, #10
 80086b2:	f7ff feff 	bl	80084b4 <dbg_write_char>
	for (;;);
 80086b6:	e7fe      	b.n	80086b6 <BusFault_Handler2+0x5e>

080086b8 <UsageFault_Handler2>:
}

void
UsageFault_Handler2(struct cm3_frame *frame)
{
 80086b8:	b500      	push	{lr}
 80086ba:	b083      	sub	sp, #12
 80086bc:	4673      	mov	r3, lr
 80086be:	9001      	str	r0, [sp, #4]
 80086c0:	f248 60b9 	movw	r0, #34489	; 0x86b9
 80086c4:	f6c0 0000 	movt	r0, #2048	; 0x800
 80086c8:	1c19      	adds	r1, r3, #0
 80086ca:	f004 fa9d 	bl	800cc08 <__cyg_profile_func_enter>
	dbg_write_str("\nUSAGE FAULT");
 80086ce:	f64d 2084 	movw	r0, #55940	; 0xda84
 80086d2:	f6c0 0000 	movt	r0, #2048	; 0x800
 80086d6:	f7ff fe81 	bl	80083dc <dbg_write_str>
	dbg_write_hex32(frame->pc);
 80086da:	9b01      	ldr	r3, [sp, #4]
 80086dc:	699b      	ldr	r3, [r3, #24]
 80086de:	1c18      	adds	r0, r3, #0
 80086e0:	f7ff ff0a 	bl	80084f8 <dbg_write_hex32>
	dbg_write_char('\n');
 80086e4:	200a      	movs	r0, #10
 80086e6:	f7ff fee5 	bl	80084b4 <dbg_write_char>
	dbg_write_hex32(SCB_REG(CFSR));
 80086ea:	f64e 5328 	movw	r3, #60712	; 0xed28
 80086ee:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80086f2:	681b      	ldr	r3, [r3, #0]
 80086f4:	1c18      	adds	r0, r3, #0
 80086f6:	f7ff feff 	bl	80084f8 <dbg_write_hex32>
	dbg_write_char('\n');
 80086fa:	200a      	movs	r0, #10
 80086fc:	f7ff feda 	bl	80084b4 <dbg_write_char>
	for (;;);
 8008700:	e7fe      	b.n	8008700 <UsageFault_Handler2+0x48>
 8008702:	bf00      	nop

08008704 <_main>:
/**
 * Initial startup code.
 */
void
_main(void)
{
 8008704:	4673      	mov	r3, lr
 8008706:	f248 7005 	movw	r0, #34565	; 0x8705
 800870a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800870e:	4619      	mov	r1, r3
 8008710:	f004 fa7a 	bl	800cc08 <__cyg_profile_func_enter>
	asm volatile ("mov r10, %0" : : "r" (&irq_stack[0]) : );
 8008714:	f240 0300 	movw	r3, #0
 8008718:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800871c:	469a      	mov	sl, r3

	//*(volatile unsigned long*)0xe000ed24 = 3 << 17;	// extra fault handlers

	*(volatile unsigned long *)0xE000ED88 |= (0xf << 20);	// turn on CP10/11 for FP support on cores that implement it
 800871e:	f64e 5388 	movw	r3, #60808	; 0xed88
 8008722:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8008726:	f64e 5288 	movw	r2, #60808	; 0xed88
 800872a:	f2ce 0200 	movt	r2, #57344	; 0xe000
 800872e:	6812      	ldr	r2, [r2, #0]
 8008730:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8008734:	601a      	str	r2, [r3, #0]

	/* copy initialised data from flash to RAM */
	memcpy(&_sdata, &_sidata, &_edata - &_sdata);
 8008736:	f240 4238 	movw	r2, #1080	; 0x438
 800873a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800873e:	f240 4300 	movw	r3, #1024	; 0x400
 8008742:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008746:	1ad3      	subs	r3, r2, r3
 8008748:	f240 4000 	movw	r0, #1024	; 0x400
 800874c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8008750:	f24e 015c 	movw	r1, #57436	; 0xe05c
 8008754:	f6c0 0100 	movt	r1, #2048	; 0x800
 8008758:	461a      	mov	r2, r3
 800875a:	f005 f87d 	bl	800d858 <memcpy>

	/* zero the BSS */
	memset(&_sbss, 0, &_ebss - &_sbss);
 800875e:	f240 52be 	movw	r2, #1470	; 0x5be
 8008762:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8008766:	f240 4338 	movw	r3, #1080	; 0x438
 800876a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800876e:	1ad3      	subs	r3, r2, r3
 8008770:	f240 4038 	movw	r0, #1080	; 0x438
 8008774:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8008778:	f04f 0100 	mov.w	r1, #0
 800877c:	461a      	mov	r2, r3
 800877e:	f005 f8af 	bl	800d8e0 <memset>

	/* fill most of the IRQ/bootstrap stack with a watermark pattern so we can measure how much is used */
	/* leave a little space at the top in case memset() isn't a leaf with no locals */
	memset(&irq_stack, 0xa5, sizeof(irq_stack) - 64);
 8008782:	f240 0000 	movw	r0, #0
 8008786:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800878a:	f04f 01a5 	mov.w	r1, #165	; 0xa5
 800878e:	f44f 7270 	mov.w	r2, #960	; 0x3c0
 8008792:	f005 f8a5 	bl	800d8e0 <memset>

	/* call main */
	(void)main();
 8008796:	f7ff fd13 	bl	80081c0 <main>
 800879a:	bf00      	nop

0800879c <DebugMon_Handler>:
/**
 * Default handler for CPU exceptions.
 */
static void
default_cpu_handler(void)
{
 800879c:	4673      	mov	r3, lr
 800879e:	f248 709d 	movw	r0, #34717	; 0x879d
 80087a2:	f6c0 0000 	movt	r0, #2048	; 0x800
 80087a6:	4619      	mov	r1, r3
 80087a8:	f004 fa2e 	bl	800cc08 <__cyg_profile_func_enter>
	for (;;) ;
 80087ac:	e7fe      	b.n	80087ac <DebugMon_Handler+0x10>
 80087ae:	bf00      	nop

080087b0 <ADC_IRQHandler>:
typedef const void	(vector)(void);

/** default interrupt handler */
static void
default_io_handler(void)
{
 80087b0:	b508      	push	{r3, lr}
 80087b2:	4673      	mov	r3, lr
 80087b4:	f248 70b1 	movw	r0, #34737	; 0x87b1
 80087b8:	f6c0 0000 	movt	r0, #2048	; 0x800
 80087bc:	4619      	mov	r1, r3
 80087be:	f004 fa23 	bl	800cc08 <__cyg_profile_func_enter>
	for (;;) ;
 80087c2:	e7fe      	b.n	80087c2 <ADC_IRQHandler+0x12>

080087c4 <PIOS_SYS_Init>:

/**
* Initialises all system peripherals
*/
void PIOS_SYS_Init(void)
{
 80087c4:	b510      	push	{r4, lr}
 80087c6:	b082      	sub	sp, #8
 80087c8:	4674      	mov	r4, lr
 80087ca:	4623      	mov	r3, r4
 80087cc:	f248 70c5 	movw	r0, #34757	; 0x87c5
 80087d0:	f6c0 0000 	movt	r0, #2048	; 0x800
 80087d4:	4619      	mov	r1, r3
 80087d6:	f004 fa17 	bl	800cc08 <__cyg_profile_func_enter>
	/* Setup STM32 system (RCC, clock, PLL and Flash configuration) - CMSIS Function */
	SystemInit();
 80087da:	f001 f95d 	bl	8009a98 <SystemInit>
	SystemCoreClockUpdate();	/* update SystemCoreClock for use elsewhere */
 80087de:	f001 f9b5 	bl	8009b4c <SystemCoreClockUpdate>
	 * having to use the clunky get-all-clocks API everytime we need one.
	 */

	/* Initialise Basic NVIC */
	/* do this early to ensure that we take exceptions in the right place */
	NVIC_Configuration();
 80087e2:	f000 f89d 	bl	8008920 <NVIC_Configuration>

	/* Init the delay system */
	PIOS_DELAY_Init();
 80087e6:	f000 f937 	bl	8008a58 <PIOS_DELAY_Init>
	PIOS_DELAY_WaitmS(500);		/* XXX wait for the OpenOCD DCC stuff to get its act together */
 80087ea:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80087ee:	f000 f9d5 	bl	8008b9c <PIOS_DELAY_WaitmS>

	/* Debug services */
	PIOS_DEBUG_Init();
 80087f2:	f000 fbe9 	bl	8008fc8 <PIOS_DEBUG_Init>
	/*
	 * Turn on all the peripheral clocks.
	 * Micromanaging clocks makes no sense given the power situation in the system, so
	 * light up everything we might reasonably use here and just leave it on.
	 */
	RCC_AHB1PeriphClockCmd(
 80087f6:	f249 10ff 	movw	r0, #37375	; 0x91ff
 80087fa:	f2c0 0067 	movt	r0, #103	; 0x67
 80087fe:	f04f 0101 	mov.w	r1, #1
 8008802:	f001 fd7d 	bl	800a300 <RCC_AHB1PeriphClockCmd>
			       //RCC_AHB1Periph_ETH_MAC_Rx |
			       //RCC_AHB1Periph_ETH_MAC_PTP |
			       //RCC_AHB1Periph_OTG_HS |			No high-speed USB (requires external PHY)
			       //RCC_AHB1Periph_OTG_HS_ULPI |		No ULPI PHY (see above)
			0, ENABLE);
	RCC_AHB2PeriphClockCmd(
 8008806:	f04f 0080 	mov.w	r0, #128	; 0x80
 800880a:	f04f 0101 	mov.w	r1, #1
 800880e:	f001 fdaf 	bl	800a370 <RCC_AHB2PeriphClockCmd>
			       //RCC_AHB2Periph_CRYP |				No crypto
			       //RCC_AHB2Periph_HASH |				No hash generator
			       //RCC_AHB2Periph_RNG |				No random numbers @todo might be good to have later if entropy is desired
			       RCC_AHB2Periph_OTG_FS |
			0, ENABLE);
	RCC_AHB3PeriphClockCmd(
 8008812:	f04f 0000 	mov.w	r0, #0
 8008816:	f04f 0101 	mov.w	r1, #1
 800881a:	f001 fde1 	bl	800a3e0 <RCC_AHB3PeriphClockCmd>
			       //RCC_AHB3Periph_FSMC |				No external static memory
			0, ENABLE);
	RCC_APB1PeriphClockCmd(
 800881e:	f64c 10ff 	movw	r0, #51711	; 0xc9ff
 8008822:	f2c3 60fe 	movt	r0, #14078	; 0x36fe
 8008826:	f04f 0101 	mov.w	r1, #1
 800882a:	f001 fe11 	bl	800a450 <RCC_APB1PeriphClockCmd>
			       RCC_APB1Periph_CAN2 |
			       RCC_APB1Periph_PWR |
			       RCC_APB1Periph_DAC |
			0, ENABLE);

	RCC_APB2PeriphClockCmd(
 800882e:	f645 7033 	movw	r0, #24371	; 0x5f33
 8008832:	f2c0 0007 	movt	r0, #7
 8008836:	f04f 0101 	mov.w	r1, #1
 800883a:	f001 fe41 	bl	800a4c0 <RCC_APB2PeriphClockCmd>
	 * Configure all pins as input / pullup to avoid issues with
	 * uncommitted pins, excepting special-function pins that we need to
	 * remain as-is.
	 */
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_StructInit(&GPIO_InitStructure);
 800883e:	466b      	mov	r3, sp
 8008840:	4618      	mov	r0, r3
 8008842:	f001 fc21 	bl	800a088 <GPIO_StructInit>
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	// default is un-pulled input
 8008846:	f04f 0301 	mov.w	r3, #1
 800884a:	f88d 3007 	strb.w	r3, [sp, #7]

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
 800884e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8008852:	9300      	str	r3, [sp, #0]
#if (PIOS_USB_ENABLED)
	GPIO_InitStructure.GPIO_Pin &= ~(GPIO_Pin_11 | GPIO_Pin_12);				// leave USB D+/D- alone
 8008854:	9b00      	ldr	r3, [sp, #0]
 8008856:	f423 53c0 	bic.w	r3, r3, #6144	; 0x1800
 800885a:	9300      	str	r3, [sp, #0]
#endif
	GPIO_InitStructure.GPIO_Pin &= ~(GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15);	// leave JTAG pins alone
 800885c:	9b00      	ldr	r3, [sp, #0]
 800885e:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8008862:	9300      	str	r3, [sp, #0]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8008864:	466b      	mov	r3, sp
 8008866:	f04f 0000 	mov.w	r0, #0
 800886a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800886e:	4619      	mov	r1, r3
 8008870:	f001 fb5a 	bl	8009f28 <GPIO_Init>

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
 8008874:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8008878:	9300      	str	r3, [sp, #0]
	GPIO_InitStructure.GPIO_Pin &= ~(GPIO_Pin_3 | GPIO_Pin_4);					// leave JTAG pins alone
 800887a:	9b00      	ldr	r3, [sp, #0]
 800887c:	f023 0318 	bic.w	r3, r3, #24
 8008880:	9300      	str	r3, [sp, #0]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8008882:	466b      	mov	r3, sp
 8008884:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8008888:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800888c:	4619      	mov	r1, r3
 800888e:	f001 fb4b 	bl	8009f28 <GPIO_Init>

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
 8008892:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8008896:	9300      	str	r3, [sp, #0]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8008898:	466b      	mov	r3, sp
 800889a:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800889e:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80088a2:	4619      	mov	r1, r3
 80088a4:	f001 fb40 	bl	8009f28 <GPIO_Init>
	GPIO_Init(GPIOD, &GPIO_InitStructure);
 80088a8:	466b      	mov	r3, sp
 80088aa:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 80088ae:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80088b2:	4619      	mov	r1, r3
 80088b4:	f001 fb38 	bl	8009f28 <GPIO_Init>
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 80088b8:	466b      	mov	r3, sp
 80088ba:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80088be:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80088c2:	4619      	mov	r1, r3
 80088c4:	f001 fb30 	bl	8009f28 <GPIO_Init>
	GPIO_Init(GPIOF, &GPIO_InitStructure);
 80088c8:	466b      	mov	r3, sp
 80088ca:	f44f 50a0 	mov.w	r0, #5120	; 0x1400
 80088ce:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80088d2:	4619      	mov	r1, r3
 80088d4:	f001 fb28 	bl	8009f28 <GPIO_Init>
	GPIO_Init(GPIOG, &GPIO_InitStructure);
 80088d8:	466b      	mov	r3, sp
 80088da:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
 80088de:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80088e2:	4619      	mov	r1, r3
 80088e4:	f001 fb20 	bl	8009f28 <GPIO_Init>
	GPIO_Init(GPIOH, &GPIO_InitStructure);
 80088e8:	466b      	mov	r3, sp
 80088ea:	f44f 50e0 	mov.w	r0, #7168	; 0x1c00
 80088ee:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80088f2:	4619      	mov	r1, r3
 80088f4:	f001 fb18 	bl	8009f28 <GPIO_Init>
	GPIO_Init(GPIOI, &GPIO_InitStructure);
 80088f8:	466b      	mov	r3, sp
 80088fa:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 80088fe:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8008902:	4619      	mov	r1, r3
 8008904:	f001 fb10 	bl	8009f28 <GPIO_Init>

#if defined(PIOS_INCLUDE_LED)
	/* Initialise LEDs */
	PIOS_LED_Init();
 8008908:	f000 f82e 	bl	8008968 <PIOS_LED_Init>
 800890c:	4623      	mov	r3, r4
 800890e:	f248 70c5 	movw	r0, #34757	; 0x87c5
 8008912:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008916:	4619      	mov	r1, r3
 8008918:	f004 f984 	bl	800cc24 <__cyg_profile_func_exit>
#endif
}
 800891c:	b002      	add	sp, #8
 800891e:	bd10      	pop	{r4, pc}

08008920 <NVIC_Configuration>:

/**
* Configures Vector Table base location and SysTick
*/
static void NVIC_Configuration(void)
{
 8008920:	b510      	push	{r4, lr}
 8008922:	4674      	mov	r4, lr
 8008924:	4623      	mov	r3, r4
 8008926:	f648 1021 	movw	r0, #35105	; 0x8921
 800892a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800892e:	4619      	mov	r1, r3
 8008930:	f004 f96a 	bl	800cc08 <__cyg_profile_func_enter>
	/* Set the Vector Table base address as specified in .ld file */
	extern void *pios_isr_vector_table_base;
	NVIC_SetVectorTable((uint32_t)&pios_isr_vector_table_base, 0x0);
 8008934:	f248 0300 	movw	r3, #32768	; 0x8000
 8008938:	f6c0 0300 	movt	r3, #2048	; 0x800
 800893c:	4618      	mov	r0, r3
 800893e:	f04f 0100 	mov.w	r1, #0
 8008942:	f001 fe79 	bl	800a638 <NVIC_SetVectorTable>

	/* 4 bits for Interrupt priorities so no sub priorities */
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
 8008946:	f44f 7040 	mov.w	r0, #768	; 0x300
 800894a:	f001 fe55 	bl	800a5f8 <NVIC_PriorityGroupConfig>

	/* Configure HCLK clock as SysTick clock source. */
	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);
 800894e:	f04f 0004 	mov.w	r0, #4
 8008952:	f001 fe95 	bl	800a680 <SysTick_CLKSourceConfig>
 8008956:	4623      	mov	r3, r4
 8008958:	f648 1021 	movw	r0, #35105	; 0x8921
 800895c:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008960:	4619      	mov	r1, r3
 8008962:	f004 f95f 	bl	800cc24 <__cyg_profile_func_exit>
}
 8008966:	bd10      	pop	{r4, pc}

08008968 <PIOS_LED_Init>:

/**
* Initialises all the LED's
*/
void PIOS_LED_Init(void)
{
 8008968:	b510      	push	{r4, lr}
 800896a:	b084      	sub	sp, #16
 800896c:	4674      	mov	r4, lr
 800896e:	4623      	mov	r3, r4
 8008970:	f648 1069 	movw	r0, #35177	; 0x8969
 8008974:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008978:	4619      	mov	r1, r3
 800897a:	f004 f945 	bl	800cc08 <__cyg_profile_func_enter>
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 800897e:	f04f 0301 	mov.w	r3, #1
 8008982:	f88d 3008 	strb.w	r3, [sp, #8]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8008986:	f04f 0300 	mov.w	r3, #0
 800898a:	f88d 300a 	strb.w	r3, [sp, #10]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800898e:	f04f 0302 	mov.w	r3, #2
 8008992:	f88d 3009 	strb.w	r3, [sp, #9]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8008996:	f04f 0300 	mov.w	r3, #0
 800899a:	f88d 300b 	strb.w	r3, [sp, #11]

	for (int LEDNum = 0; LEDNum < PIOS_LED_NUM; LEDNum++) {
 800899e:	f04f 0300 	mov.w	r3, #0
 80089a2:	9303      	str	r3, [sp, #12]
 80089a4:	e01c      	b.n	80089e0 <PIOS_LED_Init+0x78>
		GPIO_InitStructure.GPIO_Pin = LED_GPIO_PIN[LEDNum];
 80089a6:	f64d 2394 	movw	r3, #55956	; 0xda94
 80089aa:	f6c0 0300 	movt	r3, #2048	; 0x800
 80089ae:	9a03      	ldr	r2, [sp, #12]
 80089b0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80089b4:	9301      	str	r3, [sp, #4]
		GPIO_Init(LED_GPIO_PORT[LEDNum], &GPIO_InitStructure);
 80089b6:	f240 4300 	movw	r3, #1024	; 0x400
 80089ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80089be:	9a03      	ldr	r2, [sp, #12]
 80089c0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80089c4:	ab01      	add	r3, sp, #4
 80089c6:	4610      	mov	r0, r2
 80089c8:	4619      	mov	r1, r3
 80089ca:	f001 faad 	bl	8009f28 <GPIO_Init>

		/* LED's Off */
		PIOS_LED_Off(LEDNum);
 80089ce:	9b03      	ldr	r3, [sp, #12]
 80089d0:	b2db      	uxtb	r3, r3
 80089d2:	4618      	mov	r0, r3
 80089d4:	f000 f812 	bl	80089fc <PIOS_LED_Off>
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;

	for (int LEDNum = 0; LEDNum < PIOS_LED_NUM; LEDNum++) {
 80089d8:	9b03      	ldr	r3, [sp, #12]
 80089da:	f103 0301 	add.w	r3, r3, #1
 80089de:	9303      	str	r3, [sp, #12]
 80089e0:	9b03      	ldr	r3, [sp, #12]
 80089e2:	2b01      	cmp	r3, #1
 80089e4:	dddf      	ble.n	80089a6 <PIOS_LED_Init+0x3e>
 80089e6:	4623      	mov	r3, r4
 80089e8:	f648 1069 	movw	r0, #35177	; 0x8969
 80089ec:	f6c0 0000 	movt	r0, #2048	; 0x800
 80089f0:	4619      	mov	r1, r3
 80089f2:	f004 f917 	bl	800cc24 <__cyg_profile_func_exit>
		GPIO_Init(LED_GPIO_PORT[LEDNum], &GPIO_InitStructure);

		/* LED's Off */
		PIOS_LED_Off(LEDNum);
	}
}
 80089f6:	b004      	add	sp, #16
 80089f8:	bd10      	pop	{r4, pc}
 80089fa:	bf00      	nop

080089fc <PIOS_LED_Off>:
/**
* Turn off LED
* \param[in] LED LED Name (LED1, LED2)
*/
void PIOS_LED_Off(LedTypeDef LED)
{
 80089fc:	b510      	push	{r4, lr}
 80089fe:	b082      	sub	sp, #8
 8008a00:	4674      	mov	r4, lr
 8008a02:	4603      	mov	r3, r0
 8008a04:	f88d 3007 	strb.w	r3, [sp, #7]
 8008a08:	4623      	mov	r3, r4
 8008a0a:	f648 10fd 	movw	r0, #35325	; 0x89fd
 8008a0e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008a12:	4619      	mov	r1, r3
 8008a14:	f004 f8f8 	bl	800cc08 <__cyg_profile_func_enter>
	GPIO_SetBits(LED_GPIO_PORT[LED], LED_GPIO_PIN[LED]);
 8008a18:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8008a1c:	f240 4300 	movw	r3, #1024	; 0x400
 8008a20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008a24:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8008a28:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8008a2c:	f64d 2394 	movw	r3, #55956	; 0xda94
 8008a30:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008a34:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8008a38:	b29b      	uxth	r3, r3
 8008a3a:	4610      	mov	r0, r2
 8008a3c:	4619      	mov	r1, r3
 8008a3e:	f001 fb4d 	bl	800a0dc <GPIO_SetBits>
 8008a42:	4623      	mov	r3, r4
 8008a44:	f648 10fd 	movw	r0, #35325	; 0x89fd
 8008a48:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008a4c:	4619      	mov	r1, r3
 8008a4e:	f004 f8e9 	bl	800cc24 <__cyg_profile_func_exit>
}
 8008a52:	b002      	add	sp, #8
 8008a54:	bd10      	pop	{r4, pc}
 8008a56:	bf00      	nop

08008a58 <PIOS_DELAY_Init>:
 *
 * \return always zero (success)
 */

int32_t PIOS_DELAY_Init(void)
{
 8008a58:	b530      	push	{r4, r5, lr}
 8008a5a:	b085      	sub	sp, #20
 8008a5c:	4674      	mov	r4, lr
 8008a5e:	4623      	mov	r3, r4
 8008a60:	f648 2059 	movw	r0, #35417	; 0x8a59
 8008a64:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008a68:	4619      	mov	r1, r3
 8008a6a:	f004 f8cd 	bl	800cc08 <__cyg_profile_func_enter>
	RCC_ClocksTypeDef	clocks;

	/* compute the number of system clocks per microsecond */
	RCC_GetClocksFreq(&clocks);
 8008a6e:	466b      	mov	r3, sp
 8008a70:	4618      	mov	r0, r3
 8008a72:	f001 fb51 	bl	800a118 <RCC_GetClocksFreq>
	us_ticks = clocks.SYSCLK_Frequency / 1000000;
 8008a76:	9a00      	ldr	r2, [sp, #0]
 8008a78:	f64d 6383 	movw	r3, #56963	; 0xde83
 8008a7c:	f2c4 331b 	movt	r3, #17179	; 0x431b
 8008a80:	fba3 1302 	umull	r1, r3, r3, r2
 8008a84:	ea4f 4293 	mov.w	r2, r3, lsr #18
 8008a88:	f240 4340 	movw	r3, #1088	; 0x440
 8008a8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008a90:	601a      	str	r2, [r3, #0]
	PIOS_DEBUG_Assert(us_ticks > 1);
 8008a92:	f240 4340 	movw	r3, #1088	; 0x440
 8008a96:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008a9a:	681b      	ldr	r3, [r3, #0]
 8008a9c:	2b01      	cmp	r3, #1
 8008a9e:	d807      	bhi.n	8008ab0 <PIOS_DELAY_Init+0x58>
 8008aa0:	f240 4308 	movw	r3, #1032	; 0x408
 8008aa4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008aa8:	681b      	ldr	r3, [r3, #0]
 8008aaa:	4618      	mov	r0, r3
 8008aac:	f000 faa0 	bl	8008ff0 <PIOS_DEBUG_Panic>

	/* turn on access to the DWT registers */
	CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8008ab0:	f64e 53f0 	movw	r3, #60912	; 0xedf0
 8008ab4:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8008ab8:	f64e 52f0 	movw	r2, #60912	; 0xedf0
 8008abc:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8008ac0:	68d2      	ldr	r2, [r2, #12]
 8008ac2:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8008ac6:	60da      	str	r2, [r3, #12]

	/* enable the CPU cycle counter */
	DWT_CTRL |= CYCCNTENA;
 8008ac8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8008acc:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8008ad0:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8008ad4:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8008ad8:	6812      	ldr	r2, [r2, #0]
 8008ada:	f042 0201 	orr.w	r2, r2, #1
 8008ade:	601a      	str	r2, [r3, #0]

	return 0;
 8008ae0:	f04f 0500 	mov.w	r5, #0
 8008ae4:	4623      	mov	r3, r4
 8008ae6:	f648 2059 	movw	r0, #35417	; 0x8a59
 8008aea:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008aee:	4619      	mov	r1, r3
 8008af0:	f004 f898 	bl	800cc24 <__cyg_profile_func_exit>
 8008af4:	462b      	mov	r3, r5
}
 8008af6:	4618      	mov	r0, r3
 8008af8:	b005      	add	sp, #20
 8008afa:	bd30      	pop	{r4, r5, pc}

08008afc <PIOS_DELAY_WaituS>:
 * \endcode
 * \param[in] uS delay
 * \return < 0 on errors
 */
int32_t PIOS_DELAY_WaituS(uint32_t uS)
{
 8008afc:	b530      	push	{r4, r5, lr}
 8008afe:	b087      	sub	sp, #28
 8008b00:	4674      	mov	r4, lr
 8008b02:	9001      	str	r0, [sp, #4]
 8008b04:	4623      	mov	r3, r4
 8008b06:	f648 20fd 	movw	r0, #35581	; 0x8afd
 8008b0a:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008b0e:	4619      	mov	r1, r3
 8008b10:	f004 f87a 	bl	800cc08 <__cyg_profile_func_enter>
	uint32_t	elapsed = 0;
 8008b14:	f04f 0300 	mov.w	r3, #0
 8008b18:	9305      	str	r3, [sp, #20]
	uint32_t	last_count = DWT_CYCCNT;
 8008b1a:	f241 0304 	movw	r3, #4100	; 0x1004
 8008b1e:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8008b22:	681b      	ldr	r3, [r3, #0]
 8008b24:	9304      	str	r3, [sp, #16]
	
	for (;;) {
		uint32_t current_count = DWT_CYCCNT;
 8008b26:	f241 0304 	movw	r3, #4100	; 0x1004
 8008b2a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8008b2e:	681b      	ldr	r3, [r3, #0]
 8008b30:	9303      	str	r3, [sp, #12]
		uint32_t elapsed_uS;

		/* measure the time elapsed since the last time we checked */
		elapsed += current_count - last_count;
 8008b32:	9a03      	ldr	r2, [sp, #12]
 8008b34:	9b04      	ldr	r3, [sp, #16]
 8008b36:	1ad3      	subs	r3, r2, r3
 8008b38:	9a05      	ldr	r2, [sp, #20]
 8008b3a:	18d3      	adds	r3, r2, r3
 8008b3c:	9305      	str	r3, [sp, #20]
		last_count = current_count;
 8008b3e:	9b03      	ldr	r3, [sp, #12]
 8008b40:	9304      	str	r3, [sp, #16]

		/* convert to microseconds */
		elapsed_uS = elapsed / us_ticks;
 8008b42:	f240 4340 	movw	r3, #1088	; 0x440
 8008b46:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008b4a:	681b      	ldr	r3, [r3, #0]
 8008b4c:	9a05      	ldr	r2, [sp, #20]
 8008b4e:	fbb2 f3f3 	udiv	r3, r2, r3
 8008b52:	9302      	str	r3, [sp, #8]
		if (elapsed_uS >= uS)
 8008b54:	9a02      	ldr	r2, [sp, #8]
 8008b56:	9b01      	ldr	r3, [sp, #4]
 8008b58:	429a      	cmp	r2, r3
 8008b5a:	d210      	bcs.n	8008b7e <PIOS_DELAY_WaituS+0x82>
			break;

		/* reduce the delay by the elapsed time */
		uS -= elapsed_uS;
 8008b5c:	9a01      	ldr	r2, [sp, #4]
 8008b5e:	9b02      	ldr	r3, [sp, #8]
 8008b60:	1ad3      	subs	r3, r2, r3
 8008b62:	9301      	str	r3, [sp, #4]

		/* keep fractional microseconds for the next iteration */
		elapsed %= us_ticks;
 8008b64:	f240 4340 	movw	r3, #1088	; 0x440
 8008b68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008b6c:	681a      	ldr	r2, [r3, #0]
 8008b6e:	9b05      	ldr	r3, [sp, #20]
 8008b70:	fbb3 f1f2 	udiv	r1, r3, r2
 8008b74:	fb02 f201 	mul.w	r2, r2, r1
 8008b78:	1a9b      	subs	r3, r3, r2
 8008b7a:	9305      	str	r3, [sp, #20]
	}
 8008b7c:	e7d3      	b.n	8008b26 <PIOS_DELAY_WaituS+0x2a>
		last_count = current_count;

		/* convert to microseconds */
		elapsed_uS = elapsed / us_ticks;
		if (elapsed_uS >= uS)
			break;
 8008b7e:	bf00      	nop
		/* keep fractional microseconds for the next iteration */
		elapsed %= us_ticks;
	}

	/* No error */
	return 0;
 8008b80:	f04f 0500 	mov.w	r5, #0
 8008b84:	4623      	mov	r3, r4
 8008b86:	f648 20fd 	movw	r0, #35581	; 0x8afd
 8008b8a:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008b8e:	4619      	mov	r1, r3
 8008b90:	f004 f848 	bl	800cc24 <__cyg_profile_func_exit>
 8008b94:	462b      	mov	r3, r5
}
 8008b96:	4618      	mov	r0, r3
 8008b98:	b007      	add	sp, #28
 8008b9a:	bd30      	pop	{r4, r5, pc}

08008b9c <PIOS_DELAY_WaitmS>:
 * \endcode
 * \param[in] mS delay (1..65535 milliseconds)
 * \return < 0 on errors
 */
int32_t PIOS_DELAY_WaitmS(uint32_t mS)
{
 8008b9c:	b530      	push	{r4, r5, lr}
 8008b9e:	b083      	sub	sp, #12
 8008ba0:	4674      	mov	r4, lr
 8008ba2:	9001      	str	r0, [sp, #4]
 8008ba4:	4623      	mov	r3, r4
 8008ba6:	f648 309d 	movw	r0, #35741	; 0x8b9d
 8008baa:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008bae:	4619      	mov	r1, r3
 8008bb0:	f004 f82a 	bl	800cc08 <__cyg_profile_func_enter>
	while (mS--) {
 8008bb4:	e003      	b.n	8008bbe <PIOS_DELAY_WaitmS+0x22>
		PIOS_DELAY_WaituS(1000);
 8008bb6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008bba:	f7ff ff9f 	bl	8008afc <PIOS_DELAY_WaituS>
 * \param[in] mS delay (1..65535 milliseconds)
 * \return < 0 on errors
 */
int32_t PIOS_DELAY_WaitmS(uint32_t mS)
{
	while (mS--) {
 8008bbe:	9b01      	ldr	r3, [sp, #4]
 8008bc0:	2b00      	cmp	r3, #0
 8008bc2:	bf0c      	ite	eq
 8008bc4:	2300      	moveq	r3, #0
 8008bc6:	2301      	movne	r3, #1
 8008bc8:	b2db      	uxtb	r3, r3
 8008bca:	9a01      	ldr	r2, [sp, #4]
 8008bcc:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
 8008bd0:	9201      	str	r2, [sp, #4]
 8008bd2:	2b00      	cmp	r3, #0
 8008bd4:	d1ef      	bne.n	8008bb6 <PIOS_DELAY_WaitmS+0x1a>
		PIOS_DELAY_WaituS(1000);
	}

	/* No error */
	return 0;
 8008bd6:	f04f 0500 	mov.w	r5, #0
 8008bda:	4623      	mov	r3, r4
 8008bdc:	f648 309d 	movw	r0, #35741	; 0x8b9d
 8008be0:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008be4:	4619      	mov	r1, r3
 8008be6:	f004 f81d 	bl	800cc24 <__cyg_profile_func_exit>
 8008bea:	462b      	mov	r3, r5
}
 8008bec:	4618      	mov	r0, r3
 8008bee:	b003      	add	sp, #12
 8008bf0:	bd30      	pop	{r4, r5, pc}
 8008bf2:	bf00      	nop

08008bf4 <PIOS_USART_validate>:
	pios_com_callback tx_out_cb;
	uint32_t tx_out_context;
};

static bool PIOS_USART_validate(struct pios_usart_dev * usart_dev)
{
 8008bf4:	b530      	push	{r4, r5, lr}
 8008bf6:	b083      	sub	sp, #12
 8008bf8:	4674      	mov	r4, lr
 8008bfa:	9001      	str	r0, [sp, #4]
 8008bfc:	4623      	mov	r3, r4
 8008bfe:	f648 30f5 	movw	r0, #35829	; 0x8bf5
 8008c02:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008c06:	4619      	mov	r1, r3
 8008c08:	f003 fffe 	bl	800cc08 <__cyg_profile_func_enter>
	return (usart_dev->magic == PIOS_USART_DEV_MAGIC);
 8008c0c:	9b01      	ldr	r3, [sp, #4]
 8008c0e:	681a      	ldr	r2, [r3, #0]
 8008c10:	f248 334a 	movw	r3, #33610	; 0x834a
 8008c14:	f2c4 1352 	movt	r3, #16722	; 0x4152
 8008c18:	429a      	cmp	r2, r3
 8008c1a:	bf14      	ite	ne
 8008c1c:	2300      	movne	r3, #0
 8008c1e:	2301      	moveq	r3, #1
 8008c20:	b2dd      	uxtb	r5, r3
 8008c22:	4623      	mov	r3, r4
 8008c24:	f648 30f5 	movw	r0, #35829	; 0x8bf5
 8008c28:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008c2c:	4619      	mov	r1, r3
 8008c2e:	f003 fff9 	bl	800cc24 <__cyg_profile_func_exit>
 8008c32:	462b      	mov	r3, r5
}
 8008c34:	4618      	mov	r0, r3
 8008c36:	b003      	add	sp, #12
 8008c38:	bd30      	pop	{r4, r5, pc}
 8008c3a:	bf00      	nop

08008c3c <USART1_IRQHandler>:
	{														\
		PIOS_USART_generic_irq_handler (PIOS_USART_ ## _n ## _id); \
	}														\
	struct hack

USART_HANDLER(1);
 8008c3c:	b510      	push	{r4, lr}
 8008c3e:	4674      	mov	r4, lr
 8008c40:	4623      	mov	r3, r4
 8008c42:	f648 403d 	movw	r0, #35901	; 0x8c3d
 8008c46:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008c4a:	4619      	mov	r1, r3
 8008c4c:	f003 ffdc 	bl	800cc08 <__cyg_profile_func_enter>
 8008c50:	f240 4344 	movw	r3, #1092	; 0x444
 8008c54:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008c58:	681b      	ldr	r3, [r3, #0]
 8008c5a:	4618      	mov	r0, r3
 8008c5c:	f000 f896 	bl	8008d8c <PIOS_USART_generic_irq_handler>
 8008c60:	4623      	mov	r3, r4
 8008c62:	f648 403d 	movw	r0, #35901	; 0x8c3d
 8008c66:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008c6a:	4619      	mov	r1, r3
 8008c6c:	f003 ffda 	bl	800cc24 <__cyg_profile_func_exit>
 8008c70:	bd10      	pop	{r4, pc}
 8008c72:	bf00      	nop

08008c74 <USART2_IRQHandler>:
USART_HANDLER(2);
 8008c74:	b510      	push	{r4, lr}
 8008c76:	4674      	mov	r4, lr
 8008c78:	4623      	mov	r3, r4
 8008c7a:	f648 4075 	movw	r0, #35957	; 0x8c75
 8008c7e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008c82:	4619      	mov	r1, r3
 8008c84:	f003 ffc0 	bl	800cc08 <__cyg_profile_func_enter>
 8008c88:	f240 4348 	movw	r3, #1096	; 0x448
 8008c8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008c90:	681b      	ldr	r3, [r3, #0]
 8008c92:	4618      	mov	r0, r3
 8008c94:	f000 f87a 	bl	8008d8c <PIOS_USART_generic_irq_handler>
 8008c98:	4623      	mov	r3, r4
 8008c9a:	f648 4075 	movw	r0, #35957	; 0x8c75
 8008c9e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008ca2:	4619      	mov	r1, r3
 8008ca4:	f003 ffbe 	bl	800cc24 <__cyg_profile_func_exit>
 8008ca8:	bd10      	pop	{r4, pc}
 8008caa:	bf00      	nop

08008cac <USART3_IRQHandler>:
USART_HANDLER(3);
 8008cac:	b510      	push	{r4, lr}
 8008cae:	4674      	mov	r4, lr
 8008cb0:	4623      	mov	r3, r4
 8008cb2:	f648 40ad 	movw	r0, #36013	; 0x8cad
 8008cb6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008cba:	4619      	mov	r1, r3
 8008cbc:	f003 ffa4 	bl	800cc08 <__cyg_profile_func_enter>
 8008cc0:	f240 434c 	movw	r3, #1100	; 0x44c
 8008cc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008cc8:	681b      	ldr	r3, [r3, #0]
 8008cca:	4618      	mov	r0, r3
 8008ccc:	f000 f85e 	bl	8008d8c <PIOS_USART_generic_irq_handler>
 8008cd0:	4623      	mov	r3, r4
 8008cd2:	f648 40ad 	movw	r0, #36013	; 0x8cad
 8008cd6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008cda:	4619      	mov	r1, r3
 8008cdc:	f003 ffa2 	bl	800cc24 <__cyg_profile_func_exit>
 8008ce0:	bd10      	pop	{r4, pc}
 8008ce2:	bf00      	nop

08008ce4 <USART4_IRQHandler>:
USART_HANDLER(4);
 8008ce4:	b510      	push	{r4, lr}
 8008ce6:	4674      	mov	r4, lr
 8008ce8:	4623      	mov	r3, r4
 8008cea:	f648 40e5 	movw	r0, #36069	; 0x8ce5
 8008cee:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008cf2:	4619      	mov	r1, r3
 8008cf4:	f003 ff88 	bl	800cc08 <__cyg_profile_func_enter>
 8008cf8:	f240 4350 	movw	r3, #1104	; 0x450
 8008cfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008d00:	681b      	ldr	r3, [r3, #0]
 8008d02:	4618      	mov	r0, r3
 8008d04:	f000 f842 	bl	8008d8c <PIOS_USART_generic_irq_handler>
 8008d08:	4623      	mov	r3, r4
 8008d0a:	f648 40e5 	movw	r0, #36069	; 0x8ce5
 8008d0e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008d12:	4619      	mov	r1, r3
 8008d14:	f003 ff86 	bl	800cc24 <__cyg_profile_func_exit>
 8008d18:	bd10      	pop	{r4, pc}
 8008d1a:	bf00      	nop

08008d1c <USART5_IRQHandler>:
USART_HANDLER(5);
 8008d1c:	b510      	push	{r4, lr}
 8008d1e:	4674      	mov	r4, lr
 8008d20:	4623      	mov	r3, r4
 8008d22:	f648 501d 	movw	r0, #36125	; 0x8d1d
 8008d26:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008d2a:	4619      	mov	r1, r3
 8008d2c:	f003 ff6c 	bl	800cc08 <__cyg_profile_func_enter>
 8008d30:	f240 4354 	movw	r3, #1108	; 0x454
 8008d34:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008d38:	681b      	ldr	r3, [r3, #0]
 8008d3a:	4618      	mov	r0, r3
 8008d3c:	f000 f826 	bl	8008d8c <PIOS_USART_generic_irq_handler>
 8008d40:	4623      	mov	r3, r4
 8008d42:	f648 501d 	movw	r0, #36125	; 0x8d1d
 8008d46:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008d4a:	4619      	mov	r1, r3
 8008d4c:	f003 ff6a 	bl	800cc24 <__cyg_profile_func_exit>
 8008d50:	bd10      	pop	{r4, pc}
 8008d52:	bf00      	nop

08008d54 <USART6_IRQHandler>:
USART_HANDLER(6);
 8008d54:	b510      	push	{r4, lr}
 8008d56:	4674      	mov	r4, lr
 8008d58:	4623      	mov	r3, r4
 8008d5a:	f648 5055 	movw	r0, #36181	; 0x8d55
 8008d5e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008d62:	4619      	mov	r1, r3
 8008d64:	f003 ff50 	bl	800cc08 <__cyg_profile_func_enter>
 8008d68:	f240 4358 	movw	r3, #1112	; 0x458
 8008d6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008d70:	681b      	ldr	r3, [r3, #0]
 8008d72:	4618      	mov	r0, r3
 8008d74:	f000 f80a 	bl	8008d8c <PIOS_USART_generic_irq_handler>
 8008d78:	4623      	mov	r3, r4
 8008d7a:	f648 5055 	movw	r0, #36181	; 0x8d55
 8008d7e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008d82:	4619      	mov	r1, r3
 8008d84:	f003 ff4e 	bl	800cc24 <__cyg_profile_func_exit>
 8008d88:	bd10      	pop	{r4, pc}
 8008d8a:	bf00      	nop

08008d8c <PIOS_USART_generic_irq_handler>:
	usart_dev->tx_out_context = context;
	usart_dev->tx_out_cb = tx_out_cb;
}

static void PIOS_USART_generic_irq_handler(uint32_t usart_id)
{
 8008d8c:	b530      	push	{r4, r5, lr}
 8008d8e:	b089      	sub	sp, #36	; 0x24
 8008d90:	4674      	mov	r4, lr
 8008d92:	9003      	str	r0, [sp, #12]
 8008d94:	4623      	mov	r3, r4
 8008d96:	f648 508d 	movw	r0, #36237	; 0x8d8d
 8008d9a:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008d9e:	4619      	mov	r1, r3
 8008da0:	f003 ff32 	bl	800cc08 <__cyg_profile_func_enter>
	struct pios_usart_dev * usart_dev = (struct pios_usart_dev *)usart_id;
 8008da4:	9b03      	ldr	r3, [sp, #12]
 8008da6:	9307      	str	r3, [sp, #28]

	bool valid = PIOS_USART_validate(usart_dev);
 8008da8:	9807      	ldr	r0, [sp, #28]
 8008daa:	f7ff ff23 	bl	8008bf4 <PIOS_USART_validate>
 8008dae:	4603      	mov	r3, r0
 8008db0:	f88d 301b 	strb.w	r3, [sp, #27]
	PIOS_Assert(valid);
 8008db4:	f89d 301b 	ldrb.w	r3, [sp, #27]
 8008db8:	f083 0301 	eor.w	r3, r3, #1
 8008dbc:	b2db      	uxtb	r3, r3
 8008dbe:	2b00      	cmp	r3, #0
 8008dc0:	d007      	beq.n	8008dd2 <PIOS_USART_generic_irq_handler+0x46>
 8008dc2:	f240 4308 	movw	r3, #1032	; 0x408
 8008dc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008dca:	681b      	ldr	r3, [r3, #0]
 8008dcc:	4618      	mov	r0, r3
 8008dce:	f000 f90f 	bl	8008ff0 <PIOS_DEBUG_Panic>
	
	/* Force read of dr after sr to make sure to clear error flags */
	volatile uint16_t sr = usart_dev->cfg->regs->SR;
 8008dd2:	9b07      	ldr	r3, [sp, #28]
 8008dd4:	685b      	ldr	r3, [r3, #4]
 8008dd6:	681b      	ldr	r3, [r3, #0]
 8008dd8:	881b      	ldrh	r3, [r3, #0]
 8008dda:	b29b      	uxth	r3, r3
 8008ddc:	f8ad 3016 	strh.w	r3, [sp, #22]
	volatile uint8_t dr = usart_dev->cfg->regs->DR;
 8008de0:	9b07      	ldr	r3, [sp, #28]
 8008de2:	685b      	ldr	r3, [r3, #4]
 8008de4:	681b      	ldr	r3, [r3, #0]
 8008de6:	889b      	ldrh	r3, [r3, #4]
 8008de8:	b29b      	uxth	r3, r3
 8008dea:	b2db      	uxtb	r3, r3
 8008dec:	f88d 3015 	strb.w	r3, [sp, #21]
	
	/* Check if RXNE flag is set */
	bool rx_need_yield = false;
 8008df0:	f04f 0300 	mov.w	r3, #0
 8008df4:	f88d 3014 	strb.w	r3, [sp, #20]
	if (sr & USART_SR_RXNE) {
 8008df8:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8008dfc:	b29b      	uxth	r3, r3
 8008dfe:	f003 0320 	and.w	r3, r3, #32
 8008e02:	2b00      	cmp	r3, #0
 8008e04:	d017      	beq.n	8008e36 <PIOS_USART_generic_irq_handler+0xaa>
		uint8_t byte = dr;
 8008e06:	f89d 3015 	ldrb.w	r3, [sp, #21]
 8008e0a:	b2db      	uxtb	r3, r3
 8008e0c:	f88d 3012 	strb.w	r3, [sp, #18]
		if (usart_dev->rx_in_cb) {
 8008e10:	9b07      	ldr	r3, [sp, #28]
 8008e12:	689b      	ldr	r3, [r3, #8]
 8008e14:	2b00      	cmp	r3, #0
 8008e16:	d00e      	beq.n	8008e36 <PIOS_USART_generic_irq_handler+0xaa>
			(void) (usart_dev->rx_in_cb)(usart_dev->rx_in_context, &byte, 1, NULL, &rx_need_yield);
 8008e18:	9b07      	ldr	r3, [sp, #28]
 8008e1a:	689d      	ldr	r5, [r3, #8]
 8008e1c:	9b07      	ldr	r3, [sp, #28]
 8008e1e:	68da      	ldr	r2, [r3, #12]
 8008e20:	f10d 0312 	add.w	r3, sp, #18
 8008e24:	a905      	add	r1, sp, #20
 8008e26:	9100      	str	r1, [sp, #0]
 8008e28:	4610      	mov	r0, r2
 8008e2a:	4619      	mov	r1, r3
 8008e2c:	f04f 0201 	mov.w	r2, #1
 8008e30:	f04f 0300 	mov.w	r3, #0
 8008e34:	47a8      	blx	r5
		}
	}
	
	/* Check if TXE flag is set */
	bool tx_need_yield = false;
 8008e36:	f04f 0300 	mov.w	r3, #0
 8008e3a:	f88d 3013 	strb.w	r3, [sp, #19]
	if (sr & USART_SR_TXE) {
 8008e3e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8008e42:	b29b      	uxth	r3, r3
 8008e44:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8008e48:	2b00      	cmp	r3, #0
 8008e4a:	d036      	beq.n	8008eba <PIOS_USART_generic_irq_handler+0x12e>
		if (usart_dev->tx_out_cb) {
 8008e4c:	9b07      	ldr	r3, [sp, #28]
 8008e4e:	691b      	ldr	r3, [r3, #16]
 8008e50:	2b00      	cmp	r3, #0
 8008e52:	d028      	beq.n	8008ea6 <PIOS_USART_generic_irq_handler+0x11a>
			uint8_t b;
			uint16_t bytes_to_send;
			
			bytes_to_send = (usart_dev->tx_out_cb)(usart_dev->tx_out_context, &b, 1, NULL, &tx_need_yield);
 8008e54:	9b07      	ldr	r3, [sp, #28]
 8008e56:	691d      	ldr	r5, [r3, #16]
 8008e58:	9b07      	ldr	r3, [sp, #28]
 8008e5a:	695a      	ldr	r2, [r3, #20]
 8008e5c:	f10d 0311 	add.w	r3, sp, #17
 8008e60:	f10d 0113 	add.w	r1, sp, #19
 8008e64:	9100      	str	r1, [sp, #0]
 8008e66:	4610      	mov	r0, r2
 8008e68:	4619      	mov	r1, r3
 8008e6a:	f04f 0201 	mov.w	r2, #1
 8008e6e:	f04f 0300 	mov.w	r3, #0
 8008e72:	47a8      	blx	r5
 8008e74:	4603      	mov	r3, r0
 8008e76:	f8ad 3018 	strh.w	r3, [sp, #24]
			
			if (bytes_to_send > 0) {
 8008e7a:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 8008e7e:	2b00      	cmp	r3, #0
 8008e80:	d006      	beq.n	8008e90 <PIOS_USART_generic_irq_handler+0x104>
				/* Send the byte we've been given */
				usart_dev->cfg->regs->DR = b;
 8008e82:	9b07      	ldr	r3, [sp, #28]
 8008e84:	685b      	ldr	r3, [r3, #4]
 8008e86:	681b      	ldr	r3, [r3, #0]
 8008e88:	f89d 2011 	ldrb.w	r2, [sp, #17]
 8008e8c:	809a      	strh	r2, [r3, #4]
 8008e8e:	e014      	b.n	8008eba <PIOS_USART_generic_irq_handler+0x12e>
			} else {
				/* No bytes to send, disable TXE interrupt */
				USART_ITConfig(usart_dev->cfg->regs, USART_IT_TXE, DISABLE);
 8008e90:	9b07      	ldr	r3, [sp, #28]
 8008e92:	685b      	ldr	r3, [r3, #4]
 8008e94:	681b      	ldr	r3, [r3, #0]
 8008e96:	4618      	mov	r0, r3
 8008e98:	f240 7127 	movw	r1, #1831	; 0x727
 8008e9c:	f04f 0200 	mov.w	r2, #0
 8008ea0:	f001 fb46 	bl	800a530 <USART_ITConfig>
 8008ea4:	e009      	b.n	8008eba <PIOS_USART_generic_irq_handler+0x12e>
			}
		} else {
			/* No bytes to send, disable TXE interrupt */
			USART_ITConfig(usart_dev->cfg->regs, USART_IT_TXE, DISABLE);
 8008ea6:	9b07      	ldr	r3, [sp, #28]
 8008ea8:	685b      	ldr	r3, [r3, #4]
 8008eaa:	681b      	ldr	r3, [r3, #0]
 8008eac:	4618      	mov	r0, r3
 8008eae:	f240 7127 	movw	r1, #1831	; 0x727
 8008eb2:	f04f 0200 	mov.w	r2, #0
 8008eb6:	f001 fb3b 	bl	800a530 <USART_ITConfig>
		}
	}
	
#if defined(PIOS_INCLUDE_FREERTOS)
	if (rx_need_yield || tx_need_yield) {
 8008eba:	f89d 3014 	ldrb.w	r3, [sp, #20]
 8008ebe:	2b00      	cmp	r3, #0
 8008ec0:	d103      	bne.n	8008eca <PIOS_USART_generic_irq_handler+0x13e>
 8008ec2:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8008ec6:	2b00      	cmp	r3, #0
 8008ec8:	d001      	beq.n	8008ece <PIOS_USART_generic_irq_handler+0x142>
		vPortYieldFromISR();
 8008eca:	f003 fddb 	bl	800ca84 <vPortYieldFromISR>
 8008ece:	4623      	mov	r3, r4
 8008ed0:	f648 508d 	movw	r0, #36237	; 0x8d8d
 8008ed4:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008ed8:	4619      	mov	r1, r3
 8008eda:	f003 fea3 	bl	800cc24 <__cyg_profile_func_exit>
	}
#endif	/* PIOS_INCLUDE_FREERTOS */
}
 8008ede:	b009      	add	sp, #36	; 0x24
 8008ee0:	bd30      	pop	{r4, r5, pc}
 8008ee2:	bf00      	nop

08008ee4 <PIOS_IRQ_Disable>:
/**
* Disables all interrupts (nested)
* \return < 0 On errors
*/
int32_t PIOS_IRQ_Disable(void)
{
 8008ee4:	b538      	push	{r3, r4, r5, lr}
 8008ee6:	4674      	mov	r4, lr
 8008ee8:	4623      	mov	r3, r4
 8008eea:	f648 60e5 	movw	r0, #36581	; 0x8ee5
 8008eee:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008ef2:	4619      	mov	r1, r3
 8008ef4:	f003 fe88 	bl	800cc08 <__cyg_profile_func_enter>
	/* Get current priority if nested level == 0 */
	if (!nested_ctr) {
 8008ef8:	f240 435c 	movw	r3, #1116	; 0x45c
 8008efc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008f00:	681b      	ldr	r3, [r3, #0]
 8008f02:	2b00      	cmp	r3, #0
 8008f04:	d106      	bne.n	8008f14 <PIOS_IRQ_Disable+0x30>
		__asm volatile ("   mrs %0, primask\n":"=r" (prev_primask)
 8008f06:	f3ef 8210 	mrs	r2, PRIMASK
 8008f0a:	f240 4360 	movw	r3, #1120	; 0x460
 8008f0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008f12:	601a      	str	r2, [r3, #0]
		    );
	}

	/* Disable interrupts */
	__asm volatile ("     mov r0, #1     \n" "     msr primask, r0\n":::"r0");
 8008f14:	f04f 0001 	mov.w	r0, #1
 8008f18:	f380 8810 	msr	PRIMASK, r0

	++nested_ctr;
 8008f1c:	f240 435c 	movw	r3, #1116	; 0x45c
 8008f20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008f24:	681b      	ldr	r3, [r3, #0]
 8008f26:	f103 0201 	add.w	r2, r3, #1
 8008f2a:	f240 435c 	movw	r3, #1116	; 0x45c
 8008f2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008f32:	601a      	str	r2, [r3, #0]

	/* No error */
	return 0;
 8008f34:	f04f 0500 	mov.w	r5, #0
 8008f38:	4623      	mov	r3, r4
 8008f3a:	f648 60e5 	movw	r0, #36581	; 0x8ee5
 8008f3e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008f42:	4619      	mov	r1, r3
 8008f44:	f003 fe6e 	bl	800cc24 <__cyg_profile_func_exit>
 8008f48:	462b      	mov	r3, r5
}
 8008f4a:	4618      	mov	r0, r3
 8008f4c:	bd38      	pop	{r3, r4, r5, pc}
 8008f4e:	bf00      	nop

08008f50 <PIOS_IRQ_Enable>:
* Enables all interrupts (nested)
* \return < 0 on errors
* \return -1 on nesting errors (PIOS_IRQ_Disable() hasn't been called before)
*/
int32_t PIOS_IRQ_Enable(void)
{
 8008f50:	b538      	push	{r3, r4, r5, lr}
 8008f52:	4675      	mov	r5, lr
 8008f54:	462b      	mov	r3, r5
 8008f56:	f648 7051 	movw	r0, #36689	; 0x8f51
 8008f5a:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008f5e:	4619      	mov	r1, r3
 8008f60:	f003 fe52 	bl	800cc08 <__cyg_profile_func_enter>
	/* Check for nesting error */
	if (nested_ctr == 0) {
 8008f64:	f240 435c 	movw	r3, #1116	; 0x45c
 8008f68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008f6c:	681b      	ldr	r3, [r3, #0]
 8008f6e:	2b00      	cmp	r3, #0
 8008f70:	d102      	bne.n	8008f78 <PIOS_IRQ_Enable+0x28>
		/* Nesting error */
		return -1;
 8008f72:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8008f76:	e01b      	b.n	8008fb0 <PIOS_IRQ_Enable+0x60>
	}

	/* Decrease nesting level */
	--nested_ctr;
 8008f78:	f240 435c 	movw	r3, #1116	; 0x45c
 8008f7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008f80:	681b      	ldr	r3, [r3, #0]
 8008f82:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 8008f86:	f240 435c 	movw	r3, #1116	; 0x45c
 8008f8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008f8e:	601a      	str	r2, [r3, #0]

	/* Set back previous priority once nested level reached 0 again */
	if (nested_ctr == 0) {
 8008f90:	f240 435c 	movw	r3, #1116	; 0x45c
 8008f94:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008f98:	681b      	ldr	r3, [r3, #0]
 8008f9a:	2b00      	cmp	r3, #0
 8008f9c:	d106      	bne.n	8008fac <PIOS_IRQ_Enable+0x5c>
		__asm volatile ("   msr primask, %0\n"::"r" (prev_primask)
 8008f9e:	f240 4360 	movw	r3, #1120	; 0x460
 8008fa2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008fa6:	681b      	ldr	r3, [r3, #0]
 8008fa8:	f383 8810 	msr	PRIMASK, r3
		    );
	}

	/* No error */
	return 0;
 8008fac:	f04f 0400 	mov.w	r4, #0
 8008fb0:	462b      	mov	r3, r5
 8008fb2:	f648 7051 	movw	r0, #36689	; 0x8f51
 8008fb6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008fba:	4619      	mov	r1, r3
 8008fbc:	f003 fe32 	bl	800cc24 <__cyg_profile_func_exit>
 8008fc0:	4623      	mov	r3, r4
}
 8008fc2:	4618      	mov	r0, r3
 8008fc4:	bd38      	pop	{r3, r4, r5, pc}
 8008fc6:	bf00      	nop

08008fc8 <PIOS_DEBUG_Init>:

/**
* Initialise Debug-features
*/
void PIOS_DEBUG_Init(void)
{
 8008fc8:	b510      	push	{r4, lr}
 8008fca:	4674      	mov	r4, lr
 8008fcc:	4623      	mov	r3, r4
 8008fce:	f648 70c9 	movw	r0, #36809	; 0x8fc9
 8008fd2:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008fd6:	4619      	mov	r1, r3
 8008fd8:	f003 fe16 	bl	800cc08 <__cyg_profile_func_enter>
 8008fdc:	4623      	mov	r3, r4
 8008fde:	f648 70c9 	movw	r0, #36809	; 0x8fc9
 8008fe2:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008fe6:	4619      	mov	r1, r3
 8008fe8:	f003 fe1c 	bl	800cc24 <__cyg_profile_func_exit>

}
 8008fec:	bd10      	pop	{r4, pc}
 8008fee:	bf00      	nop

08008ff0 <PIOS_DEBUG_Panic>:

/**
 * Report a serious error and halt
 */
void PIOS_DEBUG_Panic(const char *msg)
{
 8008ff0:	b500      	push	{lr}
 8008ff2:	b083      	sub	sp, #12
 8008ff4:	4673      	mov	r3, lr
 8008ff6:	9001      	str	r0, [sp, #4]
 8008ff8:	f648 70f1 	movw	r0, #36849	; 0x8ff1
 8008ffc:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009000:	4619      	mov	r1, r3
 8009002:	f003 fe01 	bl	800cc08 <__cyg_profile_func_enter>
#ifdef PIOS_COM_DEBUG
	register int *lr asm("lr");	// Link-register holds the PC of the caller
	PIOS_COM_SendFormattedStringNonBlocking(PIOS_COM_DEBUG, "\r%s @0x%x\r", msg, lr);
 8009006:	f240 53b4 	movw	r3, #1460	; 0x5b4
 800900a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800900e:	681a      	ldr	r2, [r3, #0]
 8009010:	4673      	mov	r3, lr
 8009012:	4610      	mov	r0, r2
 8009014:	f64d 21ac 	movw	r1, #55980	; 0xdaac
 8009018:	f6c0 0100 	movt	r1, #2048	; 0x800
 800901c:	9a01      	ldr	r2, [sp, #4]
 800901e:	f000 f987 	bl	8009330 <PIOS_COM_SendFormattedStringNonBlocking>
#endif

	// Stay put
	while (1) ;
 8009022:	e7fe      	b.n	8009022 <PIOS_DEBUG_Panic+0x32>

08009024 <EXTI0_IRQHandler>:

/**
* Handle external lines 15 to 10 interrupt requests
*/
void EXTI0_IRQHandler(void)
{
 8009024:	b510      	push	{r4, lr}
 8009026:	b082      	sub	sp, #8
 8009028:	4674      	mov	r4, lr
 800902a:	4623      	mov	r3, r4
 800902c:	f249 0025 	movw	r0, #36901	; 0x9025
 8009030:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009034:	4619      	mov	r1, r3
 8009036:	f003 fde7 	bl	800cc08 <__cyg_profile_func_enter>
#if defined(PIOS_INCLUDE_FREERTOS)
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
 800903a:	f04f 0300 	mov.w	r3, #0
 800903e:	9301      	str	r3, [sp, #4]
#endif

#if defined(PIOS_INCLUDE_BMP085)
	if (EXTI_GetITStatus(PIOS_BMP085_EOC_EXTI_LINE) != RESET) {
 8009040:	f04f 0001 	mov.w	r0, #1
 8009044:	f000 ff16 	bl	8009e74 <EXTI_GetITStatus>
 8009048:	4603      	mov	r3, r0
 800904a:	2b00      	cmp	r3, #0
 800904c:	d011      	beq.n	8009072 <EXTI0_IRQHandler+0x4e>
		/* Read the ADC Value */
		xSemaphoreGiveFromISR(PIOS_BMP085_EOC, &xHigherPriorityTaskWoken);
 800904e:	f240 53b8 	movw	r3, #1464	; 0x5b8
 8009052:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009056:	681a      	ldr	r2, [r3, #0]
 8009058:	ab01      	add	r3, sp, #4
 800905a:	4610      	mov	r0, r2
 800905c:	f04f 0100 	mov.w	r1, #0
 8009060:	461a      	mov	r2, r3
 8009062:	f04f 0300 	mov.w	r3, #0
 8009066:	f001 fd4b 	bl	800ab00 <xQueueGenericSendFromISR>

		/* Clear the EXTI line pending bit */
		EXTI_ClearITPendingBit(PIOS_BMP085_EOC_EXTI_LINE);
 800906a:	f04f 0001 	mov.w	r0, #1
 800906e:	f000 ff3f 	bl	8009ef0 <EXTI_ClearITPendingBit>
	}
#endif

#if defined(PIOS_INCLUDE_FREERTOS)
	/* Yield From ISR if needed */
	portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
 8009072:	9b01      	ldr	r3, [sp, #4]
 8009074:	2b00      	cmp	r3, #0
 8009076:	d001      	beq.n	800907c <EXTI0_IRQHandler+0x58>
 8009078:	f003 fd04 	bl	800ca84 <vPortYieldFromISR>
 800907c:	4623      	mov	r3, r4
 800907e:	f249 0025 	movw	r0, #36901	; 0x9025
 8009082:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009086:	4619      	mov	r1, r3
 8009088:	f003 fdcc 	bl	800cc24 <__cyg_profile_func_exit>
#endif
}
 800908c:	b002      	add	sp, #8
 800908e:	bd10      	pop	{r4, pc}

08009090 <EXTI1_IRQHandler>:
/**
* Handle external line 1 interrupt requests
*/
extern void PIOS_HMC5883_IRQHandler(void);
void EXTI1_IRQHandler(void)
{
 8009090:	b510      	push	{r4, lr}
 8009092:	4674      	mov	r4, lr
 8009094:	4623      	mov	r3, r4
 8009096:	f249 0091 	movw	r0, #37009	; 0x9091
 800909a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800909e:	4619      	mov	r1, r3
 80090a0:	f003 fdb2 	bl	800cc08 <__cyg_profile_func_enter>
#if defined(PIOS_INCLUDE_HMC5883)
	if (EXTI_GetITStatus(PIOS_HMC5883_DRDY_EXTI_LINE) != RESET) {
 80090a4:	f04f 0002 	mov.w	r0, #2
 80090a8:	f000 fee4 	bl	8009e74 <EXTI_GetITStatus>
 80090ac:	4603      	mov	r3, r0
 80090ae:	2b00      	cmp	r3, #0
 80090b0:	d005      	beq.n	80090be <EXTI1_IRQHandler+0x2e>
		PIOS_HMC5883_IRQHandler();
 80090b2:	f000 f96f 	bl	8009394 <PIOS_HMC5883_IRQHandler>
		EXTI_ClearITPendingBit(PIOS_HMC5883_DRDY_EXTI_LINE);
 80090b6:	f04f 0002 	mov.w	r0, #2
 80090ba:	f000 ff19 	bl	8009ef0 <EXTI_ClearITPendingBit>
 80090be:	4623      	mov	r3, r4
 80090c0:	f249 0091 	movw	r0, #37009	; 0x9091
 80090c4:	f6c0 0000 	movt	r0, #2048	; 0x800
 80090c8:	4619      	mov	r1, r3
 80090ca:	f003 fdab 	bl	800cc24 <__cyg_profile_func_exit>
	}
#endif
}
 80090ce:	bd10      	pop	{r4, pc}

080090d0 <PIOS_COM_validate>:
	t_fifo_buffer rx;
	t_fifo_buffer tx;
};

static bool PIOS_COM_validate(struct pios_com_dev * com_dev)
{
 80090d0:	b530      	push	{r4, r5, lr}
 80090d2:	b083      	sub	sp, #12
 80090d4:	4674      	mov	r4, lr
 80090d6:	9001      	str	r0, [sp, #4]
 80090d8:	4623      	mov	r3, r4
 80090da:	f249 00d1 	movw	r0, #37073	; 0x90d1
 80090de:	f6c0 0000 	movt	r0, #2048	; 0x800
 80090e2:	4619      	mov	r1, r3
 80090e4:	f003 fd90 	bl	800cc08 <__cyg_profile_func_enter>
	return (com_dev && (com_dev->magic == PIOS_COM_DEV_MAGIC));
 80090e8:	9b01      	ldr	r3, [sp, #4]
 80090ea:	2b00      	cmp	r3, #0
 80090ec:	d00a      	beq.n	8009104 <PIOS_COM_validate+0x34>
 80090ee:	9b01      	ldr	r3, [sp, #4]
 80090f0:	681a      	ldr	r2, [r3, #0]
 80090f2:	f64a 2355 	movw	r3, #43605	; 0xaa55
 80090f6:	f6ca 2355 	movt	r3, #43605	; 0xaa55
 80090fa:	429a      	cmp	r2, r3
 80090fc:	d102      	bne.n	8009104 <PIOS_COM_validate+0x34>
 80090fe:	f04f 0301 	mov.w	r3, #1
 8009102:	e001      	b.n	8009108 <PIOS_COM_validate+0x38>
 8009104:	f04f 0300 	mov.w	r3, #0
 8009108:	b2dd      	uxtb	r5, r3
 800910a:	4623      	mov	r3, r4
 800910c:	f249 00d1 	movw	r0, #37073	; 0x90d1
 8009110:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009114:	4619      	mov	r1, r3
 8009116:	f003 fd85 	bl	800cc24 <__cyg_profile_func_exit>
 800911a:	462b      	mov	r3, r5
}
 800911c:	4618      	mov	r0, r3
 800911e:	b003      	add	sp, #12
 8009120:	bd30      	pop	{r4, r5, pc}
 8009122:	bf00      	nop

08009124 <PIOS_COM_SendBufferNonBlocking>:
* \return -2 if non-blocking mode activated: buffer is full
*            caller should retry until buffer is free again
* \return 0 on success
*/
int32_t PIOS_COM_SendBufferNonBlocking(uint32_t com_id, const uint8_t *buffer, uint16_t len)
{
 8009124:	b570      	push	{r4, r5, r6, lr}
 8009126:	b086      	sub	sp, #24
 8009128:	4675      	mov	r5, lr
 800912a:	9003      	str	r0, [sp, #12]
 800912c:	9102      	str	r1, [sp, #8]
 800912e:	4613      	mov	r3, r2
 8009130:	f8ad 3006 	strh.w	r3, [sp, #6]
 8009134:	462b      	mov	r3, r5
 8009136:	f249 1025 	movw	r0, #37157	; 0x9125
 800913a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800913e:	4619      	mov	r1, r3
 8009140:	f003 fd62 	bl	800cc08 <__cyg_profile_func_enter>
	struct pios_com_dev * com_dev = (struct pios_com_dev *)com_id;
 8009144:	9b03      	ldr	r3, [sp, #12]
 8009146:	9305      	str	r3, [sp, #20]

	if (!PIOS_COM_validate(com_dev)) {
 8009148:	9805      	ldr	r0, [sp, #20]
 800914a:	f7ff ffc1 	bl	80090d0 <PIOS_COM_validate>
 800914e:	4603      	mov	r3, r0
 8009150:	f083 0301 	eor.w	r3, r3, #1
 8009154:	b2db      	uxtb	r3, r3
 8009156:	2b00      	cmp	r3, #0
 8009158:	d002      	beq.n	8009160 <PIOS_COM_SendBufferNonBlocking+0x3c>
		/* Undefined COM port for this board (see pios_board.c) */
		return -1;
 800915a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 800915e:	e047      	b.n	80091f0 <PIOS_COM_SendBufferNonBlocking+0xcc>
	}

	PIOS_Assert(com_dev->has_tx);
 8009160:	9b05      	ldr	r3, [sp, #20]
 8009162:	7d5b      	ldrb	r3, [r3, #21]
 8009164:	f083 0301 	eor.w	r3, r3, #1
 8009168:	b2db      	uxtb	r3, r3
 800916a:	2b00      	cmp	r3, #0
 800916c:	d007      	beq.n	800917e <PIOS_COM_SendBufferNonBlocking+0x5a>
 800916e:	f240 4308 	movw	r3, #1032	; 0x408
 8009172:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009176:	681b      	ldr	r3, [r3, #0]
 8009178:	4618      	mov	r0, r3
 800917a:	f7ff ff39 	bl	8008ff0 <PIOS_DEBUG_Panic>

	if (len >= fifoBuf_getFree(&com_dev->tx)) {
 800917e:	9b05      	ldr	r3, [sp, #20]
 8009180:	f103 0324 	add.w	r3, r3, #36	; 0x24
 8009184:	4618      	mov	r0, r3
 8009186:	f000 fbcd 	bl	8009924 <fifoBuf_getFree>
 800918a:	4603      	mov	r3, r0
 800918c:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 8009190:	429a      	cmp	r2, r3
 8009192:	d302      	bcc.n	800919a <PIOS_COM_SendBufferNonBlocking+0x76>
		/* Buffer cannot accept all requested bytes (retry) */
		return -2;
 8009194:	f06f 0401 	mvn.w	r4, #1
 8009198:	e02a      	b.n	80091f0 <PIOS_COM_SendBufferNonBlocking+0xcc>
	}

	PIOS_IRQ_Disable();
 800919a:	f7ff fea3 	bl	8008ee4 <PIOS_IRQ_Disable>
	uint16_t bytes_into_fifo = fifoBuf_putData(&com_dev->tx, buffer, len);
 800919e:	9b05      	ldr	r3, [sp, #20]
 80091a0:	f103 0224 	add.w	r2, r3, #36	; 0x24
 80091a4:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80091a8:	4610      	mov	r0, r2
 80091aa:	9902      	ldr	r1, [sp, #8]
 80091ac:	461a      	mov	r2, r3
 80091ae:	f000 fbe5 	bl	800997c <fifoBuf_putData>
 80091b2:	4603      	mov	r3, r0
 80091b4:	f8ad 3012 	strh.w	r3, [sp, #18]
	PIOS_IRQ_Enable();
 80091b8:	f7ff feca 	bl	8008f50 <PIOS_IRQ_Enable>

	if (bytes_into_fifo > 0) {
 80091bc:	f8bd 3012 	ldrh.w	r3, [sp, #18]
 80091c0:	2b00      	cmp	r3, #0
 80091c2:	d013      	beq.n	80091ec <PIOS_COM_SendBufferNonBlocking+0xc8>
		/* More data has been put in the tx buffer, make sure the tx is started */
		if (com_dev->driver->tx_start) {
 80091c4:	9b05      	ldr	r3, [sp, #20]
 80091c6:	689b      	ldr	r3, [r3, #8]
 80091c8:	689b      	ldr	r3, [r3, #8]
 80091ca:	2b00      	cmp	r3, #0
 80091cc:	d00e      	beq.n	80091ec <PIOS_COM_SendBufferNonBlocking+0xc8>
			com_dev->driver->tx_start(com_dev->lower_id,
 80091ce:	9b05      	ldr	r3, [sp, #20]
 80091d0:	689b      	ldr	r3, [r3, #8]
 80091d2:	689c      	ldr	r4, [r3, #8]
 80091d4:	9b05      	ldr	r3, [sp, #20]
 80091d6:	685e      	ldr	r6, [r3, #4]
 80091d8:	9b05      	ldr	r3, [sp, #20]
 80091da:	f103 0324 	add.w	r3, r3, #36	; 0x24
 80091de:	4618      	mov	r0, r3
 80091e0:	f000 fb62 	bl	80098a8 <fifoBuf_getUsed>
 80091e4:	4603      	mov	r3, r0
 80091e6:	4630      	mov	r0, r6
 80091e8:	4619      	mov	r1, r3
 80091ea:	47a0      	blx	r4
						  fifoBuf_getUsed(&com_dev->tx));
		}
	}

	return (0);
 80091ec:	f04f 0400 	mov.w	r4, #0
 80091f0:	462b      	mov	r3, r5
 80091f2:	f249 1025 	movw	r0, #37157	; 0x9125
 80091f6:	f6c0 0000 	movt	r0, #2048	; 0x800
 80091fa:	4619      	mov	r1, r3
 80091fc:	f003 fd12 	bl	800cc24 <__cyg_profile_func_exit>
 8009200:	4623      	mov	r3, r4
}
 8009202:	4618      	mov	r0, r3
 8009204:	b006      	add	sp, #24
 8009206:	bd70      	pop	{r4, r5, r6, pc}

08009208 <PIOS_COM_SendBuffer>:
* \param[in] len buffer length
* \return -1 if port not available
* \return 0 on success
*/
int32_t PIOS_COM_SendBuffer(uint32_t com_id, const uint8_t *buffer, uint16_t len)
{
 8009208:	b570      	push	{r4, r5, r6, lr}
 800920a:	b086      	sub	sp, #24
 800920c:	4675      	mov	r5, lr
 800920e:	9003      	str	r0, [sp, #12]
 8009210:	9102      	str	r1, [sp, #8]
 8009212:	4613      	mov	r3, r2
 8009214:	f8ad 3006 	strh.w	r3, [sp, #6]
 8009218:	462b      	mov	r3, r5
 800921a:	f249 2009 	movw	r0, #37385	; 0x9209
 800921e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009222:	4619      	mov	r1, r3
 8009224:	f003 fcf0 	bl	800cc08 <__cyg_profile_func_enter>
	struct pios_com_dev * com_dev = (struct pios_com_dev *)com_id;
 8009228:	9b03      	ldr	r3, [sp, #12]
 800922a:	9305      	str	r3, [sp, #20]

	if (!PIOS_COM_validate(com_dev)) {
 800922c:	9805      	ldr	r0, [sp, #20]
 800922e:	f7ff ff4f 	bl	80090d0 <PIOS_COM_validate>
 8009232:	4603      	mov	r3, r0
 8009234:	f083 0301 	eor.w	r3, r3, #1
 8009238:	b2db      	uxtb	r3, r3
 800923a:	2b00      	cmp	r3, #0
 800923c:	d002      	beq.n	8009244 <PIOS_COM_SendBuffer+0x3c>
		/* Undefined COM port for this board (see pios_board.c) */
		return -1;
 800923e:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8009242:	e044      	b.n	80092ce <PIOS_COM_SendBuffer+0xc6>
	}

	PIOS_Assert(com_dev->has_tx);
 8009244:	9b05      	ldr	r3, [sp, #20]
 8009246:	7d5b      	ldrb	r3, [r3, #21]
 8009248:	f083 0301 	eor.w	r3, r3, #1
 800924c:	b2db      	uxtb	r3, r3
 800924e:	2b00      	cmp	r3, #0
 8009250:	d007      	beq.n	8009262 <PIOS_COM_SendBuffer+0x5a>
 8009252:	f240 4308 	movw	r3, #1032	; 0x408
 8009256:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800925a:	681b      	ldr	r3, [r3, #0]
 800925c:	4618      	mov	r0, r3
 800925e:	f7ff fec7 	bl	8008ff0 <PIOS_DEBUG_Panic>

	int32_t rc;
	do {
	  rc = PIOS_COM_SendBufferNonBlocking(com_id, buffer, len);
 8009262:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8009266:	9803      	ldr	r0, [sp, #12]
 8009268:	9902      	ldr	r1, [sp, #8]
 800926a:	461a      	mov	r2, r3
 800926c:	f7ff ff5a 	bl	8009124 <PIOS_COM_SendBufferNonBlocking>
 8009270:	9004      	str	r0, [sp, #16]

#if defined(PIOS_INCLUDE_FREERTOS)
	  if (rc == -2) {
 8009272:	9b04      	ldr	r3, [sp, #16]
 8009274:	f113 0f02 	cmn.w	r3, #2
 8009278:	d124      	bne.n	80092c4 <PIOS_COM_SendBuffer+0xbc>
	    /* Make sure the transmitter is running while we wait */
	    if (com_dev->driver->tx_start) {
 800927a:	9b05      	ldr	r3, [sp, #20]
 800927c:	689b      	ldr	r3, [r3, #8]
 800927e:	689b      	ldr	r3, [r3, #8]
 8009280:	2b00      	cmp	r3, #0
 8009282:	d00e      	beq.n	80092a2 <PIOS_COM_SendBuffer+0x9a>
	      (com_dev->driver->tx_start)(com_dev->lower_id,
 8009284:	9b05      	ldr	r3, [sp, #20]
 8009286:	689b      	ldr	r3, [r3, #8]
 8009288:	689c      	ldr	r4, [r3, #8]
 800928a:	9b05      	ldr	r3, [sp, #20]
 800928c:	685e      	ldr	r6, [r3, #4]
 800928e:	9b05      	ldr	r3, [sp, #20]
 8009290:	f103 0324 	add.w	r3, r3, #36	; 0x24
 8009294:	4618      	mov	r0, r3
 8009296:	f000 fb07 	bl	80098a8 <fifoBuf_getUsed>
 800929a:	4603      	mov	r3, r0
 800929c:	4630      	mov	r0, r6
 800929e:	4619      	mov	r1, r3
 80092a0:	47a0      	blx	r4
					  fifoBuf_getUsed(&com_dev->tx));
	    }
	    if (xSemaphoreTake(com_dev->tx_sem, portMAX_DELAY) != pdTRUE) {
 80092a2:	9b05      	ldr	r3, [sp, #20]
 80092a4:	68db      	ldr	r3, [r3, #12]
 80092a6:	4618      	mov	r0, r3
 80092a8:	f04f 0100 	mov.w	r1, #0
 80092ac:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80092b0:	f04f 0300 	mov.w	r3, #0
 80092b4:	f001 fc7a 	bl	800abac <xQueueGenericReceive>
 80092b8:	4603      	mov	r3, r0
 80092ba:	2b01      	cmp	r3, #1
 80092bc:	d002      	beq.n	80092c4 <PIOS_COM_SendBuffer+0xbc>
	      return -3;
 80092be:	f06f 0402 	mvn.w	r4, #2
 80092c2:	e004      	b.n	80092ce <PIOS_COM_SendBuffer+0xc6>
	    }
	  }
#endif
	} while (rc == -2);
 80092c4:	9b04      	ldr	r3, [sp, #16]
 80092c6:	f113 0f02 	cmn.w	r3, #2
 80092ca:	d0ca      	beq.n	8009262 <PIOS_COM_SendBuffer+0x5a>

	return rc;
 80092cc:	9c04      	ldr	r4, [sp, #16]
 80092ce:	462b      	mov	r3, r5
 80092d0:	f249 2009 	movw	r0, #37385	; 0x9209
 80092d4:	f6c0 0000 	movt	r0, #2048	; 0x800
 80092d8:	4619      	mov	r1, r3
 80092da:	f003 fca3 	bl	800cc24 <__cyg_profile_func_exit>
 80092de:	4623      	mov	r3, r4
}
 80092e0:	4618      	mov	r0, r3
 80092e2:	b006      	add	sp, #24
 80092e4:	bd70      	pop	{r4, r5, r6, pc}
 80092e6:	bf00      	nop

080092e8 <PIOS_COM_SendChar>:
* \param[in] c character
* \return -1 if port not available
* \return 0 on success
*/
int32_t PIOS_COM_SendChar(uint32_t com_id, char c)
{
 80092e8:	b530      	push	{r4, r5, lr}
 80092ea:	b083      	sub	sp, #12
 80092ec:	4674      	mov	r4, lr
 80092ee:	9001      	str	r0, [sp, #4]
 80092f0:	460b      	mov	r3, r1
 80092f2:	f88d 3003 	strb.w	r3, [sp, #3]
 80092f6:	4623      	mov	r3, r4
 80092f8:	f249 20e9 	movw	r0, #37609	; 0x92e9
 80092fc:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009300:	4619      	mov	r1, r3
 8009302:	f003 fc81 	bl	800cc08 <__cyg_profile_func_enter>
	return PIOS_COM_SendBuffer(com_id, (uint8_t *)&c, 1);
 8009306:	f10d 0303 	add.w	r3, sp, #3
 800930a:	9801      	ldr	r0, [sp, #4]
 800930c:	4619      	mov	r1, r3
 800930e:	f04f 0201 	mov.w	r2, #1
 8009312:	f7ff ff79 	bl	8009208 <PIOS_COM_SendBuffer>
 8009316:	4605      	mov	r5, r0
 8009318:	4623      	mov	r3, r4
 800931a:	f249 20e9 	movw	r0, #37609	; 0x92e9
 800931e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009322:	4619      	mov	r1, r3
 8009324:	f003 fc7e 	bl	800cc24 <__cyg_profile_func_exit>
 8009328:	462b      	mov	r3, r5
}
 800932a:	4618      	mov	r0, r3
 800932c:	b003      	add	sp, #12
 800932e:	bd30      	pop	{r4, r5, pc}

08009330 <PIOS_COM_SendFormattedStringNonBlocking>:
* \return -2 if non-blocking mode activated: buffer is full
*         caller should retry until buffer is free again
* \return 0 on success
*/
int32_t PIOS_COM_SendFormattedStringNonBlocking(uint32_t com_id, const char *format, ...)
{
 8009330:	b40e      	push	{r1, r2, r3}
 8009332:	b530      	push	{r4, r5, lr}
 8009334:	b0a4      	sub	sp, #144	; 0x90
 8009336:	4674      	mov	r4, lr
 8009338:	9001      	str	r0, [sp, #4]
 800933a:	4623      	mov	r3, r4
 800933c:	f249 3031 	movw	r0, #37681	; 0x9331
 8009340:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009344:	4619      	mov	r1, r3
 8009346:	f003 fc5f 	bl	800cc08 <__cyg_profile_func_enter>
	uint8_t buffer[128]; // TODO: tmp!!! Provide a streamed COM method later!

	va_list args;

	va_start(args, format);
 800934a:	ab28      	add	r3, sp, #160	; 0xa0
 800934c:	9303      	str	r3, [sp, #12]
	vsprintf((char *)buffer, format, args);
 800934e:	ab04      	add	r3, sp, #16
 8009350:	4618      	mov	r0, r3
 8009352:	9927      	ldr	r1, [sp, #156]	; 0x9c
 8009354:	9a03      	ldr	r2, [sp, #12]
 8009356:	f000 fa83 	bl	8009860 <vsprintf>
	return PIOS_COM_SendBufferNonBlocking(com_id, buffer, (uint16_t)strlen((char *)buffer));
 800935a:	ab04      	add	r3, sp, #16
 800935c:	4618      	mov	r0, r3
 800935e:	f004 fb09 	bl	800d974 <strlen>
 8009362:	4603      	mov	r3, r0
 8009364:	b29b      	uxth	r3, r3
 8009366:	aa04      	add	r2, sp, #16
 8009368:	9801      	ldr	r0, [sp, #4]
 800936a:	4611      	mov	r1, r2
 800936c:	461a      	mov	r2, r3
 800936e:	f7ff fed9 	bl	8009124 <PIOS_COM_SendBufferNonBlocking>
 8009372:	4605      	mov	r5, r0
 8009374:	4623      	mov	r3, r4
 8009376:	f249 3031 	movw	r0, #37681	; 0x9331
 800937a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800937e:	4619      	mov	r1, r3
 8009380:	f003 fc50 	bl	800cc24 <__cyg_profile_func_exit>
 8009384:	462b      	mov	r3, r5
}
 8009386:	4618      	mov	r0, r3
 8009388:	b024      	add	sp, #144	; 0x90
 800938a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 800938e:	b003      	add	sp, #12
 8009390:	4770      	bx	lr
 8009392:	bf00      	nop

08009394 <PIOS_HMC5883_IRQHandler>:

/**
* @brief IRQ Handler
*/
void PIOS_HMC5883_IRQHandler(void)
{
 8009394:	b510      	push	{r4, lr}
 8009396:	4674      	mov	r4, lr
 8009398:	4623      	mov	r3, r4
 800939a:	f249 3095 	movw	r0, #37781	; 0x9395
 800939e:	f6c0 0000 	movt	r0, #2048	; 0x800
 80093a2:	4619      	mov	r1, r3
 80093a4:	f003 fc30 	bl	800cc08 <__cyg_profile_func_enter>
	pios_hmc5883_data_ready = true;
 80093a8:	f240 53bd 	movw	r3, #1469	; 0x5bd
 80093ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80093b0:	f04f 0201 	mov.w	r2, #1
 80093b4:	701a      	strb	r2, [r3, #0]
 80093b6:	4623      	mov	r3, r4
 80093b8:	f249 3095 	movw	r0, #37781	; 0x9395
 80093bc:	f6c0 0000 	movt	r0, #2048	; 0x800
 80093c0:	4619      	mov	r1, r3
 80093c2:	f003 fc2f 	bl	800cc24 <__cyg_profile_func_exit>
}
 80093c6:	bd10      	pop	{r4, pc}

080093c8 <printchar>:
//#define putchar(c) COMSendChar(c)

#include <pios.h>

static void printchar(char **str, int c)
{
 80093c8:	b510      	push	{r4, lr}
 80093ca:	b082      	sub	sp, #8
 80093cc:	4674      	mov	r4, lr
 80093ce:	9001      	str	r0, [sp, #4]
 80093d0:	9100      	str	r1, [sp, #0]
 80093d2:	4623      	mov	r3, r4
 80093d4:	f249 30c9 	movw	r0, #37833	; 0x93c9
 80093d8:	f6c0 0000 	movt	r0, #2048	; 0x800
 80093dc:	4619      	mov	r1, r3
 80093de:	f003 fc13 	bl	800cc08 <__cyg_profile_func_enter>
	if (str) {
 80093e2:	9b01      	ldr	r3, [sp, #4]
 80093e4:	2b00      	cmp	r3, #0
 80093e6:	d00b      	beq.n	8009400 <printchar+0x38>
		**str = c;
 80093e8:	9b01      	ldr	r3, [sp, #4]
 80093ea:	681b      	ldr	r3, [r3, #0]
 80093ec:	9a00      	ldr	r2, [sp, #0]
 80093ee:	b2d2      	uxtb	r2, r2
 80093f0:	701a      	strb	r2, [r3, #0]
		++(*str);
 80093f2:	9b01      	ldr	r3, [sp, #4]
 80093f4:	681b      	ldr	r3, [r3, #0]
 80093f6:	f103 0201 	add.w	r2, r3, #1
 80093fa:	9b01      	ldr	r3, [sp, #4]
 80093fc:	601a      	str	r2, [r3, #0]
 80093fe:	e00a      	b.n	8009416 <printchar+0x4e>
	}
#ifdef PIOS_COM_DEBUG
	else
		PIOS_COM_SendChar(PIOS_COM_DEBUG, c);
 8009400:	f240 53b4 	movw	r3, #1460	; 0x5b4
 8009404:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009408:	681a      	ldr	r2, [r3, #0]
 800940a:	9b00      	ldr	r3, [sp, #0]
 800940c:	b2db      	uxtb	r3, r3
 800940e:	4610      	mov	r0, r2
 8009410:	4619      	mov	r1, r3
 8009412:	f7ff ff69 	bl	80092e8 <PIOS_COM_SendChar>
 8009416:	4623      	mov	r3, r4
 8009418:	f249 30c9 	movw	r0, #37833	; 0x93c9
 800941c:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009420:	4619      	mov	r1, r3
 8009422:	f003 fbff 	bl	800cc24 <__cyg_profile_func_exit>
#endif

}
 8009426:	b002      	add	sp, #8
 8009428:	bd10      	pop	{r4, pc}
 800942a:	bf00      	nop

0800942c <prints>:

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
 800942c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009430:	b084      	sub	sp, #16
 8009432:	46f0      	mov	r8, lr
 8009434:	9003      	str	r0, [sp, #12]
 8009436:	9102      	str	r1, [sp, #8]
 8009438:	9201      	str	r2, [sp, #4]
 800943a:	9300      	str	r3, [sp, #0]
 800943c:	4643      	mov	r3, r8
 800943e:	f249 402d 	movw	r0, #37933	; 0x942d
 8009442:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009446:	4619      	mov	r1, r3
 8009448:	f003 fbde 	bl	800cc08 <__cyg_profile_func_enter>
	register int pc = 0, padchar = ' ';
 800944c:	f04f 0400 	mov.w	r4, #0
 8009450:	f04f 0620 	mov.w	r6, #32

	if (width > 0) {
 8009454:	9b01      	ldr	r3, [sp, #4]
 8009456:	2b00      	cmp	r3, #0
 8009458:	dd1b      	ble.n	8009492 <prints+0x66>
		register int len = 0;
 800945a:	f04f 0500 	mov.w	r5, #0
		register const char *ptr;
		for (ptr = string; *ptr; ++ptr)
 800945e:	9f02      	ldr	r7, [sp, #8]
 8009460:	e003      	b.n	800946a <prints+0x3e>
			++len;
 8009462:	f105 0501 	add.w	r5, r5, #1
	register int pc = 0, padchar = ' ';

	if (width > 0) {
		register int len = 0;
		register const char *ptr;
		for (ptr = string; *ptr; ++ptr)
 8009466:	f107 0701 	add.w	r7, r7, #1
 800946a:	783b      	ldrb	r3, [r7, #0]
 800946c:	2b00      	cmp	r3, #0
 800946e:	d1f8      	bne.n	8009462 <prints+0x36>
			++len;
		if (len >= width)
 8009470:	9b01      	ldr	r3, [sp, #4]
 8009472:	429d      	cmp	r5, r3
 8009474:	db03      	blt.n	800947e <prints+0x52>
			width = 0;
 8009476:	f04f 0300 	mov.w	r3, #0
 800947a:	9301      	str	r3, [sp, #4]
 800947c:	e002      	b.n	8009484 <prints+0x58>
		else
			width -= len;
 800947e:	9b01      	ldr	r3, [sp, #4]
 8009480:	1b5b      	subs	r3, r3, r5
 8009482:	9301      	str	r3, [sp, #4]
		if (pad & PAD_ZERO)
 8009484:	9b00      	ldr	r3, [sp, #0]
 8009486:	f003 0302 	and.w	r3, r3, #2
 800948a:	2b00      	cmp	r3, #0
 800948c:	d001      	beq.n	8009492 <prints+0x66>
			padchar = '0';
 800948e:	f04f 0630 	mov.w	r6, #48	; 0x30
	}
	if (!(pad & PAD_RIGHT)) {
 8009492:	9b00      	ldr	r3, [sp, #0]
 8009494:	f003 0301 	and.w	r3, r3, #1
 8009498:	2b00      	cmp	r3, #0
 800949a:	d11b      	bne.n	80094d4 <prints+0xa8>
		for (; width > 0; --width) {
 800949c:	e009      	b.n	80094b2 <prints+0x86>
			printchar(out, padchar);
 800949e:	9803      	ldr	r0, [sp, #12]
 80094a0:	4631      	mov	r1, r6
 80094a2:	f7ff ff91 	bl	80093c8 <printchar>
			++pc;
 80094a6:	f104 0401 	add.w	r4, r4, #1
			width -= len;
		if (pad & PAD_ZERO)
			padchar = '0';
	}
	if (!(pad & PAD_RIGHT)) {
		for (; width > 0; --width) {
 80094aa:	9b01      	ldr	r3, [sp, #4]
 80094ac:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
 80094b0:	9301      	str	r3, [sp, #4]
 80094b2:	9b01      	ldr	r3, [sp, #4]
 80094b4:	2b00      	cmp	r3, #0
 80094b6:	dcf2      	bgt.n	800949e <prints+0x72>
			printchar(out, padchar);
			++pc;
		}
	}
	for (; *string; ++string) {
 80094b8:	e00c      	b.n	80094d4 <prints+0xa8>
		printchar(out, *string);
 80094ba:	9b02      	ldr	r3, [sp, #8]
 80094bc:	781b      	ldrb	r3, [r3, #0]
 80094be:	9803      	ldr	r0, [sp, #12]
 80094c0:	4619      	mov	r1, r3
 80094c2:	f7ff ff81 	bl	80093c8 <printchar>
		++pc;
 80094c6:	f104 0401 	add.w	r4, r4, #1
		for (; width > 0; --width) {
			printchar(out, padchar);
			++pc;
		}
	}
	for (; *string; ++string) {
 80094ca:	9b02      	ldr	r3, [sp, #8]
 80094cc:	f103 0301 	add.w	r3, r3, #1
 80094d0:	9302      	str	r3, [sp, #8]
 80094d2:	e000      	b.n	80094d6 <prints+0xaa>
 80094d4:	bf00      	nop
 80094d6:	9b02      	ldr	r3, [sp, #8]
 80094d8:	781b      	ldrb	r3, [r3, #0]
 80094da:	2b00      	cmp	r3, #0
 80094dc:	d1ed      	bne.n	80094ba <prints+0x8e>
		printchar(out, *string);
		++pc;
	}
	for (; width > 0; --width) {
 80094de:	e009      	b.n	80094f4 <prints+0xc8>
		printchar(out, padchar);
 80094e0:	9803      	ldr	r0, [sp, #12]
 80094e2:	4631      	mov	r1, r6
 80094e4:	f7ff ff70 	bl	80093c8 <printchar>
		++pc;
 80094e8:	f104 0401 	add.w	r4, r4, #1
	}
	for (; *string; ++string) {
		printchar(out, *string);
		++pc;
	}
	for (; width > 0; --width) {
 80094ec:	9b01      	ldr	r3, [sp, #4]
 80094ee:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
 80094f2:	9301      	str	r3, [sp, #4]
 80094f4:	9b01      	ldr	r3, [sp, #4]
 80094f6:	2b00      	cmp	r3, #0
 80094f8:	dcf2      	bgt.n	80094e0 <prints+0xb4>
		printchar(out, padchar);
		++pc;
	}

	return pc;
 80094fa:	4643      	mov	r3, r8
 80094fc:	f249 402d 	movw	r0, #37933	; 0x942d
 8009500:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009504:	4619      	mov	r1, r3
 8009506:	f003 fb8d 	bl	800cc24 <__cyg_profile_func_exit>
 800950a:	4623      	mov	r3, r4
}
 800950c:	4618      	mov	r0, r3
 800950e:	b004      	add	sp, #16
 8009510:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08009514 <printi>:

/* the following should be enough for 32 bit int */
#define PRINT_BUF_LEN 12

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
 8009514:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8009518:	b089      	sub	sp, #36	; 0x24
 800951a:	46f0      	mov	r8, lr
 800951c:	9003      	str	r0, [sp, #12]
 800951e:	9102      	str	r1, [sp, #8]
 8009520:	9201      	str	r2, [sp, #4]
 8009522:	9300      	str	r3, [sp, #0]
 8009524:	4643      	mov	r3, r8
 8009526:	f249 5015 	movw	r0, #38165	; 0x9515
 800952a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800952e:	4619      	mov	r1, r3
 8009530:	f003 fb6a 	bl	800cc08 <__cyg_profile_func_enter>
	char print_buf[PRINT_BUF_LEN];
	register char *s;
	register int t, neg = 0, pc = 0;
 8009534:	f04f 0900 	mov.w	r9, #0
 8009538:	f04f 0700 	mov.w	r7, #0
	register unsigned int u = i;
 800953c:	9d02      	ldr	r5, [sp, #8]

	if (i == 0) {
 800953e:	9b02      	ldr	r3, [sp, #8]
 8009540:	2b00      	cmp	r3, #0
 8009542:	d110      	bne.n	8009566 <printi+0x52>
		print_buf[0] = '0';
 8009544:	f04f 0330 	mov.w	r3, #48	; 0x30
 8009548:	f88d 3014 	strb.w	r3, [sp, #20]
		print_buf[1] = '\0';
 800954c:	f04f 0300 	mov.w	r3, #0
 8009550:	f88d 3015 	strb.w	r3, [sp, #21]
		return prints(out, print_buf, width, pad);
 8009554:	ab05      	add	r3, sp, #20
 8009556:	9803      	ldr	r0, [sp, #12]
 8009558:	4619      	mov	r1, r3
 800955a:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800955c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800955e:	f7ff ff65 	bl	800942c <prints>
 8009562:	4604      	mov	r4, r0
 8009564:	e052      	b.n	800960c <printi+0xf8>
	}

	if (sg && b == 10 && i < 0) {
 8009566:	9b00      	ldr	r3, [sp, #0]
 8009568:	2b00      	cmp	r3, #0
 800956a:	d00b      	beq.n	8009584 <printi+0x70>
 800956c:	9b01      	ldr	r3, [sp, #4]
 800956e:	2b0a      	cmp	r3, #10
 8009570:	d108      	bne.n	8009584 <printi+0x70>
 8009572:	9b02      	ldr	r3, [sp, #8]
 8009574:	2b00      	cmp	r3, #0
 8009576:	da05      	bge.n	8009584 <printi+0x70>
		neg = 1;
 8009578:	f04f 0901 	mov.w	r9, #1
		u = -i;
 800957c:	9b02      	ldr	r3, [sp, #8]
 800957e:	f1c3 0300 	rsb	r3, r3, #0
 8009582:	461d      	mov	r5, r3
	}

	s = print_buf + PRINT_BUF_LEN - 1;
 8009584:	ab05      	add	r3, sp, #20
 8009586:	f103 040b 	add.w	r4, r3, #11
	*s = '\0';
 800958a:	f04f 0300 	mov.w	r3, #0
 800958e:	7023      	strb	r3, [r4, #0]

	while (u) {
 8009590:	e016      	b.n	80095c0 <printi+0xac>
		t = u % b;
 8009592:	9b01      	ldr	r3, [sp, #4]
 8009594:	fbb5 f2f3 	udiv	r2, r5, r3
 8009598:	fb03 f302 	mul.w	r3, r3, r2
 800959c:	1aeb      	subs	r3, r5, r3
 800959e:	461e      	mov	r6, r3
		if (t >= 10)
 80095a0:	2e09      	cmp	r6, #9
 80095a2:	dd03      	ble.n	80095ac <printi+0x98>
			t += letbase - '0' - 10;
 80095a4:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80095a6:	f1a3 033a 	sub.w	r3, r3, #58	; 0x3a
 80095aa:	18f6      	adds	r6, r6, r3
		*--s = t + '0';
 80095ac:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
 80095b0:	b2f3      	uxtb	r3, r6
 80095b2:	f103 0330 	add.w	r3, r3, #48	; 0x30
 80095b6:	b2db      	uxtb	r3, r3
 80095b8:	7023      	strb	r3, [r4, #0]
		u /= b;
 80095ba:	9b01      	ldr	r3, [sp, #4]
 80095bc:	fbb5 f5f3 	udiv	r5, r5, r3
	}

	s = print_buf + PRINT_BUF_LEN - 1;
	*s = '\0';

	while (u) {
 80095c0:	2d00      	cmp	r5, #0
 80095c2:	d1e6      	bne.n	8009592 <printi+0x7e>
			t += letbase - '0' - 10;
		*--s = t + '0';
		u /= b;
	}

	if (neg) {
 80095c4:	f1b9 0f00 	cmp.w	r9, #0
 80095c8:	d018      	beq.n	80095fc <printi+0xe8>
		if (width && (pad & PAD_ZERO)) {
 80095ca:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80095cc:	2b00      	cmp	r3, #0
 80095ce:	d010      	beq.n	80095f2 <printi+0xde>
 80095d0:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80095d2:	f003 0302 	and.w	r3, r3, #2
 80095d6:	2b00      	cmp	r3, #0
 80095d8:	d00b      	beq.n	80095f2 <printi+0xde>
			printchar(out, '-');
 80095da:	9803      	ldr	r0, [sp, #12]
 80095dc:	f04f 012d 	mov.w	r1, #45	; 0x2d
 80095e0:	f7ff fef2 	bl	80093c8 <printchar>
			++pc;
 80095e4:	f107 0701 	add.w	r7, r7, #1
			--width;
 80095e8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80095ea:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
 80095ee:	9310      	str	r3, [sp, #64]	; 0x40
 80095f0:	e004      	b.n	80095fc <printi+0xe8>
		} else {
			*--s = '-';
 80095f2:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
 80095f6:	f04f 032d 	mov.w	r3, #45	; 0x2d
 80095fa:	7023      	strb	r3, [r4, #0]
		}
	}

	return pc + prints(out, s, width, pad);
 80095fc:	9803      	ldr	r0, [sp, #12]
 80095fe:	4621      	mov	r1, r4
 8009600:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8009602:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8009604:	f7ff ff12 	bl	800942c <prints>
 8009608:	4603      	mov	r3, r0
 800960a:	19dc      	adds	r4, r3, r7
 800960c:	4643      	mov	r3, r8
 800960e:	f249 5015 	movw	r0, #38165	; 0x9515
 8009612:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009616:	4619      	mov	r1, r3
 8009618:	f003 fb04 	bl	800cc24 <__cyg_profile_func_exit>
 800961c:	4623      	mov	r3, r4
}
 800961e:	4618      	mov	r0, r3
 8009620:	b009      	add	sp, #36	; 0x24
 8009622:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8009626:	bf00      	nop

08009628 <print>:

static int print(char **out, const char *format, va_list args)
{
 8009628:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800962c:	b08a      	sub	sp, #40	; 0x28
 800962e:	4677      	mov	r7, lr
 8009630:	9007      	str	r0, [sp, #28]
 8009632:	9106      	str	r1, [sp, #24]
 8009634:	9205      	str	r2, [sp, #20]
 8009636:	463b      	mov	r3, r7
 8009638:	f249 6029 	movw	r0, #38441	; 0x9629
 800963c:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009640:	4619      	mov	r1, r3
 8009642:	f003 fae1 	bl	800cc08 <__cyg_profile_func_enter>
	register int width, pad;
	register int pc = 0;
 8009646:	f04f 0400 	mov.w	r4, #0
	char scr[2];

	for (; *format != 0; ++format) {
 800964a:	e0ec      	b.n	8009826 <print+0x1fe>
		if (*format == '%') {
 800964c:	9b06      	ldr	r3, [sp, #24]
 800964e:	781b      	ldrb	r3, [r3, #0]
 8009650:	2b25      	cmp	r3, #37	; 0x25
 8009652:	f040 80dc 	bne.w	800980e <print+0x1e6>
			++format;
 8009656:	9b06      	ldr	r3, [sp, #24]
 8009658:	f103 0301 	add.w	r3, r3, #1
 800965c:	9306      	str	r3, [sp, #24]
			width = pad = 0;
 800965e:	f04f 0600 	mov.w	r6, #0
 8009662:	4635      	mov	r5, r6
			if (*format == '\0')
 8009664:	9b06      	ldr	r3, [sp, #24]
 8009666:	781b      	ldrb	r3, [r3, #0]
 8009668:	2b00      	cmp	r3, #0
 800966a:	f000 80e2 	beq.w	8009832 <print+0x20a>
				break;
			if (*format == '%')
 800966e:	9b06      	ldr	r3, [sp, #24]
 8009670:	781b      	ldrb	r3, [r3, #0]
 8009672:	2b25      	cmp	r3, #37	; 0x25
 8009674:	f000 80ca 	beq.w	800980c <print+0x1e4>
				goto out;
			if (*format == '-') {
 8009678:	9b06      	ldr	r3, [sp, #24]
 800967a:	781b      	ldrb	r3, [r3, #0]
 800967c:	2b2d      	cmp	r3, #45	; 0x2d
 800967e:	d10d      	bne.n	800969c <print+0x74>
				++format;
 8009680:	9b06      	ldr	r3, [sp, #24]
 8009682:	f103 0301 	add.w	r3, r3, #1
 8009686:	9306      	str	r3, [sp, #24]
				pad = PAD_RIGHT;
 8009688:	f04f 0601 	mov.w	r6, #1
			}
			while (*format == '0') {
 800968c:	e006      	b.n	800969c <print+0x74>
				++format;
 800968e:	9b06      	ldr	r3, [sp, #24]
 8009690:	f103 0301 	add.w	r3, r3, #1
 8009694:	9306      	str	r3, [sp, #24]
				pad |= PAD_ZERO;
 8009696:	f046 0602 	orr.w	r6, r6, #2
 800969a:	e000      	b.n	800969e <print+0x76>
				goto out;
			if (*format == '-') {
				++format;
				pad = PAD_RIGHT;
			}
			while (*format == '0') {
 800969c:	bf00      	nop
 800969e:	9b06      	ldr	r3, [sp, #24]
 80096a0:	781b      	ldrb	r3, [r3, #0]
 80096a2:	2b30      	cmp	r3, #48	; 0x30
 80096a4:	d0f3      	beq.n	800968e <print+0x66>
				++format;
				pad |= PAD_ZERO;
			}
			for (; *format >= '0' && *format <= '9'; ++format) {
 80096a6:	e00f      	b.n	80096c8 <print+0xa0>
				width *= 10;
 80096a8:	462b      	mov	r3, r5
 80096aa:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80096ae:	195b      	adds	r3, r3, r5
 80096b0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80096b4:	461d      	mov	r5, r3
				width += *format - '0';
 80096b6:	9b06      	ldr	r3, [sp, #24]
 80096b8:	781b      	ldrb	r3, [r3, #0]
 80096ba:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 80096be:	18ed      	adds	r5, r5, r3
			}
			while (*format == '0') {
				++format;
				pad |= PAD_ZERO;
			}
			for (; *format >= '0' && *format <= '9'; ++format) {
 80096c0:	9b06      	ldr	r3, [sp, #24]
 80096c2:	f103 0301 	add.w	r3, r3, #1
 80096c6:	9306      	str	r3, [sp, #24]
 80096c8:	9b06      	ldr	r3, [sp, #24]
 80096ca:	781b      	ldrb	r3, [r3, #0]
 80096cc:	2b2f      	cmp	r3, #47	; 0x2f
 80096ce:	d903      	bls.n	80096d8 <print+0xb0>
 80096d0:	9b06      	ldr	r3, [sp, #24]
 80096d2:	781b      	ldrb	r3, [r3, #0]
 80096d4:	2b39      	cmp	r3, #57	; 0x39
 80096d6:	d9e7      	bls.n	80096a8 <print+0x80>
				width *= 10;
				width += *format - '0';
			}
			if (*format == 's') {
 80096d8:	9b06      	ldr	r3, [sp, #24]
 80096da:	781b      	ldrb	r3, [r3, #0]
 80096dc:	2b73      	cmp	r3, #115	; 0x73
 80096de:	d117      	bne.n	8009710 <print+0xe8>
				register char *s = (char *)va_arg(args, int);
 80096e0:	9b05      	ldr	r3, [sp, #20]
 80096e2:	f103 0204 	add.w	r2, r3, #4
 80096e6:	9205      	str	r2, [sp, #20]
 80096e8:	681b      	ldr	r3, [r3, #0]
 80096ea:	4698      	mov	r8, r3
				pc += prints(out, s ? s : "(null)", width, pad);
 80096ec:	f1b8 0f00 	cmp.w	r8, #0
 80096f0:	d001      	beq.n	80096f6 <print+0xce>
 80096f2:	4643      	mov	r3, r8
 80096f4:	e003      	b.n	80096fe <print+0xd6>
 80096f6:	f64d 23b8 	movw	r3, #55992	; 0xdab8
 80096fa:	f6c0 0300 	movt	r3, #2048	; 0x800
 80096fe:	9807      	ldr	r0, [sp, #28]
 8009700:	4619      	mov	r1, r3
 8009702:	462a      	mov	r2, r5
 8009704:	4633      	mov	r3, r6
 8009706:	f7ff fe91 	bl	800942c <prints>
 800970a:	4603      	mov	r3, r0
 800970c:	18e4      	adds	r4, r4, r3
				continue;
 800970e:	e086      	b.n	800981e <print+0x1f6>
			}
			if (*format == 'd') {
 8009710:	9b06      	ldr	r3, [sp, #24]
 8009712:	781b      	ldrb	r3, [r3, #0]
 8009714:	2b64      	cmp	r3, #100	; 0x64
 8009716:	d114      	bne.n	8009742 <print+0x11a>
				pc += printi(out, va_arg(args, int), 10, 1, width, pad, 'a');
 8009718:	9b05      	ldr	r3, [sp, #20]
 800971a:	f103 0204 	add.w	r2, r3, #4
 800971e:	9205      	str	r2, [sp, #20]
 8009720:	681b      	ldr	r3, [r3, #0]
 8009722:	9500      	str	r5, [sp, #0]
 8009724:	9601      	str	r6, [sp, #4]
 8009726:	f04f 0261 	mov.w	r2, #97	; 0x61
 800972a:	9202      	str	r2, [sp, #8]
 800972c:	9807      	ldr	r0, [sp, #28]
 800972e:	4619      	mov	r1, r3
 8009730:	f04f 020a 	mov.w	r2, #10
 8009734:	f04f 0301 	mov.w	r3, #1
 8009738:	f7ff feec 	bl	8009514 <printi>
 800973c:	4603      	mov	r3, r0
 800973e:	18e4      	adds	r4, r4, r3
				continue;
 8009740:	e06d      	b.n	800981e <print+0x1f6>
			}
			if (*format == 'x') {
 8009742:	9b06      	ldr	r3, [sp, #24]
 8009744:	781b      	ldrb	r3, [r3, #0]
 8009746:	2b78      	cmp	r3, #120	; 0x78
 8009748:	d114      	bne.n	8009774 <print+0x14c>
				pc += printi(out, va_arg(args, int), 16, 0, width, pad, 'a');
 800974a:	9b05      	ldr	r3, [sp, #20]
 800974c:	f103 0204 	add.w	r2, r3, #4
 8009750:	9205      	str	r2, [sp, #20]
 8009752:	681b      	ldr	r3, [r3, #0]
 8009754:	9500      	str	r5, [sp, #0]
 8009756:	9601      	str	r6, [sp, #4]
 8009758:	f04f 0261 	mov.w	r2, #97	; 0x61
 800975c:	9202      	str	r2, [sp, #8]
 800975e:	9807      	ldr	r0, [sp, #28]
 8009760:	4619      	mov	r1, r3
 8009762:	f04f 0210 	mov.w	r2, #16
 8009766:	f04f 0300 	mov.w	r3, #0
 800976a:	f7ff fed3 	bl	8009514 <printi>
 800976e:	4603      	mov	r3, r0
 8009770:	18e4      	adds	r4, r4, r3
				continue;
 8009772:	e054      	b.n	800981e <print+0x1f6>
			}
			if (*format == 'X') {
 8009774:	9b06      	ldr	r3, [sp, #24]
 8009776:	781b      	ldrb	r3, [r3, #0]
 8009778:	2b58      	cmp	r3, #88	; 0x58
 800977a:	d114      	bne.n	80097a6 <print+0x17e>
				pc += printi(out, va_arg(args, int), 16, 0, width, pad, 'A');
 800977c:	9b05      	ldr	r3, [sp, #20]
 800977e:	f103 0204 	add.w	r2, r3, #4
 8009782:	9205      	str	r2, [sp, #20]
 8009784:	681b      	ldr	r3, [r3, #0]
 8009786:	9500      	str	r5, [sp, #0]
 8009788:	9601      	str	r6, [sp, #4]
 800978a:	f04f 0241 	mov.w	r2, #65	; 0x41
 800978e:	9202      	str	r2, [sp, #8]
 8009790:	9807      	ldr	r0, [sp, #28]
 8009792:	4619      	mov	r1, r3
 8009794:	f04f 0210 	mov.w	r2, #16
 8009798:	f04f 0300 	mov.w	r3, #0
 800979c:	f7ff feba 	bl	8009514 <printi>
 80097a0:	4603      	mov	r3, r0
 80097a2:	18e4      	adds	r4, r4, r3
				continue;
 80097a4:	e03b      	b.n	800981e <print+0x1f6>
			}
			if (*format == 'u') {
 80097a6:	9b06      	ldr	r3, [sp, #24]
 80097a8:	781b      	ldrb	r3, [r3, #0]
 80097aa:	2b75      	cmp	r3, #117	; 0x75
 80097ac:	d114      	bne.n	80097d8 <print+0x1b0>
				pc += printi(out, va_arg(args, int), 10, 0, width, pad, 'a');
 80097ae:	9b05      	ldr	r3, [sp, #20]
 80097b0:	f103 0204 	add.w	r2, r3, #4
 80097b4:	9205      	str	r2, [sp, #20]
 80097b6:	681b      	ldr	r3, [r3, #0]
 80097b8:	9500      	str	r5, [sp, #0]
 80097ba:	9601      	str	r6, [sp, #4]
 80097bc:	f04f 0261 	mov.w	r2, #97	; 0x61
 80097c0:	9202      	str	r2, [sp, #8]
 80097c2:	9807      	ldr	r0, [sp, #28]
 80097c4:	4619      	mov	r1, r3
 80097c6:	f04f 020a 	mov.w	r2, #10
 80097ca:	f04f 0300 	mov.w	r3, #0
 80097ce:	f7ff fea1 	bl	8009514 <printi>
 80097d2:	4603      	mov	r3, r0
 80097d4:	18e4      	adds	r4, r4, r3
				continue;
 80097d6:	e022      	b.n	800981e <print+0x1f6>
			}
			if (*format == 'c') {
 80097d8:	9b06      	ldr	r3, [sp, #24]
 80097da:	781b      	ldrb	r3, [r3, #0]
 80097dc:	2b63      	cmp	r3, #99	; 0x63
 80097de:	d11e      	bne.n	800981e <print+0x1f6>
				/* char are converted to int then pushed on the stack */
				scr[0] = (char)va_arg(args, int);
 80097e0:	9b05      	ldr	r3, [sp, #20]
 80097e2:	f103 0204 	add.w	r2, r3, #4
 80097e6:	9205      	str	r2, [sp, #20]
 80097e8:	681b      	ldr	r3, [r3, #0]
 80097ea:	b2db      	uxtb	r3, r3
 80097ec:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
				scr[1] = '\0';
 80097f0:	f04f 0300 	mov.w	r3, #0
 80097f4:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
				pc += prints(out, scr, width, pad);
 80097f8:	ab09      	add	r3, sp, #36	; 0x24
 80097fa:	9807      	ldr	r0, [sp, #28]
 80097fc:	4619      	mov	r1, r3
 80097fe:	462a      	mov	r2, r5
 8009800:	4633      	mov	r3, r6
 8009802:	f7ff fe13 	bl	800942c <prints>
 8009806:	4603      	mov	r3, r0
 8009808:	18e4      	adds	r4, r4, r3
				continue;
 800980a:	e008      	b.n	800981e <print+0x1f6>
			++format;
			width = pad = 0;
			if (*format == '\0')
				break;
			if (*format == '%')
				goto out;
 800980c:	bf00      	nop
				pc += prints(out, scr, width, pad);
				continue;
			}
		} else {
out:
			printchar(out, *format);
 800980e:	9b06      	ldr	r3, [sp, #24]
 8009810:	781b      	ldrb	r3, [r3, #0]
 8009812:	9807      	ldr	r0, [sp, #28]
 8009814:	4619      	mov	r1, r3
 8009816:	f7ff fdd7 	bl	80093c8 <printchar>
			++pc;
 800981a:	f104 0401 	add.w	r4, r4, #1
{
	register int width, pad;
	register int pc = 0;
	char scr[2];

	for (; *format != 0; ++format) {
 800981e:	9b06      	ldr	r3, [sp, #24]
 8009820:	f103 0301 	add.w	r3, r3, #1
 8009824:	9306      	str	r3, [sp, #24]
 8009826:	9b06      	ldr	r3, [sp, #24]
 8009828:	781b      	ldrb	r3, [r3, #0]
 800982a:	2b00      	cmp	r3, #0
 800982c:	f47f af0e 	bne.w	800964c <print+0x24>
 8009830:	e000      	b.n	8009834 <print+0x20c>
		if (*format == '%') {
			++format;
			width = pad = 0;
			if (*format == '\0')
				break;
 8009832:	bf00      	nop
out:
			printchar(out, *format);
			++pc;
		}
	}
	if (out)
 8009834:	9b07      	ldr	r3, [sp, #28]
 8009836:	2b00      	cmp	r3, #0
 8009838:	d004      	beq.n	8009844 <print+0x21c>
		**out = '\0';
 800983a:	9b07      	ldr	r3, [sp, #28]
 800983c:	681b      	ldr	r3, [r3, #0]
 800983e:	f04f 0200 	mov.w	r2, #0
 8009842:	701a      	strb	r2, [r3, #0]
	va_end(args);
	return pc;
 8009844:	463b      	mov	r3, r7
 8009846:	f249 6029 	movw	r0, #38441	; 0x9629
 800984a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800984e:	4619      	mov	r1, r3
 8009850:	f003 f9e8 	bl	800cc24 <__cyg_profile_func_exit>
 8009854:	4623      	mov	r3, r4
}
 8009856:	4618      	mov	r0, r3
 8009858:	b00a      	add	sp, #40	; 0x28
 800985a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800985e:	bf00      	nop

08009860 <vsprintf>:
	return print(&out, format, args);
}

// TK: added for alternative parameter passing
int vsprintf(char *out, const char *format, va_list args)
{
 8009860:	b530      	push	{r4, r5, lr}
 8009862:	b087      	sub	sp, #28
 8009864:	4674      	mov	r4, lr
 8009866:	9003      	str	r0, [sp, #12]
 8009868:	9102      	str	r1, [sp, #8]
 800986a:	9201      	str	r2, [sp, #4]
 800986c:	4623      	mov	r3, r4
 800986e:	f649 0061 	movw	r0, #39009	; 0x9861
 8009872:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009876:	4619      	mov	r1, r3
 8009878:	f003 f9c6 	bl	800cc08 <__cyg_profile_func_enter>
	char *_out;
	_out = out;
 800987c:	9b03      	ldr	r3, [sp, #12]
 800987e:	9305      	str	r3, [sp, #20]
	return print(&_out, format, args);
 8009880:	ab05      	add	r3, sp, #20
 8009882:	4618      	mov	r0, r3
 8009884:	9902      	ldr	r1, [sp, #8]
 8009886:	9a01      	ldr	r2, [sp, #4]
 8009888:	f7ff fece 	bl	8009628 <print>
 800988c:	4605      	mov	r5, r0
 800988e:	4623      	mov	r3, r4
 8009890:	f649 0061 	movw	r0, #39009	; 0x9861
 8009894:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009898:	4619      	mov	r1, r3
 800989a:	f003 f9c3 	bl	800cc24 <__cyg_profile_func_exit>
 800989e:	462b      	mov	r3, r5
}
 80098a0:	4618      	mov	r0, r3
 80098a2:	b007      	add	sp, #28
 80098a4:	bd30      	pop	{r4, r5, pc}
 80098a6:	bf00      	nop

080098a8 <fifoBuf_getUsed>:
    else
      return 0;
}

uint16_t fifoBuf_getUsed(t_fifo_buffer *buf)
{       // return the number of bytes available in the rx buffer
 80098a8:	b530      	push	{r4, r5, lr}
 80098aa:	b085      	sub	sp, #20
 80098ac:	4674      	mov	r4, lr
 80098ae:	9001      	str	r0, [sp, #4]
 80098b0:	4623      	mov	r3, r4
 80098b2:	f649 00a9 	movw	r0, #39081	; 0x98a9
 80098b6:	f6c0 0000 	movt	r0, #2048	; 0x800
 80098ba:	4619      	mov	r1, r3
 80098bc:	f003 f9a4 	bl	800cc08 <__cyg_profile_func_enter>

    uint16_t rd = buf->rd;
 80098c0:	9b01      	ldr	r3, [sp, #4]
 80098c2:	889b      	ldrh	r3, [r3, #4]
 80098c4:	f8ad 300c 	strh.w	r3, [sp, #12]
    uint16_t wr = buf->wr;
 80098c8:	9b01      	ldr	r3, [sp, #4]
 80098ca:	88db      	ldrh	r3, [r3, #6]
 80098cc:	f8ad 300a 	strh.w	r3, [sp, #10]
    uint16_t buf_size = buf->buf_size;
 80098d0:	9b01      	ldr	r3, [sp, #4]
 80098d2:	891b      	ldrh	r3, [r3, #8]
 80098d4:	f8ad 3008 	strh.w	r3, [sp, #8]

    uint16_t num_bytes = wr - rd;
 80098d8:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 80098dc:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 80098e0:	1ad3      	subs	r3, r2, r3
 80098e2:	f8ad 300e 	strh.w	r3, [sp, #14]
    if (wr < rd)
 80098e6:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 80098ea:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 80098ee:	429a      	cmp	r2, r3
 80098f0:	d20a      	bcs.n	8009908 <fifoBuf_getUsed+0x60>
        num_bytes = (buf_size - rd) + wr;
 80098f2:	f8bd 2008 	ldrh.w	r2, [sp, #8]
 80098f6:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 80098fa:	1ad3      	subs	r3, r2, r3
 80098fc:	b29a      	uxth	r2, r3
 80098fe:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 8009902:	18d3      	adds	r3, r2, r3
 8009904:	f8ad 300e 	strh.w	r3, [sp, #14]

    return num_bytes;
 8009908:	f8bd 500e 	ldrh.w	r5, [sp, #14]
 800990c:	4623      	mov	r3, r4
 800990e:	f649 00a9 	movw	r0, #39081	; 0x98a9
 8009912:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009916:	4619      	mov	r1, r3
 8009918:	f003 f984 	bl	800cc24 <__cyg_profile_func_exit>
 800991c:	462b      	mov	r3, r5
}
 800991e:	4618      	mov	r0, r3
 8009920:	b005      	add	sp, #20
 8009922:	bd30      	pop	{r4, r5, pc}

08009924 <fifoBuf_getFree>:

uint16_t fifoBuf_getFree(t_fifo_buffer *buf)
{       // return the free space size in the buffer
 8009924:	b530      	push	{r4, r5, lr}
 8009926:	b085      	sub	sp, #20
 8009928:	4674      	mov	r4, lr
 800992a:	9001      	str	r0, [sp, #4]
 800992c:	4623      	mov	r3, r4
 800992e:	f649 1025 	movw	r0, #39205	; 0x9925
 8009932:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009936:	4619      	mov	r1, r3
 8009938:	f003 f966 	bl	800cc08 <__cyg_profile_func_enter>

    uint16_t buf_size = buf->buf_size;
 800993c:	9b01      	ldr	r3, [sp, #4]
 800993e:	891b      	ldrh	r3, [r3, #8]
 8009940:	f8ad 300e 	strh.w	r3, [sp, #14]

    uint16_t num_bytes = fifoBuf_getUsed(buf);
 8009944:	9801      	ldr	r0, [sp, #4]
 8009946:	f7ff ffaf 	bl	80098a8 <fifoBuf_getUsed>
 800994a:	4603      	mov	r3, r0
 800994c:	f8ad 300c 	strh.w	r3, [sp, #12]

    return ((buf_size - num_bytes) - 1);
 8009950:	f8bd 200e 	ldrh.w	r2, [sp, #14]
 8009954:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 8009958:	1ad3      	subs	r3, r2, r3
 800995a:	b29b      	uxth	r3, r3
 800995c:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
 8009960:	b29d      	uxth	r5, r3
 8009962:	4623      	mov	r3, r4
 8009964:	f649 1025 	movw	r0, #39205	; 0x9925
 8009968:	f6c0 0000 	movt	r0, #2048	; 0x800
 800996c:	4619      	mov	r1, r3
 800996e:	f003 f959 	bl	800cc24 <__cyg_profile_func_exit>
 8009972:	462b      	mov	r3, r5
}
 8009974:	4618      	mov	r0, r3
 8009976:	b005      	add	sp, #20
 8009978:	bd30      	pop	{r4, r5, pc}
 800997a:	bf00      	nop

0800997c <fifoBuf_putData>:

    return 1;                   // return number of bytes copied
}

uint16_t fifoBuf_putData(t_fifo_buffer *buf, const void *data, uint16_t len)
{       // add data to the buffer
 800997c:	b530      	push	{r4, r5, lr}
 800997e:	b08b      	sub	sp, #44	; 0x2c
 8009980:	4675      	mov	r5, lr
 8009982:	9003      	str	r0, [sp, #12]
 8009984:	9102      	str	r1, [sp, #8]
 8009986:	4613      	mov	r3, r2
 8009988:	f8ad 3006 	strh.w	r3, [sp, #6]
 800998c:	462b      	mov	r3, r5
 800998e:	f649 107d 	movw	r0, #39293	; 0x997d
 8009992:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009996:	4619      	mov	r1, r3
 8009998:	f003 f936 	bl	800cc08 <__cyg_profile_func_enter>

    uint16_t wr = buf->wr;
 800999c:	9b03      	ldr	r3, [sp, #12]
 800999e:	88db      	ldrh	r3, [r3, #6]
 80099a0:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
    uint16_t buf_size = buf->buf_size;
 80099a4:	9b03      	ldr	r3, [sp, #12]
 80099a6:	891b      	ldrh	r3, [r3, #8]
 80099a8:	f8ad 301e 	strh.w	r3, [sp, #30]
    uint8_t *buff = buf->buf_ptr;
 80099ac:	9b03      	ldr	r3, [sp, #12]
 80099ae:	681b      	ldr	r3, [r3, #0]
 80099b0:	9306      	str	r3, [sp, #24]

    uint16_t num_bytes = fifoBuf_getFree(buf);
 80099b2:	9803      	ldr	r0, [sp, #12]
 80099b4:	f7ff ffb6 	bl	8009924 <fifoBuf_getFree>
 80099b8:	4603      	mov	r3, r0
 80099ba:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    if (num_bytes > len)
 80099be:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
 80099c2:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80099c6:	429a      	cmp	r2, r3
 80099c8:	d903      	bls.n	80099d2 <fifoBuf_putData+0x56>
        num_bytes = len;
 80099ca:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80099ce:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24

    if (num_bytes < 1)
 80099d2:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
 80099d6:	2b00      	cmp	r3, #0
 80099d8:	d102      	bne.n	80099e0 <fifoBuf_putData+0x64>
        return 0;               // return number of bytes copied
 80099da:	f04f 0400 	mov.w	r4, #0
 80099de:	e04f      	b.n	8009a80 <fifoBuf_putData+0x104>

    uint8_t *p = (uint8_t *)data;
 80099e0:	9b02      	ldr	r3, [sp, #8]
 80099e2:	9305      	str	r3, [sp, #20]
    uint16_t i = 0;
 80099e4:	f04f 0300 	mov.w	r3, #0
 80099e8:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22

    while (num_bytes > 0)
 80099ec:	e03e      	b.n	8009a6c <fifoBuf_putData+0xf0>
    {
        uint16_t j = buf_size - wr;
 80099ee:	f8bd 201e 	ldrh.w	r2, [sp, #30]
 80099f2:	f8bd 3026 	ldrh.w	r3, [sp, #38]	; 0x26
 80099f6:	1ad3      	subs	r3, r2, r3
 80099f8:	f8ad 3020 	strh.w	r3, [sp, #32]
        if (j > num_bytes)
 80099fc:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 8009a00:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
 8009a04:	429a      	cmp	r2, r3
 8009a06:	d903      	bls.n	8009a10 <fifoBuf_putData+0x94>
            j = num_bytes;
 8009a08:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
 8009a0c:	f8ad 3020 	strh.w	r3, [sp, #32]
        memcpy(buff + wr, p + i, j);
 8009a10:	f8bd 3026 	ldrh.w	r3, [sp, #38]	; 0x26
 8009a14:	9a06      	ldr	r2, [sp, #24]
 8009a16:	18d1      	adds	r1, r2, r3
 8009a18:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
 8009a1c:	9a05      	ldr	r2, [sp, #20]
 8009a1e:	18d2      	adds	r2, r2, r3
 8009a20:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 8009a24:	4608      	mov	r0, r1
 8009a26:	4611      	mov	r1, r2
 8009a28:	461a      	mov	r2, r3
 8009a2a:	f003 ff15 	bl	800d858 <memcpy>
        i += j;
 8009a2e:	f8bd 2022 	ldrh.w	r2, [sp, #34]	; 0x22
 8009a32:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 8009a36:	18d3      	adds	r3, r2, r3
 8009a38:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
        num_bytes -= j;
 8009a3c:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
 8009a40:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 8009a44:	1ad3      	subs	r3, r2, r3
 8009a46:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
        wr += j;
 8009a4a:	f8bd 2026 	ldrh.w	r2, [sp, #38]	; 0x26
 8009a4e:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 8009a52:	18d3      	adds	r3, r2, r3
 8009a54:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
        if (wr >= buf_size)
 8009a58:	f8bd 2026 	ldrh.w	r2, [sp, #38]	; 0x26
 8009a5c:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8009a60:	429a      	cmp	r2, r3
 8009a62:	d303      	bcc.n	8009a6c <fifoBuf_putData+0xf0>
            wr = 0;
 8009a64:	f04f 0300 	mov.w	r3, #0
 8009a68:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
        return 0;               // return number of bytes copied

    uint8_t *p = (uint8_t *)data;
    uint16_t i = 0;

    while (num_bytes > 0)
 8009a6c:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
 8009a70:	2b00      	cmp	r3, #0
 8009a72:	d1bc      	bne.n	80099ee <fifoBuf_putData+0x72>
        wr += j;
        if (wr >= buf_size)
            wr = 0;
    }

    buf->wr = wr;
 8009a74:	9b03      	ldr	r3, [sp, #12]
 8009a76:	f8bd 2026 	ldrh.w	r2, [sp, #38]	; 0x26
 8009a7a:	80da      	strh	r2, [r3, #6]

    return i;                   // return number of bytes copied
 8009a7c:	f8bd 4022 	ldrh.w	r4, [sp, #34]	; 0x22
 8009a80:	462b      	mov	r3, r5
 8009a82:	f649 107d 	movw	r0, #39293	; 0x997d
 8009a86:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009a8a:	4619      	mov	r1, r3
 8009a8c:	f003 f8ca 	bl	800cc24 <__cyg_profile_func_exit>
 8009a90:	4623      	mov	r3, r4
}
 8009a92:	4618      	mov	r0, r3
 8009a94:	b00b      	add	sp, #44	; 0x2c
 8009a96:	bd30      	pop	{r4, r5, pc}

08009a98 <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8009a98:	b510      	push	{r4, lr}
 8009a9a:	4674      	mov	r4, lr
 8009a9c:	4623      	mov	r3, r4
 8009a9e:	f649 2099 	movw	r0, #39577	; 0x9a99
 8009aa2:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009aa6:	4619      	mov	r1, r3
 8009aa8:	f003 f8ae 	bl	800cc08 <__cyg_profile_func_enter>
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8009aac:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009ab0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009ab4:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009ab8:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009abc:	6812      	ldr	r2, [r2, #0]
 8009abe:	f042 0201 	orr.w	r2, r2, #1
 8009ac2:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8009ac4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009ac8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009acc:	f04f 0200 	mov.w	r2, #0
 8009ad0:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8009ad2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009ad6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009ada:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009ade:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009ae2:	6812      	ldr	r2, [r2, #0]
 8009ae4:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8009ae8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8009aec:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8009aee:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009af2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009af6:	f243 0210 	movw	r2, #12304	; 0x3010
 8009afa:	f2c2 4200 	movt	r2, #9216	; 0x2400
 8009afe:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8009b00:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009b04:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009b08:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009b0c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009b10:	6812      	ldr	r2, [r2, #0]
 8009b12:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8009b16:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8009b18:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009b1c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009b20:	f04f 0200 	mov.w	r2, #0
 8009b24:	60da      	str	r2, [r3, #12]
  SystemInit_ExtMemCtl(); 
#endif /* DATA_IN_ExtSRAM */
         
  /* Configure the System clock source, PLL Multiplier and Divider factors, 
     AHB/APBx prescalers and Flash settings ----------------------------------*/
  SetSysClock();
 8009b26:	f000 f8d5 	bl	8009cd4 <SetSysClock>

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8009b2a:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8009b2e:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8009b32:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8009b36:	609a      	str	r2, [r3, #8]
 8009b38:	4623      	mov	r3, r4
 8009b3a:	f649 2099 	movw	r0, #39577	; 0x9a99
 8009b3e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009b42:	4619      	mov	r1, r3
 8009b44:	f003 f86e 	bl	800cc24 <__cyg_profile_func_exit>
#endif
}
 8009b48:	bd10      	pop	{r4, pc}
 8009b4a:	bf00      	nop

08009b4c <SystemCoreClockUpdate>:
  *     
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
 8009b4c:	b510      	push	{r4, lr}
 8009b4e:	b086      	sub	sp, #24
 8009b50:	4674      	mov	r4, lr
 8009b52:	4623      	mov	r3, r4
 8009b54:	f649 304d 	movw	r0, #39757	; 0x9b4d
 8009b58:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009b5c:	4619      	mov	r1, r3
 8009b5e:	f003 f853 	bl	800cc08 <__cyg_profile_func_enter>
  uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
 8009b62:	f04f 0300 	mov.w	r3, #0
 8009b66:	9304      	str	r3, [sp, #16]
 8009b68:	f04f 0300 	mov.w	r3, #0
 8009b6c:	9305      	str	r3, [sp, #20]
 8009b6e:	f04f 0302 	mov.w	r3, #2
 8009b72:	9303      	str	r3, [sp, #12]
 8009b74:	f04f 0300 	mov.w	r3, #0
 8009b78:	9302      	str	r3, [sp, #8]
 8009b7a:	f04f 0302 	mov.w	r3, #2
 8009b7e:	9301      	str	r3, [sp, #4]
  
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8009b80:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009b84:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009b88:	689b      	ldr	r3, [r3, #8]
 8009b8a:	f003 030c 	and.w	r3, r3, #12
 8009b8e:	9304      	str	r3, [sp, #16]

  switch (tmp)
 8009b90:	9b04      	ldr	r3, [sp, #16]
 8009b92:	2b04      	cmp	r3, #4
 8009b94:	d00d      	beq.n	8009bb2 <SystemCoreClockUpdate+0x66>
 8009b96:	2b08      	cmp	r3, #8
 8009b98:	d015      	beq.n	8009bc6 <SystemCoreClockUpdate+0x7a>
 8009b9a:	2b00      	cmp	r3, #0
 8009b9c:	d169      	bne.n	8009c72 <SystemCoreClockUpdate+0x126>
  {
    case 0x00:  /* HSI used as system clock source */
      SystemCoreClock = HSI_VALUE;
 8009b9e:	f240 430c 	movw	r3, #1036	; 0x40c
 8009ba2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009ba6:	f44f 5210 	mov.w	r2, #9216	; 0x2400
 8009baa:	f2c0 02f4 	movt	r2, #244	; 0xf4
 8009bae:	601a      	str	r2, [r3, #0]
      break;
 8009bb0:	e069      	b.n	8009c86 <SystemCoreClockUpdate+0x13a>
    case 0x04:  /* HSE used as system clock source */
      SystemCoreClock = HSE_VALUE;
 8009bb2:	f240 430c 	movw	r3, #1036	; 0x40c
 8009bb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009bba:	f44f 5258 	mov.w	r2, #13824	; 0x3600
 8009bbe:	f2c0 126e 	movt	r2, #366	; 0x16e
 8009bc2:	601a      	str	r2, [r3, #0]
      break;
 8009bc4:	e05f      	b.n	8009c86 <SystemCoreClockUpdate+0x13a>
    case 0x08:  /* PLL used as system clock source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8009bc6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009bca:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009bce:	685b      	ldr	r3, [r3, #4]
 8009bd0:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8009bd4:	ea4f 5393 	mov.w	r3, r3, lsr #22
 8009bd8:	9302      	str	r3, [sp, #8]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8009bda:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009bde:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009be2:	685b      	ldr	r3, [r3, #4]
 8009be4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8009be8:	9301      	str	r3, [sp, #4]
      
      if (pllsource != 0)
 8009bea:	9b02      	ldr	r3, [sp, #8]
 8009bec:	2b00      	cmp	r3, #0
 8009bee:	d014      	beq.n	8009c1a <SystemCoreClockUpdate+0xce>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8009bf0:	f44f 5358 	mov.w	r3, #13824	; 0x3600
 8009bf4:	f2c0 136e 	movt	r3, #366	; 0x16e
 8009bf8:	9a01      	ldr	r2, [sp, #4]
 8009bfa:	fbb3 f2f2 	udiv	r2, r3, r2
 8009bfe:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009c02:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009c06:	6859      	ldr	r1, [r3, #4]
 8009c08:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8009c0c:	400b      	ands	r3, r1
 8009c0e:	ea4f 1393 	mov.w	r3, r3, lsr #6
 8009c12:	fb03 f302 	mul.w	r3, r3, r2
 8009c16:	9305      	str	r3, [sp, #20]
 8009c18:	e013      	b.n	8009c42 <SystemCoreClockUpdate+0xf6>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8009c1a:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 8009c1e:	f2c0 03f4 	movt	r3, #244	; 0xf4
 8009c22:	9a01      	ldr	r2, [sp, #4]
 8009c24:	fbb3 f2f2 	udiv	r2, r3, r2
 8009c28:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009c2c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009c30:	6859      	ldr	r1, [r3, #4]
 8009c32:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8009c36:	400b      	ands	r3, r1
 8009c38:	ea4f 1393 	mov.w	r3, r3, lsr #6
 8009c3c:	fb03 f302 	mul.w	r3, r3, r2
 8009c40:	9305      	str	r3, [sp, #20]
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8009c42:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009c46:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009c4a:	685b      	ldr	r3, [r3, #4]
 8009c4c:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8009c50:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8009c54:	f103 0301 	add.w	r3, r3, #1
 8009c58:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8009c5c:	9303      	str	r3, [sp, #12]
      SystemCoreClock = pllvco/pllp;
 8009c5e:	9a05      	ldr	r2, [sp, #20]
 8009c60:	9b03      	ldr	r3, [sp, #12]
 8009c62:	fbb2 f2f3 	udiv	r2, r2, r3
 8009c66:	f240 430c 	movw	r3, #1036	; 0x40c
 8009c6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009c6e:	601a      	str	r2, [r3, #0]
      break;
 8009c70:	e009      	b.n	8009c86 <SystemCoreClockUpdate+0x13a>
    default:
      SystemCoreClock = HSI_VALUE;
 8009c72:	f240 430c 	movw	r3, #1036	; 0x40c
 8009c76:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009c7a:	f44f 5210 	mov.w	r2, #9216	; 0x2400
 8009c7e:	f2c0 02f4 	movt	r2, #244	; 0xf4
 8009c82:	601a      	str	r2, [r3, #0]
      break;
 8009c84:	bf00      	nop
  }
  /* Compute HCLK frequency --------------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8009c86:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009c8a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009c8e:	689b      	ldr	r3, [r3, #8]
 8009c90:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8009c94:	ea4f 1213 	mov.w	r2, r3, lsr #4
 8009c98:	f240 4310 	movw	r3, #1040	; 0x410
 8009c9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009ca0:	5c9b      	ldrb	r3, [r3, r2]
 8009ca2:	b2db      	uxtb	r3, r3
 8009ca4:	9304      	str	r3, [sp, #16]
  /* HCLK frequency */
  SystemCoreClock >>= tmp;
 8009ca6:	f240 430c 	movw	r3, #1036	; 0x40c
 8009caa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009cae:	681a      	ldr	r2, [r3, #0]
 8009cb0:	9b04      	ldr	r3, [sp, #16]
 8009cb2:	fa22 f203 	lsr.w	r2, r2, r3
 8009cb6:	f240 430c 	movw	r3, #1036	; 0x40c
 8009cba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009cbe:	601a      	str	r2, [r3, #0]
 8009cc0:	4623      	mov	r3, r4
 8009cc2:	f649 304d 	movw	r0, #39757	; 0x9b4d
 8009cc6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009cca:	4619      	mov	r1, r3
 8009ccc:	f002 ffaa 	bl	800cc24 <__cyg_profile_func_exit>
}
 8009cd0:	b006      	add	sp, #24
 8009cd2:	bd10      	pop	{r4, pc}

08009cd4 <SetSysClock>:
  *         is reset to the default reset state (done in SystemInit() function).   
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
 8009cd4:	b510      	push	{r4, lr}
 8009cd6:	b082      	sub	sp, #8
 8009cd8:	4674      	mov	r4, lr
 8009cda:	4623      	mov	r3, r4
 8009cdc:	f649 40d5 	movw	r0, #40149	; 0x9cd5
 8009ce0:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009ce4:	4619      	mov	r1, r3
 8009ce6:	f002 ff8f 	bl	800cc08 <__cyg_profile_func_enter>
/******************************************************************************/
/*            PLL (clocked by HSE) used as System clock source                */
/******************************************************************************/
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 8009cea:	f04f 0300 	mov.w	r3, #0
 8009cee:	9301      	str	r3, [sp, #4]
 8009cf0:	f04f 0300 	mov.w	r3, #0
 8009cf4:	9300      	str	r3, [sp, #0]
  
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8009cf6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009cfa:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009cfe:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009d02:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009d06:	6812      	ldr	r2, [r2, #0]
 8009d08:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8009d0c:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8009d0e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009d12:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009d16:	681b      	ldr	r3, [r3, #0]
 8009d18:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8009d1c:	9300      	str	r3, [sp, #0]
    StartUpCounter++;
 8009d1e:	9b01      	ldr	r3, [sp, #4]
 8009d20:	f103 0301 	add.w	r3, r3, #1
 8009d24:	9301      	str	r3, [sp, #4]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8009d26:	9b00      	ldr	r3, [sp, #0]
 8009d28:	2b00      	cmp	r3, #0
 8009d2a:	d103      	bne.n	8009d34 <SetSysClock+0x60>
 8009d2c:	9b01      	ldr	r3, [sp, #4]
 8009d2e:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8009d32:	d1ec      	bne.n	8009d0e <SetSysClock+0x3a>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8009d34:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009d38:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009d3c:	681b      	ldr	r3, [r3, #0]
 8009d3e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8009d42:	2b00      	cmp	r3, #0
 8009d44:	d003      	beq.n	8009d4e <SetSysClock+0x7a>
  {
    HSEStatus = (uint32_t)0x01;
 8009d46:	f04f 0301 	mov.w	r3, #1
 8009d4a:	9300      	str	r3, [sp, #0]
 8009d4c:	e002      	b.n	8009d54 <SetSysClock+0x80>
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 8009d4e:	f04f 0300 	mov.w	r3, #0
 8009d52:	9300      	str	r3, [sp, #0]
  }

  if (HSEStatus == (uint32_t)0x01)
 8009d54:	9b00      	ldr	r3, [sp, #0]
 8009d56:	2b01      	cmp	r3, #1
 8009d58:	f040 8082 	bne.w	8009e60 <SetSysClock+0x18c>
  {
    /* Select regulator voltage output Scale 1 mode, System frequency up to 168 MHz */
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 8009d5c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009d60:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009d64:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009d68:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009d6c:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8009d6e:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8009d72:	641a      	str	r2, [r3, #64]	; 0x40
#define  PWR_CR_VOS                          ((uint16_t)0x4000)     /*!< Regulator voltage scaling output selection */
    PWR->CR |= PWR_CR_VOS;
 8009d74:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8009d78:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009d7c:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 8009d80:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8009d84:	6812      	ldr	r2, [r2, #0]
 8009d86:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8009d8a:	601a      	str	r2, [r3, #0]

    /* HCLK = SYSCLK / 1*/
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 8009d8c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009d90:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009d94:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009d98:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009d9c:	6892      	ldr	r2, [r2, #8]
 8009d9e:	609a      	str	r2, [r3, #8]
      
    /* PCLK2 = HCLK / 2*/
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 8009da0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009da4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009da8:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009dac:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009db0:	6892      	ldr	r2, [r2, #8]
 8009db2:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8009db6:	609a      	str	r2, [r3, #8]
    
    /* PCLK1 = HCLK / 4*/
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 8009db8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009dbc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009dc0:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009dc4:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009dc8:	6892      	ldr	r2, [r2, #8]
 8009dca:	f442 52a0 	orr.w	r2, r2, #5120	; 0x1400
 8009dce:	609a      	str	r2, [r3, #8]

    /* Configure the main PLL */
    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 8009dd0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009dd4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009dd8:	f245 4218 	movw	r2, #21528	; 0x5418
 8009ddc:	f2c0 7240 	movt	r2, #1856	; 0x740
 8009de0:	605a      	str	r2, [r3, #4]
                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);

    /* Enable the main PLL */
    RCC->CR |= RCC_CR_PLLON;
 8009de2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009de6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009dea:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009dee:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009df2:	6812      	ldr	r2, [r2, #0]
 8009df4:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8009df8:	601a      	str	r2, [r3, #0]

    /* Wait till the main PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8009dfa:	bf00      	nop
 8009dfc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009e00:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009e04:	681b      	ldr	r3, [r3, #0]
 8009e06:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8009e0a:	2b00      	cmp	r3, #0
 8009e0c:	d0f6      	beq.n	8009dfc <SetSysClock+0x128>
    {
    }
   
    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
    FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 8009e0e:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8009e12:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009e16:	f240 6205 	movw	r2, #1541	; 0x605
 8009e1a:	601a      	str	r2, [r3, #0]

    /* Select the main PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8009e1c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009e20:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009e24:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009e28:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009e2c:	6892      	ldr	r2, [r2, #8]
 8009e2e:	f022 0203 	bic.w	r2, r2, #3
 8009e32:	609a      	str	r2, [r3, #8]
    RCC->CFGR |= RCC_CFGR_SW_PLL;
 8009e34:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009e38:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009e3c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009e40:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009e44:	6892      	ldr	r2, [r2, #8]
 8009e46:	f042 0202 	orr.w	r2, r2, #2
 8009e4a:	609a      	str	r2, [r3, #8]

    /* Wait till the main PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 8009e4c:	bf00      	nop
 8009e4e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009e52:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009e56:	689b      	ldr	r3, [r3, #8]
 8009e58:	f003 030c 	and.w	r3, r3, #12
 8009e5c:	2b08      	cmp	r3, #8
 8009e5e:	d1f6      	bne.n	8009e4e <SetSysClock+0x17a>
 8009e60:	4623      	mov	r3, r4
 8009e62:	f649 40d5 	movw	r0, #40149	; 0x9cd5
 8009e66:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009e6a:	4619      	mov	r1, r3
 8009e6c:	f002 feda 	bl	800cc24 <__cyg_profile_func_exit>
  else
  { /* If HSE fails to start-up, the application will have wrong clock
         configuration. User can add here some code to deal with this error */
  }

}
 8009e70:	b002      	add	sp, #8
 8009e72:	bd10      	pop	{r4, pc}

08009e74 <EXTI_GetITStatus>:
  * @param  EXTI_Line: specifies the EXTI line to check.
  *          This parameter can be EXTI_Linex where x can be(0..22)
  * @retval The new state of EXTI_Line (SET or RESET).
  */
ITStatus EXTI_GetITStatus(uint32_t EXTI_Line)
{
 8009e74:	b530      	push	{r4, r5, lr}
 8009e76:	b085      	sub	sp, #20
 8009e78:	4674      	mov	r4, lr
 8009e7a:	9001      	str	r0, [sp, #4]
 8009e7c:	4623      	mov	r3, r4
 8009e7e:	f649 6075 	movw	r0, #40565	; 0x9e75
 8009e82:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009e86:	4619      	mov	r1, r3
 8009e88:	f002 febe 	bl	800cc08 <__cyg_profile_func_enter>
  ITStatus bitstatus = RESET;
 8009e8c:	f04f 0300 	mov.w	r3, #0
 8009e90:	f88d 300f 	strb.w	r3, [sp, #15]
  uint32_t enablestatus = 0;
 8009e94:	f04f 0300 	mov.w	r3, #0
 8009e98:	9302      	str	r3, [sp, #8]
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  EXTI->IMR & EXTI_Line;
 8009e9a:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8009e9e:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8009ea2:	681a      	ldr	r2, [r3, #0]
 8009ea4:	9b01      	ldr	r3, [sp, #4]
 8009ea6:	4013      	ands	r3, r2
 8009ea8:	9302      	str	r3, [sp, #8]
  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 8009eaa:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8009eae:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8009eb2:	695a      	ldr	r2, [r3, #20]
 8009eb4:	9b01      	ldr	r3, [sp, #4]
 8009eb6:	4013      	ands	r3, r2
 8009eb8:	2b00      	cmp	r3, #0
 8009eba:	d007      	beq.n	8009ecc <EXTI_GetITStatus+0x58>
 8009ebc:	9b02      	ldr	r3, [sp, #8]
 8009ebe:	2b00      	cmp	r3, #0
 8009ec0:	d004      	beq.n	8009ecc <EXTI_GetITStatus+0x58>
  {
    bitstatus = SET;
 8009ec2:	f04f 0301 	mov.w	r3, #1
 8009ec6:	f88d 300f 	strb.w	r3, [sp, #15]
 8009eca:	e003      	b.n	8009ed4 <EXTI_GetITStatus+0x60>
  }
  else
  {
    bitstatus = RESET;
 8009ecc:	f04f 0300 	mov.w	r3, #0
 8009ed0:	f88d 300f 	strb.w	r3, [sp, #15]
  }
  return bitstatus;
 8009ed4:	f89d 500f 	ldrb.w	r5, [sp, #15]
 8009ed8:	4623      	mov	r3, r4
 8009eda:	f649 6075 	movw	r0, #40565	; 0x9e75
 8009ede:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009ee2:	4619      	mov	r1, r3
 8009ee4:	f002 fe9e 	bl	800cc24 <__cyg_profile_func_exit>
 8009ee8:	462b      	mov	r3, r5
}
 8009eea:	4618      	mov	r0, r3
 8009eec:	b005      	add	sp, #20
 8009eee:	bd30      	pop	{r4, r5, pc}

08009ef0 <EXTI_ClearITPendingBit>:
  * @param  EXTI_Line: specifies the EXTI lines to clear.
  *          This parameter can be any combination of EXTI_Linex where x can be (0..22)
  * @retval None
  */
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
 8009ef0:	b510      	push	{r4, lr}
 8009ef2:	b082      	sub	sp, #8
 8009ef4:	4674      	mov	r4, lr
 8009ef6:	9001      	str	r0, [sp, #4]
 8009ef8:	4623      	mov	r3, r4
 8009efa:	f649 60f1 	movw	r0, #40689	; 0x9ef1
 8009efe:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009f02:	4619      	mov	r1, r3
 8009f04:	f002 fe80 	bl	800cc08 <__cyg_profile_func_enter>
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 8009f08:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8009f0c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8009f10:	9a01      	ldr	r2, [sp, #4]
 8009f12:	615a      	str	r2, [r3, #20]
 8009f14:	4623      	mov	r3, r4
 8009f16:	f649 60f1 	movw	r0, #40689	; 0x9ef1
 8009f1a:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009f1e:	4619      	mov	r1, r3
 8009f20:	f002 fe80 	bl	800cc24 <__cyg_profile_func_exit>
}
 8009f24:	b002      	add	sp, #8
 8009f26:	bd10      	pop	{r4, pc}

08009f28 <GPIO_Init>:
  *                        - pull-down: GPIO_PuPd_DOWN
  *                        - Neither pull-up nor Pull-down: GPIO_PuPd_NOPULL
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8009f28:	b510      	push	{r4, lr}
 8009f2a:	b086      	sub	sp, #24
 8009f2c:	4674      	mov	r4, lr
 8009f2e:	9001      	str	r0, [sp, #4]
 8009f30:	9100      	str	r1, [sp, #0]
 8009f32:	4623      	mov	r3, r4
 8009f34:	f649 7029 	movw	r0, #40745	; 0x9f29
 8009f38:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009f3c:	4619      	mov	r1, r3
 8009f3e:	f002 fe63 	bl	800cc08 <__cyg_profile_func_enter>
  uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
 8009f42:	f04f 0300 	mov.w	r3, #0
 8009f46:	9305      	str	r3, [sp, #20]
 8009f48:	f04f 0300 	mov.w	r3, #0
 8009f4c:	9304      	str	r3, [sp, #16]
 8009f4e:	f04f 0300 	mov.w	r3, #0
 8009f52:	9303      	str	r3, [sp, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8009f54:	f04f 0300 	mov.w	r3, #0
 8009f58:	9305      	str	r3, [sp, #20]
 8009f5a:	e086      	b.n	800a06a <GPIO_Init+0x142>
  {
    pos = ((uint32_t)0x01) << pinpos;
 8009f5c:	9b05      	ldr	r3, [sp, #20]
 8009f5e:	f04f 0201 	mov.w	r2, #1
 8009f62:	fa02 f303 	lsl.w	r3, r2, r3
 8009f66:	9304      	str	r3, [sp, #16]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8009f68:	9b00      	ldr	r3, [sp, #0]
 8009f6a:	681a      	ldr	r2, [r3, #0]
 8009f6c:	9b04      	ldr	r3, [sp, #16]
 8009f6e:	4013      	ands	r3, r2
 8009f70:	9303      	str	r3, [sp, #12]

    if (currentpin == pos)
 8009f72:	9a03      	ldr	r2, [sp, #12]
 8009f74:	9b04      	ldr	r3, [sp, #16]
 8009f76:	429a      	cmp	r2, r3
 8009f78:	d173      	bne.n	800a062 <GPIO_Init+0x13a>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8009f7a:	9b01      	ldr	r3, [sp, #4]
 8009f7c:	681a      	ldr	r2, [r3, #0]
 8009f7e:	9b05      	ldr	r3, [sp, #20]
 8009f80:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8009f84:	f04f 0103 	mov.w	r1, #3
 8009f88:	fa01 f303 	lsl.w	r3, r1, r3
 8009f8c:	ea6f 0303 	mvn.w	r3, r3
 8009f90:	401a      	ands	r2, r3
 8009f92:	9b01      	ldr	r3, [sp, #4]
 8009f94:	601a      	str	r2, [r3, #0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8009f96:	9b01      	ldr	r3, [sp, #4]
 8009f98:	681a      	ldr	r2, [r3, #0]
 8009f9a:	9b00      	ldr	r3, [sp, #0]
 8009f9c:	791b      	ldrb	r3, [r3, #4]
 8009f9e:	4619      	mov	r1, r3
 8009fa0:	9b05      	ldr	r3, [sp, #20]
 8009fa2:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8009fa6:	fa01 f303 	lsl.w	r3, r1, r3
 8009faa:	431a      	orrs	r2, r3
 8009fac:	9b01      	ldr	r3, [sp, #4]
 8009fae:	601a      	str	r2, [r3, #0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8009fb0:	9b00      	ldr	r3, [sp, #0]
 8009fb2:	791b      	ldrb	r3, [r3, #4]
 8009fb4:	2b01      	cmp	r3, #1
 8009fb6:	d003      	beq.n	8009fc0 <GPIO_Init+0x98>
 8009fb8:	9b00      	ldr	r3, [sp, #0]
 8009fba:	791b      	ldrb	r3, [r3, #4]
 8009fbc:	2b02      	cmp	r3, #2
 8009fbe:	d134      	bne.n	800a02a <GPIO_Init+0x102>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8009fc0:	9b01      	ldr	r3, [sp, #4]
 8009fc2:	689a      	ldr	r2, [r3, #8]
 8009fc4:	9b05      	ldr	r3, [sp, #20]
 8009fc6:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8009fca:	f04f 0103 	mov.w	r1, #3
 8009fce:	fa01 f303 	lsl.w	r3, r1, r3
 8009fd2:	ea6f 0303 	mvn.w	r3, r3
 8009fd6:	401a      	ands	r2, r3
 8009fd8:	9b01      	ldr	r3, [sp, #4]
 8009fda:	609a      	str	r2, [r3, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8009fdc:	9b01      	ldr	r3, [sp, #4]
 8009fde:	689a      	ldr	r2, [r3, #8]
 8009fe0:	9b00      	ldr	r3, [sp, #0]
 8009fe2:	795b      	ldrb	r3, [r3, #5]
 8009fe4:	4619      	mov	r1, r3
 8009fe6:	9b05      	ldr	r3, [sp, #20]
 8009fe8:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8009fec:	fa01 f303 	lsl.w	r3, r1, r3
 8009ff0:	431a      	orrs	r2, r3
 8009ff2:	9b01      	ldr	r3, [sp, #4]
 8009ff4:	609a      	str	r2, [r3, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 8009ff6:	9b01      	ldr	r3, [sp, #4]
 8009ff8:	685a      	ldr	r2, [r3, #4]
 8009ffa:	9b05      	ldr	r3, [sp, #20]
 8009ffc:	b29b      	uxth	r3, r3
 8009ffe:	f04f 0101 	mov.w	r1, #1
 800a002:	fa01 f303 	lsl.w	r3, r1, r3
 800a006:	ea6f 0303 	mvn.w	r3, r3
 800a00a:	401a      	ands	r2, r3
 800a00c:	9b01      	ldr	r3, [sp, #4]
 800a00e:	605a      	str	r2, [r3, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 800a010:	9b01      	ldr	r3, [sp, #4]
 800a012:	685a      	ldr	r2, [r3, #4]
 800a014:	9b00      	ldr	r3, [sp, #0]
 800a016:	799b      	ldrb	r3, [r3, #6]
 800a018:	4619      	mov	r1, r3
 800a01a:	9b05      	ldr	r3, [sp, #20]
 800a01c:	b29b      	uxth	r3, r3
 800a01e:	fa01 f303 	lsl.w	r3, r1, r3
 800a022:	b29b      	uxth	r3, r3
 800a024:	431a      	orrs	r2, r3
 800a026:	9b01      	ldr	r3, [sp, #4]
 800a028:	605a      	str	r2, [r3, #4]
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 800a02a:	9b01      	ldr	r3, [sp, #4]
 800a02c:	68da      	ldr	r2, [r3, #12]
 800a02e:	9b05      	ldr	r3, [sp, #20]
 800a030:	b29b      	uxth	r3, r3
 800a032:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800a036:	f04f 0103 	mov.w	r1, #3
 800a03a:	fa01 f303 	lsl.w	r3, r1, r3
 800a03e:	ea6f 0303 	mvn.w	r3, r3
 800a042:	401a      	ands	r2, r3
 800a044:	9b01      	ldr	r3, [sp, #4]
 800a046:	60da      	str	r2, [r3, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 800a048:	9b01      	ldr	r3, [sp, #4]
 800a04a:	68da      	ldr	r2, [r3, #12]
 800a04c:	9b00      	ldr	r3, [sp, #0]
 800a04e:	79db      	ldrb	r3, [r3, #7]
 800a050:	4619      	mov	r1, r3
 800a052:	9b05      	ldr	r3, [sp, #20]
 800a054:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800a058:	fa01 f303 	lsl.w	r3, r1, r3
 800a05c:	431a      	orrs	r2, r3
 800a05e:	9b01      	ldr	r3, [sp, #4]
 800a060:	60da      	str	r2, [r3, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800a062:	9b05      	ldr	r3, [sp, #20]
 800a064:	f103 0301 	add.w	r3, r3, #1
 800a068:	9305      	str	r3, [sp, #20]
 800a06a:	9b05      	ldr	r3, [sp, #20]
 800a06c:	2b0f      	cmp	r3, #15
 800a06e:	f67f af75 	bls.w	8009f5c <GPIO_Init+0x34>
 800a072:	4623      	mov	r3, r4
 800a074:	f649 7029 	movw	r0, #40745	; 0x9f29
 800a078:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a07c:	4619      	mov	r1, r3
 800a07e:	f002 fdd1 	bl	800cc24 <__cyg_profile_func_exit>
      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 800a082:	b006      	add	sp, #24
 800a084:	bd10      	pop	{r4, pc}
 800a086:	bf00      	nop

0800a088 <GPIO_StructInit>:
  * @brief  Fills each GPIO_InitStruct member with its default value.
  * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will be initialized.
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
 800a088:	b510      	push	{r4, lr}
 800a08a:	b082      	sub	sp, #8
 800a08c:	4674      	mov	r4, lr
 800a08e:	9001      	str	r0, [sp, #4]
 800a090:	4623      	mov	r3, r4
 800a092:	f24a 0089 	movw	r0, #41097	; 0xa089
 800a096:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a09a:	4619      	mov	r1, r3
 800a09c:	f002 fdb4 	bl	800cc08 <__cyg_profile_func_enter>
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 800a0a0:	9b01      	ldr	r3, [sp, #4]
 800a0a2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800a0a6:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 800a0a8:	9b01      	ldr	r3, [sp, #4]
 800a0aa:	f04f 0200 	mov.w	r2, #0
 800a0ae:	711a      	strb	r2, [r3, #4]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 800a0b0:	9b01      	ldr	r3, [sp, #4]
 800a0b2:	f04f 0200 	mov.w	r2, #0
 800a0b6:	715a      	strb	r2, [r3, #5]
  GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
 800a0b8:	9b01      	ldr	r3, [sp, #4]
 800a0ba:	f04f 0200 	mov.w	r2, #0
 800a0be:	719a      	strb	r2, [r3, #6]
  GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
 800a0c0:	9b01      	ldr	r3, [sp, #4]
 800a0c2:	f04f 0200 	mov.w	r2, #0
 800a0c6:	71da      	strb	r2, [r3, #7]
 800a0c8:	4623      	mov	r3, r4
 800a0ca:	f24a 0089 	movw	r0, #41097	; 0xa089
 800a0ce:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a0d2:	4619      	mov	r1, r3
 800a0d4:	f002 fda6 	bl	800cc24 <__cyg_profile_func_exit>
}
 800a0d8:	b002      	add	sp, #8
 800a0da:	bd10      	pop	{r4, pc}

0800a0dc <GPIO_SetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800a0dc:	b510      	push	{r4, lr}
 800a0de:	b082      	sub	sp, #8
 800a0e0:	4674      	mov	r4, lr
 800a0e2:	9001      	str	r0, [sp, #4]
 800a0e4:	460b      	mov	r3, r1
 800a0e6:	f8ad 3002 	strh.w	r3, [sp, #2]
 800a0ea:	4623      	mov	r3, r4
 800a0ec:	f24a 00dd 	movw	r0, #41181	; 0xa0dd
 800a0f0:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a0f4:	4619      	mov	r1, r3
 800a0f6:	f002 fd87 	bl	800cc08 <__cyg_profile_func_enter>
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRL = GPIO_Pin;
 800a0fa:	9b01      	ldr	r3, [sp, #4]
 800a0fc:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 800a100:	831a      	strh	r2, [r3, #24]
 800a102:	4623      	mov	r3, r4
 800a104:	f24a 00dd 	movw	r0, #41181	; 0xa0dd
 800a108:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a10c:	4619      	mov	r1, r3
 800a10e:	f002 fd89 	bl	800cc24 <__cyg_profile_func_exit>
}
 800a112:	b002      	add	sp, #8
 800a114:	bd10      	pop	{r4, pc}
 800a116:	bf00      	nop

0800a118 <RCC_GetClocksFreq>:
  *           configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 800a118:	b510      	push	{r4, lr}
 800a11a:	b088      	sub	sp, #32
 800a11c:	4674      	mov	r4, lr
 800a11e:	9001      	str	r0, [sp, #4]
 800a120:	4623      	mov	r3, r4
 800a122:	f24a 1019 	movw	r0, #41241	; 0xa119
 800a126:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a12a:	4619      	mov	r1, r3
 800a12c:	f002 fd6c 	bl	800cc08 <__cyg_profile_func_enter>
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
 800a130:	f04f 0300 	mov.w	r3, #0
 800a134:	9306      	str	r3, [sp, #24]
 800a136:	f04f 0300 	mov.w	r3, #0
 800a13a:	9305      	str	r3, [sp, #20]
 800a13c:	f04f 0300 	mov.w	r3, #0
 800a140:	9307      	str	r3, [sp, #28]
 800a142:	f04f 0302 	mov.w	r3, #2
 800a146:	9304      	str	r3, [sp, #16]
 800a148:	f04f 0300 	mov.w	r3, #0
 800a14c:	9303      	str	r3, [sp, #12]
 800a14e:	f04f 0302 	mov.w	r3, #2
 800a152:	9302      	str	r3, [sp, #8]

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 800a154:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800a158:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800a15c:	689b      	ldr	r3, [r3, #8]
 800a15e:	f003 030c 	and.w	r3, r3, #12
 800a162:	9306      	str	r3, [sp, #24]

  switch (tmp)
 800a164:	9b06      	ldr	r3, [sp, #24]
 800a166:	2b04      	cmp	r3, #4
 800a168:	d00a      	beq.n	800a180 <RCC_GetClocksFreq+0x68>
 800a16a:	2b08      	cmp	r3, #8
 800a16c:	d00f      	beq.n	800a18e <RCC_GetClocksFreq+0x76>
 800a16e:	2b00      	cmp	r3, #0
 800a170:	d160      	bne.n	800a234 <RCC_GetClocksFreq+0x11c>
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 800a172:	9a01      	ldr	r2, [sp, #4]
 800a174:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 800a178:	f2c0 03f4 	movt	r3, #244	; 0xf4
 800a17c:	6013      	str	r3, [r2, #0]
      break;
 800a17e:	e060      	b.n	800a242 <RCC_GetClocksFreq+0x12a>
    case 0x04:  /* HSE used as system clock  source */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 800a180:	9a01      	ldr	r2, [sp, #4]
 800a182:	f44f 5358 	mov.w	r3, #13824	; 0x3600
 800a186:	f2c0 136e 	movt	r3, #366	; 0x16e
 800a18a:	6013      	str	r3, [r2, #0]
      break;
 800a18c:	e059      	b.n	800a242 <RCC_GetClocksFreq+0x12a>
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 800a18e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800a192:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800a196:	685b      	ldr	r3, [r3, #4]
 800a198:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800a19c:	ea4f 5393 	mov.w	r3, r3, lsr #22
 800a1a0:	9303      	str	r3, [sp, #12]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800a1a2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800a1a6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800a1aa:	685b      	ldr	r3, [r3, #4]
 800a1ac:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800a1b0:	9302      	str	r3, [sp, #8]
      
      if (pllsource != 0)
 800a1b2:	9b03      	ldr	r3, [sp, #12]
 800a1b4:	2b00      	cmp	r3, #0
 800a1b6:	d014      	beq.n	800a1e2 <RCC_GetClocksFreq+0xca>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 800a1b8:	f44f 5358 	mov.w	r3, #13824	; 0x3600
 800a1bc:	f2c0 136e 	movt	r3, #366	; 0x16e
 800a1c0:	9a02      	ldr	r2, [sp, #8]
 800a1c2:	fbb3 f2f2 	udiv	r2, r3, r2
 800a1c6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800a1ca:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800a1ce:	6859      	ldr	r1, [r3, #4]
 800a1d0:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800a1d4:	400b      	ands	r3, r1
 800a1d6:	ea4f 1393 	mov.w	r3, r3, lsr #6
 800a1da:	fb03 f302 	mul.w	r3, r3, r2
 800a1de:	9307      	str	r3, [sp, #28]
 800a1e0:	e013      	b.n	800a20a <RCC_GetClocksFreq+0xf2>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 800a1e2:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 800a1e6:	f2c0 03f4 	movt	r3, #244	; 0xf4
 800a1ea:	9a02      	ldr	r2, [sp, #8]
 800a1ec:	fbb3 f2f2 	udiv	r2, r3, r2
 800a1f0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800a1f4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800a1f8:	6859      	ldr	r1, [r3, #4]
 800a1fa:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800a1fe:	400b      	ands	r3, r1
 800a200:	ea4f 1393 	mov.w	r3, r3, lsr #6
 800a204:	fb03 f302 	mul.w	r3, r3, r2
 800a208:	9307      	str	r3, [sp, #28]
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 800a20a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800a20e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800a212:	685b      	ldr	r3, [r3, #4]
 800a214:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 800a218:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800a21c:	f103 0301 	add.w	r3, r3, #1
 800a220:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800a224:	9304      	str	r3, [sp, #16]
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 800a226:	9a07      	ldr	r2, [sp, #28]
 800a228:	9b04      	ldr	r3, [sp, #16]
 800a22a:	fbb2 f2f3 	udiv	r2, r2, r3
 800a22e:	9b01      	ldr	r3, [sp, #4]
 800a230:	601a      	str	r2, [r3, #0]
      break;
 800a232:	e006      	b.n	800a242 <RCC_GetClocksFreq+0x12a>
    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 800a234:	9a01      	ldr	r2, [sp, #4]
 800a236:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 800a23a:	f2c0 03f4 	movt	r3, #244	; 0xf4
 800a23e:	6013      	str	r3, [r2, #0]
      break;
 800a240:	bf00      	nop
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 800a242:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800a246:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800a24a:	689b      	ldr	r3, [r3, #8]
 800a24c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800a250:	9306      	str	r3, [sp, #24]
  tmp = tmp >> 4;
 800a252:	9b06      	ldr	r3, [sp, #24]
 800a254:	ea4f 1313 	mov.w	r3, r3, lsr #4
 800a258:	9306      	str	r3, [sp, #24]
  presc = APBAHBPrescTable[tmp];
 800a25a:	f240 4320 	movw	r3, #1056	; 0x420
 800a25e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800a262:	9a06      	ldr	r2, [sp, #24]
 800a264:	189b      	adds	r3, r3, r2
 800a266:	781b      	ldrb	r3, [r3, #0]
 800a268:	b2db      	uxtb	r3, r3
 800a26a:	9305      	str	r3, [sp, #20]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 800a26c:	9b01      	ldr	r3, [sp, #4]
 800a26e:	681a      	ldr	r2, [r3, #0]
 800a270:	9b05      	ldr	r3, [sp, #20]
 800a272:	fa22 f203 	lsr.w	r2, r2, r3
 800a276:	9b01      	ldr	r3, [sp, #4]
 800a278:	605a      	str	r2, [r3, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 800a27a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800a27e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800a282:	689b      	ldr	r3, [r3, #8]
 800a284:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 800a288:	9306      	str	r3, [sp, #24]
  tmp = tmp >> 10;
 800a28a:	9b06      	ldr	r3, [sp, #24]
 800a28c:	ea4f 2393 	mov.w	r3, r3, lsr #10
 800a290:	9306      	str	r3, [sp, #24]
  presc = APBAHBPrescTable[tmp];
 800a292:	f240 4320 	movw	r3, #1056	; 0x420
 800a296:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800a29a:	9a06      	ldr	r2, [sp, #24]
 800a29c:	189b      	adds	r3, r3, r2
 800a29e:	781b      	ldrb	r3, [r3, #0]
 800a2a0:	b2db      	uxtb	r3, r3
 800a2a2:	9305      	str	r3, [sp, #20]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800a2a4:	9b01      	ldr	r3, [sp, #4]
 800a2a6:	685a      	ldr	r2, [r3, #4]
 800a2a8:	9b05      	ldr	r3, [sp, #20]
 800a2aa:	fa22 f203 	lsr.w	r2, r2, r3
 800a2ae:	9b01      	ldr	r3, [sp, #4]
 800a2b0:	609a      	str	r2, [r3, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 800a2b2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800a2b6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800a2ba:	689b      	ldr	r3, [r3, #8]
 800a2bc:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 800a2c0:	9306      	str	r3, [sp, #24]
  tmp = tmp >> 13;
 800a2c2:	9b06      	ldr	r3, [sp, #24]
 800a2c4:	ea4f 3353 	mov.w	r3, r3, lsr #13
 800a2c8:	9306      	str	r3, [sp, #24]
  presc = APBAHBPrescTable[tmp];
 800a2ca:	f240 4320 	movw	r3, #1056	; 0x420
 800a2ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800a2d2:	9a06      	ldr	r2, [sp, #24]
 800a2d4:	189b      	adds	r3, r3, r2
 800a2d6:	781b      	ldrb	r3, [r3, #0]
 800a2d8:	b2db      	uxtb	r3, r3
 800a2da:	9305      	str	r3, [sp, #20]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800a2dc:	9b01      	ldr	r3, [sp, #4]
 800a2de:	685a      	ldr	r2, [r3, #4]
 800a2e0:	9b05      	ldr	r3, [sp, #20]
 800a2e2:	fa22 f203 	lsr.w	r2, r2, r3
 800a2e6:	9b01      	ldr	r3, [sp, #4]
 800a2e8:	60da      	str	r2, [r3, #12]
 800a2ea:	4623      	mov	r3, r4
 800a2ec:	f24a 1019 	movw	r0, #41241	; 0xa119
 800a2f0:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a2f4:	4619      	mov	r1, r3
 800a2f6:	f002 fc95 	bl	800cc24 <__cyg_profile_func_exit>
}
 800a2fa:	b008      	add	sp, #32
 800a2fc:	bd10      	pop	{r4, pc}
 800a2fe:	bf00      	nop

0800a300 <RCC_AHB1PeriphClockCmd>:
  *          This parameter can be: ENABLE or DISABLE.
  *  
  * @retval None
  */
void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 800a300:	b510      	push	{r4, lr}
 800a302:	b082      	sub	sp, #8
 800a304:	4674      	mov	r4, lr
 800a306:	9001      	str	r0, [sp, #4]
 800a308:	460b      	mov	r3, r1
 800a30a:	f88d 3003 	strb.w	r3, [sp, #3]
 800a30e:	4623      	mov	r3, r4
 800a310:	f24a 3001 	movw	r0, #41729	; 0xa301
 800a314:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a318:	4619      	mov	r1, r3
 800a31a:	f002 fc75 	bl	800cc08 <__cyg_profile_func_enter>
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800a31e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800a322:	2b00      	cmp	r3, #0
 800a324:	d00c      	beq.n	800a340 <RCC_AHB1PeriphClockCmd+0x40>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 800a326:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800a32a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800a32e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800a332:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800a336:	6b11      	ldr	r1, [r2, #48]	; 0x30
 800a338:	9a01      	ldr	r2, [sp, #4]
 800a33a:	430a      	orrs	r2, r1
 800a33c:	631a      	str	r2, [r3, #48]	; 0x30
 800a33e:	e00d      	b.n	800a35c <RCC_AHB1PeriphClockCmd+0x5c>
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 800a340:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800a344:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800a348:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800a34c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800a350:	6b11      	ldr	r1, [r2, #48]	; 0x30
 800a352:	9a01      	ldr	r2, [sp, #4]
 800a354:	ea6f 0202 	mvn.w	r2, r2
 800a358:	400a      	ands	r2, r1
 800a35a:	631a      	str	r2, [r3, #48]	; 0x30
 800a35c:	4623      	mov	r3, r4
 800a35e:	f24a 3001 	movw	r0, #41729	; 0xa301
 800a362:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a366:	4619      	mov	r1, r3
 800a368:	f002 fc5c 	bl	800cc24 <__cyg_profile_func_exit>
  }
}
 800a36c:	b002      	add	sp, #8
 800a36e:	bd10      	pop	{r4, pc}

0800a370 <RCC_AHB2PeriphClockCmd>:
  *          This parameter can be: ENABLE or DISABLE.
  *
  * @retval None
  */
void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
 800a370:	b510      	push	{r4, lr}
 800a372:	b082      	sub	sp, #8
 800a374:	4674      	mov	r4, lr
 800a376:	9001      	str	r0, [sp, #4]
 800a378:	460b      	mov	r3, r1
 800a37a:	f88d 3003 	strb.w	r3, [sp, #3]
 800a37e:	4623      	mov	r3, r4
 800a380:	f24a 3071 	movw	r0, #41841	; 0xa371
 800a384:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a388:	4619      	mov	r1, r3
 800a38a:	f002 fc3d 	bl	800cc08 <__cyg_profile_func_enter>
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800a38e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800a392:	2b00      	cmp	r3, #0
 800a394:	d00c      	beq.n	800a3b0 <RCC_AHB2PeriphClockCmd+0x40>
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
 800a396:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800a39a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800a39e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800a3a2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800a3a6:	6b51      	ldr	r1, [r2, #52]	; 0x34
 800a3a8:	9a01      	ldr	r2, [sp, #4]
 800a3aa:	430a      	orrs	r2, r1
 800a3ac:	635a      	str	r2, [r3, #52]	; 0x34
 800a3ae:	e00d      	b.n	800a3cc <RCC_AHB2PeriphClockCmd+0x5c>
  }
  else
  {
    RCC->AHB2ENR &= ~RCC_AHB2Periph;
 800a3b0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800a3b4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800a3b8:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800a3bc:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800a3c0:	6b51      	ldr	r1, [r2, #52]	; 0x34
 800a3c2:	9a01      	ldr	r2, [sp, #4]
 800a3c4:	ea6f 0202 	mvn.w	r2, r2
 800a3c8:	400a      	ands	r2, r1
 800a3ca:	635a      	str	r2, [r3, #52]	; 0x34
 800a3cc:	4623      	mov	r3, r4
 800a3ce:	f24a 3071 	movw	r0, #41841	; 0xa371
 800a3d2:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a3d6:	4619      	mov	r1, r3
 800a3d8:	f002 fc24 	bl	800cc24 <__cyg_profile_func_exit>
  }
}
 800a3dc:	b002      	add	sp, #8
 800a3de:	bd10      	pop	{r4, pc}

0800a3e0 <RCC_AHB3PeriphClockCmd>:
  *          This parameter can be: ENABLE or DISABLE.
  *  
  * @retval None
  */
void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
 800a3e0:	b510      	push	{r4, lr}
 800a3e2:	b082      	sub	sp, #8
 800a3e4:	4674      	mov	r4, lr
 800a3e6:	9001      	str	r0, [sp, #4]
 800a3e8:	460b      	mov	r3, r1
 800a3ea:	f88d 3003 	strb.w	r3, [sp, #3]
 800a3ee:	4623      	mov	r3, r4
 800a3f0:	f24a 30e1 	movw	r0, #41953	; 0xa3e1
 800a3f4:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a3f8:	4619      	mov	r1, r3
 800a3fa:	f002 fc05 	bl	800cc08 <__cyg_profile_func_enter>
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800a3fe:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800a402:	2b00      	cmp	r3, #0
 800a404:	d00c      	beq.n	800a420 <RCC_AHB3PeriphClockCmd+0x40>
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
 800a406:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800a40a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800a40e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800a412:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800a416:	6b91      	ldr	r1, [r2, #56]	; 0x38
 800a418:	9a01      	ldr	r2, [sp, #4]
 800a41a:	430a      	orrs	r2, r1
 800a41c:	639a      	str	r2, [r3, #56]	; 0x38
 800a41e:	e00d      	b.n	800a43c <RCC_AHB3PeriphClockCmd+0x5c>
  }
  else
  {
    RCC->AHB3ENR &= ~RCC_AHB3Periph;
 800a420:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800a424:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800a428:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800a42c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800a430:	6b91      	ldr	r1, [r2, #56]	; 0x38
 800a432:	9a01      	ldr	r2, [sp, #4]
 800a434:	ea6f 0202 	mvn.w	r2, r2
 800a438:	400a      	ands	r2, r1
 800a43a:	639a      	str	r2, [r3, #56]	; 0x38
 800a43c:	4623      	mov	r3, r4
 800a43e:	f24a 30e1 	movw	r0, #41953	; 0xa3e1
 800a442:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a446:	4619      	mov	r1, r3
 800a448:	f002 fbec 	bl	800cc24 <__cyg_profile_func_exit>
  }
}
 800a44c:	b002      	add	sp, #8
 800a44e:	bd10      	pop	{r4, pc}

0800a450 <RCC_APB1PeriphClockCmd>:
  *          This parameter can be: ENABLE or DISABLE.
  *  
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 800a450:	b510      	push	{r4, lr}
 800a452:	b082      	sub	sp, #8
 800a454:	4674      	mov	r4, lr
 800a456:	9001      	str	r0, [sp, #4]
 800a458:	460b      	mov	r3, r1
 800a45a:	f88d 3003 	strb.w	r3, [sp, #3]
 800a45e:	4623      	mov	r3, r4
 800a460:	f24a 4051 	movw	r0, #42065	; 0xa451
 800a464:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a468:	4619      	mov	r1, r3
 800a46a:	f002 fbcd 	bl	800cc08 <__cyg_profile_func_enter>
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800a46e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800a472:	2b00      	cmp	r3, #0
 800a474:	d00c      	beq.n	800a490 <RCC_APB1PeriphClockCmd+0x40>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 800a476:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800a47a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800a47e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800a482:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800a486:	6c11      	ldr	r1, [r2, #64]	; 0x40
 800a488:	9a01      	ldr	r2, [sp, #4]
 800a48a:	430a      	orrs	r2, r1
 800a48c:	641a      	str	r2, [r3, #64]	; 0x40
 800a48e:	e00d      	b.n	800a4ac <RCC_APB1PeriphClockCmd+0x5c>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 800a490:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800a494:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800a498:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800a49c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800a4a0:	6c11      	ldr	r1, [r2, #64]	; 0x40
 800a4a2:	9a01      	ldr	r2, [sp, #4]
 800a4a4:	ea6f 0202 	mvn.w	r2, r2
 800a4a8:	400a      	ands	r2, r1
 800a4aa:	641a      	str	r2, [r3, #64]	; 0x40
 800a4ac:	4623      	mov	r3, r4
 800a4ae:	f24a 4051 	movw	r0, #42065	; 0xa451
 800a4b2:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a4b6:	4619      	mov	r1, r3
 800a4b8:	f002 fbb4 	bl	800cc24 <__cyg_profile_func_exit>
  }
}
 800a4bc:	b002      	add	sp, #8
 800a4be:	bd10      	pop	{r4, pc}

0800a4c0 <RCC_APB2PeriphClockCmd>:
  *          This parameter can be: ENABLE or DISABLE.
  *  
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 800a4c0:	b510      	push	{r4, lr}
 800a4c2:	b082      	sub	sp, #8
 800a4c4:	4674      	mov	r4, lr
 800a4c6:	9001      	str	r0, [sp, #4]
 800a4c8:	460b      	mov	r3, r1
 800a4ca:	f88d 3003 	strb.w	r3, [sp, #3]
 800a4ce:	4623      	mov	r3, r4
 800a4d0:	f24a 40c1 	movw	r0, #42177	; 0xa4c1
 800a4d4:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a4d8:	4619      	mov	r1, r3
 800a4da:	f002 fb95 	bl	800cc08 <__cyg_profile_func_enter>
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800a4de:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800a4e2:	2b00      	cmp	r3, #0
 800a4e4:	d00c      	beq.n	800a500 <RCC_APB2PeriphClockCmd+0x40>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 800a4e6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800a4ea:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800a4ee:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800a4f2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800a4f6:	6c51      	ldr	r1, [r2, #68]	; 0x44
 800a4f8:	9a01      	ldr	r2, [sp, #4]
 800a4fa:	430a      	orrs	r2, r1
 800a4fc:	645a      	str	r2, [r3, #68]	; 0x44
 800a4fe:	e00d      	b.n	800a51c <RCC_APB2PeriphClockCmd+0x5c>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 800a500:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800a504:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800a508:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800a50c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800a510:	6c51      	ldr	r1, [r2, #68]	; 0x44
 800a512:	9a01      	ldr	r2, [sp, #4]
 800a514:	ea6f 0202 	mvn.w	r2, r2
 800a518:	400a      	ands	r2, r1
 800a51a:	645a      	str	r2, [r3, #68]	; 0x44
 800a51c:	4623      	mov	r3, r4
 800a51e:	f24a 40c1 	movw	r0, #42177	; 0xa4c1
 800a522:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a526:	4619      	mov	r1, r3
 800a528:	f002 fb7c 	bl	800cc24 <__cyg_profile_func_exit>
  }
}
 800a52c:	b002      	add	sp, #8
 800a52e:	bd10      	pop	{r4, pc}

0800a530 <USART_ITConfig>:
  * @param  NewState: new state of the specified USARTx interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
{
 800a530:	b510      	push	{r4, lr}
 800a532:	b086      	sub	sp, #24
 800a534:	4674      	mov	r4, lr
 800a536:	9001      	str	r0, [sp, #4]
 800a538:	4613      	mov	r3, r2
 800a53a:	460a      	mov	r2, r1
 800a53c:	f8ad 2002 	strh.w	r2, [sp, #2]
 800a540:	f88d 3001 	strb.w	r3, [sp, #1]
 800a544:	4623      	mov	r3, r4
 800a546:	f24a 5031 	movw	r0, #42289	; 0xa531
 800a54a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a54e:	4619      	mov	r1, r3
 800a550:	f002 fb5a 	bl	800cc08 <__cyg_profile_func_enter>
  uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
 800a554:	f04f 0300 	mov.w	r3, #0
 800a558:	9304      	str	r3, [sp, #16]
 800a55a:	f04f 0300 	mov.w	r3, #0
 800a55e:	9303      	str	r3, [sp, #12]
 800a560:	f04f 0300 	mov.w	r3, #0
 800a564:	9302      	str	r3, [sp, #8]
  uint32_t usartxbase = 0x00;
 800a566:	f04f 0300 	mov.w	r3, #0
 800a56a:	9305      	str	r3, [sp, #20]
  if (USART_IT == USART_IT_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  usartxbase = (uint32_t)USARTx;
 800a56c:	9b01      	ldr	r3, [sp, #4]
 800a56e:	9305      	str	r3, [sp, #20]

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 800a570:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 800a574:	b2db      	uxtb	r3, r3
 800a576:	ea4f 1353 	mov.w	r3, r3, lsr #5
 800a57a:	b2db      	uxtb	r3, r3
 800a57c:	9304      	str	r3, [sp, #16]

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
 800a57e:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 800a582:	f003 031f 	and.w	r3, r3, #31
 800a586:	9303      	str	r3, [sp, #12]
  itmask = (((uint32_t)0x01) << itpos);
 800a588:	9b03      	ldr	r3, [sp, #12]
 800a58a:	f04f 0201 	mov.w	r2, #1
 800a58e:	fa02 f303 	lsl.w	r3, r2, r3
 800a592:	9302      	str	r3, [sp, #8]
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 800a594:	9b04      	ldr	r3, [sp, #16]
 800a596:	2b01      	cmp	r3, #1
 800a598:	d104      	bne.n	800a5a4 <USART_ITConfig+0x74>
  {
    usartxbase += 0x0C;
 800a59a:	9b05      	ldr	r3, [sp, #20]
 800a59c:	f103 030c 	add.w	r3, r3, #12
 800a5a0:	9305      	str	r3, [sp, #20]
 800a5a2:	e00b      	b.n	800a5bc <USART_ITConfig+0x8c>
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 800a5a4:	9b04      	ldr	r3, [sp, #16]
 800a5a6:	2b02      	cmp	r3, #2
 800a5a8:	d104      	bne.n	800a5b4 <USART_ITConfig+0x84>
  {
    usartxbase += 0x10;
 800a5aa:	9b05      	ldr	r3, [sp, #20]
 800a5ac:	f103 0310 	add.w	r3, r3, #16
 800a5b0:	9305      	str	r3, [sp, #20]
 800a5b2:	e003      	b.n	800a5bc <USART_ITConfig+0x8c>
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
 800a5b4:	9b05      	ldr	r3, [sp, #20]
 800a5b6:	f103 0314 	add.w	r3, r3, #20
 800a5ba:	9305      	str	r3, [sp, #20]
  }
  if (NewState != DISABLE)
 800a5bc:	f89d 3001 	ldrb.w	r3, [sp, #1]
 800a5c0:	2b00      	cmp	r3, #0
 800a5c2:	d006      	beq.n	800a5d2 <USART_ITConfig+0xa2>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 800a5c4:	9b05      	ldr	r3, [sp, #20]
 800a5c6:	9a05      	ldr	r2, [sp, #20]
 800a5c8:	6811      	ldr	r1, [r2, #0]
 800a5ca:	9a02      	ldr	r2, [sp, #8]
 800a5cc:	430a      	orrs	r2, r1
 800a5ce:	601a      	str	r2, [r3, #0]
 800a5d0:	e007      	b.n	800a5e2 <USART_ITConfig+0xb2>
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 800a5d2:	9b05      	ldr	r3, [sp, #20]
 800a5d4:	9a05      	ldr	r2, [sp, #20]
 800a5d6:	6811      	ldr	r1, [r2, #0]
 800a5d8:	9a02      	ldr	r2, [sp, #8]
 800a5da:	ea6f 0202 	mvn.w	r2, r2
 800a5de:	400a      	ands	r2, r1
 800a5e0:	601a      	str	r2, [r3, #0]
 800a5e2:	4623      	mov	r3, r4
 800a5e4:	f24a 5031 	movw	r0, #42289	; 0xa531
 800a5e8:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a5ec:	4619      	mov	r1, r3
 800a5ee:	f002 fb19 	bl	800cc24 <__cyg_profile_func_exit>
  }
}
 800a5f2:	b006      	add	sp, #24
 800a5f4:	bd10      	pop	{r4, pc}
 800a5f6:	bf00      	nop

0800a5f8 <NVIC_PriorityGroupConfig>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)
{
 800a5f8:	b510      	push	{r4, lr}
 800a5fa:	b082      	sub	sp, #8
 800a5fc:	4674      	mov	r4, lr
 800a5fe:	9001      	str	r0, [sp, #4]
 800a600:	4623      	mov	r3, r4
 800a602:	f24a 50f9 	movw	r0, #42489	; 0xa5f9
 800a606:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a60a:	4619      	mov	r1, r3
 800a60c:	f002 fafc 	bl	800cc08 <__cyg_profile_func_enter>
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 800a610:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800a614:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800a618:	9a01      	ldr	r2, [sp, #4]
 800a61a:	f042 62bf 	orr.w	r2, r2, #100139008	; 0x5f80000
 800a61e:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800a622:	60da      	str	r2, [r3, #12]
 800a624:	4623      	mov	r3, r4
 800a626:	f24a 50f9 	movw	r0, #42489	; 0xa5f9
 800a62a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a62e:	4619      	mov	r1, r3
 800a630:	f002 faf8 	bl	800cc24 <__cyg_profile_func_exit>
}
 800a634:	b002      	add	sp, #8
 800a636:	bd10      	pop	{r4, pc}

0800a638 <NVIC_SetVectorTable>:
  *     @arg NVIC_VectTab_FLASH
  * @param  Offset: Vector Table base offset field. This value must be a multiple of 0x200.
  * @retval None
  */
void NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset)
{ 
 800a638:	b510      	push	{r4, lr}
 800a63a:	b082      	sub	sp, #8
 800a63c:	4674      	mov	r4, lr
 800a63e:	9001      	str	r0, [sp, #4]
 800a640:	9100      	str	r1, [sp, #0]
 800a642:	4623      	mov	r3, r4
 800a644:	f24a 6039 	movw	r0, #42553	; 0xa639
 800a648:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a64c:	4619      	mov	r1, r3
 800a64e:	f002 fadb 	bl	800cc08 <__cyg_profile_func_enter>
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 800a652:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800a656:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800a65a:	9a00      	ldr	r2, [sp, #0]
 800a65c:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 800a660:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
 800a664:	9901      	ldr	r1, [sp, #4]
 800a666:	430a      	orrs	r2, r1
 800a668:	609a      	str	r2, [r3, #8]
 800a66a:	4623      	mov	r3, r4
 800a66c:	f24a 6039 	movw	r0, #42553	; 0xa639
 800a670:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a674:	4619      	mov	r1, r3
 800a676:	f002 fad5 	bl	800cc24 <__cyg_profile_func_exit>
}
 800a67a:	b002      	add	sp, #8
 800a67c:	bd10      	pop	{r4, pc}
 800a67e:	bf00      	nop

0800a680 <SysTick_CLKSourceConfig>:
  *     @arg SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8 selected as SysTick clock source.
  *     @arg SysTick_CLKSource_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
 800a680:	b510      	push	{r4, lr}
 800a682:	b082      	sub	sp, #8
 800a684:	4674      	mov	r4, lr
 800a686:	9001      	str	r0, [sp, #4]
 800a688:	4623      	mov	r3, r4
 800a68a:	f24a 6081 	movw	r0, #42625	; 0xa681
 800a68e:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a692:	4619      	mov	r1, r3
 800a694:	f002 fab8 	bl	800cc08 <__cyg_profile_func_enter>
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 800a698:	9b01      	ldr	r3, [sp, #4]
 800a69a:	2b04      	cmp	r3, #4
 800a69c:	d10c      	bne.n	800a6b8 <SysTick_CLKSourceConfig+0x38>
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 800a69e:	f24e 0310 	movw	r3, #57360	; 0xe010
 800a6a2:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800a6a6:	f24e 0210 	movw	r2, #57360	; 0xe010
 800a6aa:	f2ce 0200 	movt	r2, #57344	; 0xe000
 800a6ae:	6812      	ldr	r2, [r2, #0]
 800a6b0:	f042 0204 	orr.w	r2, r2, #4
 800a6b4:	601a      	str	r2, [r3, #0]
 800a6b6:	e00b      	b.n	800a6d0 <SysTick_CLKSourceConfig+0x50>
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 800a6b8:	f24e 0310 	movw	r3, #57360	; 0xe010
 800a6bc:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800a6c0:	f24e 0210 	movw	r2, #57360	; 0xe010
 800a6c4:	f2ce 0200 	movt	r2, #57344	; 0xe000
 800a6c8:	6812      	ldr	r2, [r2, #0]
 800a6ca:	f022 0204 	bic.w	r2, r2, #4
 800a6ce:	601a      	str	r2, [r3, #0]
 800a6d0:	4623      	mov	r3, r4
 800a6d2:	f24a 6081 	movw	r0, #42625	; 0xa681
 800a6d6:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a6da:	4619      	mov	r1, r3
 800a6dc:	f002 faa2 	bl	800cc24 <__cyg_profile_func_exit>
  }
}
 800a6e0:	b002      	add	sp, #8
 800a6e2:	bd10      	pop	{r4, pc}

0800a6e4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
 800a6e4:	b510      	push	{r4, lr}
 800a6e6:	b082      	sub	sp, #8
 800a6e8:	4674      	mov	r4, lr
 800a6ea:	9001      	str	r0, [sp, #4]
 800a6ec:	4623      	mov	r3, r4
 800a6ee:	f24a 60e5 	movw	r0, #42725	; 0xa6e5
 800a6f2:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a6f6:	4619      	mov	r1, r3
 800a6f8:	f002 fa86 	bl	800cc08 <__cyg_profile_func_enter>
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 800a6fc:	9b01      	ldr	r3, [sp, #4]
 800a6fe:	f103 0208 	add.w	r2, r3, #8
 800a702:	9b01      	ldr	r3, [sp, #4]
 800a704:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800a706:	9b01      	ldr	r3, [sp, #4]
 800a708:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800a70c:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 800a70e:	9b01      	ldr	r3, [sp, #4]
 800a710:	f103 0208 	add.w	r2, r3, #8
 800a714:	9b01      	ldr	r3, [sp, #4]
 800a716:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 800a718:	9b01      	ldr	r3, [sp, #4]
 800a71a:	f103 0208 	add.w	r2, r3, #8
 800a71e:	9b01      	ldr	r3, [sp, #4]
 800a720:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 800a722:	9b01      	ldr	r3, [sp, #4]
 800a724:	f04f 0200 	mov.w	r2, #0
 800a728:	601a      	str	r2, [r3, #0]
 800a72a:	4623      	mov	r3, r4
 800a72c:	f24a 60e5 	movw	r0, #42725	; 0xa6e5
 800a730:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a734:	4619      	mov	r1, r3
 800a736:	f002 fa75 	bl	800cc24 <__cyg_profile_func_exit>
}
 800a73a:	b002      	add	sp, #8
 800a73c:	bd10      	pop	{r4, pc}
 800a73e:	bf00      	nop

0800a740 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
 800a740:	b510      	push	{r4, lr}
 800a742:	b082      	sub	sp, #8
 800a744:	4674      	mov	r4, lr
 800a746:	9001      	str	r0, [sp, #4]
 800a748:	4623      	mov	r3, r4
 800a74a:	f24a 7041 	movw	r0, #42817	; 0xa741
 800a74e:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a752:	4619      	mov	r1, r3
 800a754:	f002 fa58 	bl	800cc08 <__cyg_profile_func_enter>
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 800a758:	9b01      	ldr	r3, [sp, #4]
 800a75a:	f04f 0200 	mov.w	r2, #0
 800a75e:	611a      	str	r2, [r3, #16]
 800a760:	4623      	mov	r3, r4
 800a762:	f24a 7041 	movw	r0, #42817	; 0xa741
 800a766:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a76a:	4619      	mov	r1, r3
 800a76c:	f002 fa5a 	bl	800cc24 <__cyg_profile_func_exit>
}
 800a770:	b002      	add	sp, #8
 800a772:	bd10      	pop	{r4, pc}

0800a774 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
 800a774:	b510      	push	{r4, lr}
 800a776:	b084      	sub	sp, #16
 800a778:	4674      	mov	r4, lr
 800a77a:	9001      	str	r0, [sp, #4]
 800a77c:	9100      	str	r1, [sp, #0]
 800a77e:	4623      	mov	r3, r4
 800a780:	f24a 7075 	movw	r0, #42869	; 0xa775
 800a784:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a788:	4619      	mov	r1, r3
 800a78a:	f002 fa3d 	bl	800cc08 <__cyg_profile_func_enter>

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 800a78e:	9b01      	ldr	r3, [sp, #4]
 800a790:	685b      	ldr	r3, [r3, #4]
 800a792:	9303      	str	r3, [sp, #12]

	pxNewListItem->pxNext = pxIndex->pxNext;
 800a794:	9b03      	ldr	r3, [sp, #12]
 800a796:	685a      	ldr	r2, [r3, #4]
 800a798:	9b00      	ldr	r3, [sp, #0]
 800a79a:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
 800a79c:	9b01      	ldr	r3, [sp, #4]
 800a79e:	685a      	ldr	r2, [r3, #4]
 800a7a0:	9b00      	ldr	r3, [sp, #0]
 800a7a2:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 800a7a4:	9b03      	ldr	r3, [sp, #12]
 800a7a6:	685b      	ldr	r3, [r3, #4]
 800a7a8:	9a00      	ldr	r2, [sp, #0]
 800a7aa:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 800a7ac:	9b03      	ldr	r3, [sp, #12]
 800a7ae:	9a00      	ldr	r2, [sp, #0]
 800a7b0:	605a      	str	r2, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 800a7b2:	9b01      	ldr	r3, [sp, #4]
 800a7b4:	9a00      	ldr	r2, [sp, #0]
 800a7b6:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 800a7b8:	9b00      	ldr	r3, [sp, #0]
 800a7ba:	9a01      	ldr	r2, [sp, #4]
 800a7bc:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 800a7be:	9b01      	ldr	r3, [sp, #4]
 800a7c0:	681b      	ldr	r3, [r3, #0]
 800a7c2:	f103 0201 	add.w	r2, r3, #1
 800a7c6:	9b01      	ldr	r3, [sp, #4]
 800a7c8:	601a      	str	r2, [r3, #0]
 800a7ca:	4623      	mov	r3, r4
 800a7cc:	f24a 7075 	movw	r0, #42869	; 0xa775
 800a7d0:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a7d4:	4619      	mov	r1, r3
 800a7d6:	f002 fa25 	bl	800cc24 <__cyg_profile_func_exit>
}
 800a7da:	b004      	add	sp, #16
 800a7dc:	bd10      	pop	{r4, pc}
 800a7de:	bf00      	nop

0800a7e0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
 800a7e0:	b510      	push	{r4, lr}
 800a7e2:	b084      	sub	sp, #16
 800a7e4:	4674      	mov	r4, lr
 800a7e6:	9001      	str	r0, [sp, #4]
 800a7e8:	9100      	str	r1, [sp, #0]
 800a7ea:	4623      	mov	r3, r4
 800a7ec:	f24a 70e1 	movw	r0, #42977	; 0xa7e1
 800a7f0:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a7f4:	4619      	mov	r1, r3
 800a7f6:	f002 fa07 	bl	800cc08 <__cyg_profile_func_enter>
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 800a7fa:	9b00      	ldr	r3, [sp, #0]
 800a7fc:	681b      	ldr	r3, [r3, #0]
 800a7fe:	9302      	str	r3, [sp, #8]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 800a800:	9b02      	ldr	r3, [sp, #8]
 800a802:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800a806:	d103      	bne.n	800a810 <vListInsert+0x30>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 800a808:	9b01      	ldr	r3, [sp, #4]
 800a80a:	691b      	ldr	r3, [r3, #16]
 800a80c:	9303      	str	r3, [sp, #12]
 800a80e:	e00d      	b.n	800a82c <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 800a810:	9b01      	ldr	r3, [sp, #4]
 800a812:	f103 0308 	add.w	r3, r3, #8
 800a816:	9303      	str	r3, [sp, #12]
 800a818:	e002      	b.n	800a820 <vListInsert+0x40>
 800a81a:	9b03      	ldr	r3, [sp, #12]
 800a81c:	685b      	ldr	r3, [r3, #4]
 800a81e:	9303      	str	r3, [sp, #12]
 800a820:	9b03      	ldr	r3, [sp, #12]
 800a822:	685b      	ldr	r3, [r3, #4]
 800a824:	681a      	ldr	r2, [r3, #0]
 800a826:	9b02      	ldr	r3, [sp, #8]
 800a828:	429a      	cmp	r2, r3
 800a82a:	d9f6      	bls.n	800a81a <vListInsert+0x3a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 800a82c:	9b03      	ldr	r3, [sp, #12]
 800a82e:	685a      	ldr	r2, [r3, #4]
 800a830:	9b00      	ldr	r3, [sp, #0]
 800a832:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 800a834:	9b00      	ldr	r3, [sp, #0]
 800a836:	685b      	ldr	r3, [r3, #4]
 800a838:	9a00      	ldr	r2, [sp, #0]
 800a83a:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 800a83c:	9b00      	ldr	r3, [sp, #0]
 800a83e:	9a03      	ldr	r2, [sp, #12]
 800a840:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 800a842:	9b03      	ldr	r3, [sp, #12]
 800a844:	9a00      	ldr	r2, [sp, #0]
 800a846:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 800a848:	9b00      	ldr	r3, [sp, #0]
 800a84a:	9a01      	ldr	r2, [sp, #4]
 800a84c:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 800a84e:	9b01      	ldr	r3, [sp, #4]
 800a850:	681b      	ldr	r3, [r3, #0]
 800a852:	f103 0201 	add.w	r2, r3, #1
 800a856:	9b01      	ldr	r3, [sp, #4]
 800a858:	601a      	str	r2, [r3, #0]
 800a85a:	4623      	mov	r3, r4
 800a85c:	f24a 70e1 	movw	r0, #42977	; 0xa7e1
 800a860:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a864:	4619      	mov	r1, r3
 800a866:	f002 f9dd 	bl	800cc24 <__cyg_profile_func_exit>
}
 800a86a:	b004      	add	sp, #16
 800a86c:	bd10      	pop	{r4, pc}
 800a86e:	bf00      	nop

0800a870 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
 800a870:	b510      	push	{r4, lr}
 800a872:	b084      	sub	sp, #16
 800a874:	4674      	mov	r4, lr
 800a876:	9001      	str	r0, [sp, #4]
 800a878:	4623      	mov	r3, r4
 800a87a:	f64a 0071 	movw	r0, #43121	; 0xa871
 800a87e:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a882:	4619      	mov	r1, r3
 800a884:	f002 f9c0 	bl	800cc08 <__cyg_profile_func_enter>
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800a888:	9b01      	ldr	r3, [sp, #4]
 800a88a:	685b      	ldr	r3, [r3, #4]
 800a88c:	9a01      	ldr	r2, [sp, #4]
 800a88e:	6892      	ldr	r2, [r2, #8]
 800a890:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 800a892:	9b01      	ldr	r3, [sp, #4]
 800a894:	689b      	ldr	r3, [r3, #8]
 800a896:	9a01      	ldr	r2, [sp, #4]
 800a898:	6852      	ldr	r2, [r2, #4]
 800a89a:	605a      	str	r2, [r3, #4]
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 800a89c:	9b01      	ldr	r3, [sp, #4]
 800a89e:	691b      	ldr	r3, [r3, #16]
 800a8a0:	9303      	str	r3, [sp, #12]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 800a8a2:	9b03      	ldr	r3, [sp, #12]
 800a8a4:	685a      	ldr	r2, [r3, #4]
 800a8a6:	9b01      	ldr	r3, [sp, #4]
 800a8a8:	429a      	cmp	r2, r3
 800a8aa:	d103      	bne.n	800a8b4 <vListRemove+0x44>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 800a8ac:	9b01      	ldr	r3, [sp, #4]
 800a8ae:	689a      	ldr	r2, [r3, #8]
 800a8b0:	9b03      	ldr	r3, [sp, #12]
 800a8b2:	605a      	str	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
 800a8b4:	9b01      	ldr	r3, [sp, #4]
 800a8b6:	f04f 0200 	mov.w	r2, #0
 800a8ba:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 800a8bc:	9b03      	ldr	r3, [sp, #12]
 800a8be:	681b      	ldr	r3, [r3, #0]
 800a8c0:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 800a8c4:	9b03      	ldr	r3, [sp, #12]
 800a8c6:	601a      	str	r2, [r3, #0]
 800a8c8:	4623      	mov	r3, r4
 800a8ca:	f64a 0071 	movw	r0, #43121	; 0xa871
 800a8ce:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a8d2:	4619      	mov	r1, r3
 800a8d4:	f002 f9a6 	bl	800cc24 <__cyg_profile_func_exit>
}
 800a8d8:	b004      	add	sp, #16
 800a8da:	bd10      	pop	{r4, pc}

0800a8dc <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
 800a8dc:	b530      	push	{r4, r5, lr}
 800a8de:	b087      	sub	sp, #28
 800a8e0:	4674      	mov	r4, lr
 800a8e2:	9001      	str	r0, [sp, #4]
 800a8e4:	9100      	str	r1, [sp, #0]
 800a8e6:	4623      	mov	r3, r4
 800a8e8:	f64a 00dd 	movw	r0, #43229	; 0xa8dd
 800a8ec:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a8f0:	4619      	mov	r1, r3
 800a8f2:	f002 f989 	bl	800cc08 <__cyg_profile_func_enter>
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
 800a8f6:	f04f 0300 	mov.w	r3, #0
 800a8fa:	9305      	str	r3, [sp, #20]

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 800a8fc:	9b01      	ldr	r3, [sp, #4]
 800a8fe:	2b00      	cmp	r3, #0
 800a900:	d054      	beq.n	800a9ac <xQueueCreate+0xd0>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 800a902:	f04f 004c 	mov.w	r0, #76	; 0x4c
 800a906:	f002 fef5 	bl	800d6f4 <pvPortMalloc>
 800a90a:	9004      	str	r0, [sp, #16]
		if( pxNewQueue != NULL )
 800a90c:	9b04      	ldr	r3, [sp, #16]
 800a90e:	2b00      	cmp	r3, #0
 800a910:	d04c      	beq.n	800a9ac <xQueueCreate+0xd0>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
 800a912:	9b01      	ldr	r3, [sp, #4]
 800a914:	9a00      	ldr	r2, [sp, #0]
 800a916:	fb02 f303 	mul.w	r3, r2, r3
 800a91a:	f103 0301 	add.w	r3, r3, #1
 800a91e:	9303      	str	r3, [sp, #12]

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 800a920:	9803      	ldr	r0, [sp, #12]
 800a922:	f002 fee7 	bl	800d6f4 <pvPortMalloc>
 800a926:	4602      	mov	r2, r0
 800a928:	9b04      	ldr	r3, [sp, #16]
 800a92a:	601a      	str	r2, [r3, #0]
			if( pxNewQueue->pcHead != NULL )
 800a92c:	9b04      	ldr	r3, [sp, #16]
 800a92e:	681b      	ldr	r3, [r3, #0]
 800a930:	2b00      	cmp	r3, #0
 800a932:	d038      	beq.n	800a9a6 <xQueueCreate+0xca>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
 800a934:	9b04      	ldr	r3, [sp, #16]
 800a936:	681a      	ldr	r2, [r3, #0]
 800a938:	9b01      	ldr	r3, [sp, #4]
 800a93a:	9900      	ldr	r1, [sp, #0]
 800a93c:	fb01 f303 	mul.w	r3, r1, r3
 800a940:	18d2      	adds	r2, r2, r3
 800a942:	9b04      	ldr	r3, [sp, #16]
 800a944:	605a      	str	r2, [r3, #4]
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 800a946:	9b04      	ldr	r3, [sp, #16]
 800a948:	f04f 0200 	mov.w	r2, #0
 800a94c:	639a      	str	r2, [r3, #56]	; 0x38
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
 800a94e:	9b04      	ldr	r3, [sp, #16]
 800a950:	681a      	ldr	r2, [r3, #0]
 800a952:	9b04      	ldr	r3, [sp, #16]
 800a954:	609a      	str	r2, [r3, #8]
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
 800a956:	9b04      	ldr	r3, [sp, #16]
 800a958:	681a      	ldr	r2, [r3, #0]
 800a95a:	9b01      	ldr	r3, [sp, #4]
 800a95c:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
 800a960:	9900      	ldr	r1, [sp, #0]
 800a962:	fb01 f303 	mul.w	r3, r1, r3
 800a966:	18d2      	adds	r2, r2, r3
 800a968:	9b04      	ldr	r3, [sp, #16]
 800a96a:	60da      	str	r2, [r3, #12]
				pxNewQueue->uxLength = uxQueueLength;
 800a96c:	9b04      	ldr	r3, [sp, #16]
 800a96e:	9a01      	ldr	r2, [sp, #4]
 800a970:	63da      	str	r2, [r3, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
 800a972:	9b04      	ldr	r3, [sp, #16]
 800a974:	9a00      	ldr	r2, [sp, #0]
 800a976:	641a      	str	r2, [r3, #64]	; 0x40
				pxNewQueue->xRxLock = queueUNLOCKED;
 800a978:	9b04      	ldr	r3, [sp, #16]
 800a97a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800a97e:	645a      	str	r2, [r3, #68]	; 0x44
				pxNewQueue->xTxLock = queueUNLOCKED;
 800a980:	9b04      	ldr	r3, [sp, #16]
 800a982:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800a986:	649a      	str	r2, [r3, #72]	; 0x48

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 800a988:	9b04      	ldr	r3, [sp, #16]
 800a98a:	f103 0310 	add.w	r3, r3, #16
 800a98e:	4618      	mov	r0, r3
 800a990:	f7ff fea8 	bl	800a6e4 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 800a994:	9b04      	ldr	r3, [sp, #16]
 800a996:	f103 0324 	add.w	r3, r3, #36	; 0x24
 800a99a:	4618      	mov	r0, r3
 800a99c:	f7ff fea2 	bl	800a6e4 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
 800a9a0:	9b04      	ldr	r3, [sp, #16]
 800a9a2:	9305      	str	r3, [sp, #20]
 800a9a4:	e002      	b.n	800a9ac <xQueueCreate+0xd0>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
 800a9a6:	9804      	ldr	r0, [sp, #16]
 800a9a8:	f002 fed0 	bl	800d74c <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
 800a9ac:	9d05      	ldr	r5, [sp, #20]
 800a9ae:	4623      	mov	r3, r4
 800a9b0:	f64a 00dd 	movw	r0, #43229	; 0xa8dd
 800a9b4:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a9b8:	4619      	mov	r1, r3
 800a9ba:	f002 f933 	bl	800cc24 <__cyg_profile_func_exit>
 800a9be:	462b      	mov	r3, r5
}
 800a9c0:	4618      	mov	r0, r3
 800a9c2:	b007      	add	sp, #28
 800a9c4:	bd30      	pop	{r4, r5, pc}
 800a9c6:	bf00      	nop

0800a9c8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
 800a9c8:	b530      	push	{r4, r5, lr}
 800a9ca:	b089      	sub	sp, #36	; 0x24
 800a9cc:	4675      	mov	r5, lr
 800a9ce:	9003      	str	r0, [sp, #12]
 800a9d0:	9102      	str	r1, [sp, #8]
 800a9d2:	9201      	str	r2, [sp, #4]
 800a9d4:	9300      	str	r3, [sp, #0]
 800a9d6:	462b      	mov	r3, r5
 800a9d8:	f64a 10c9 	movw	r0, #43465	; 0xa9c9
 800a9dc:	f6c0 0000 	movt	r0, #2048	; 0x800
 800a9e0:	4619      	mov	r1, r3
 800a9e2:	f002 f911 	bl	800cc08 <__cyg_profile_func_enter>
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 800a9e6:	f04f 0300 	mov.w	r3, #0
 800a9ea:	9307      	str	r3, [sp, #28]
 800a9ec:	e000      	b.n	800a9f0 <xQueueGenericSend+0x28>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
 800a9ee:	bf00      	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 800a9f0:	f002 f862 	bl	800cab8 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 800a9f4:	9b03      	ldr	r3, [sp, #12]
 800a9f6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800a9f8:	9b03      	ldr	r3, [sp, #12]
 800a9fa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800a9fc:	429a      	cmp	r2, r3
 800a9fe:	d218      	bcs.n	800aa32 <xQueueGenericSend+0x6a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800aa00:	9803      	ldr	r0, [sp, #12]
 800aa02:	9902      	ldr	r1, [sp, #8]
 800aa04:	9a00      	ldr	r2, [sp, #0]
 800aa06:	f000 f9a1 	bl	800ad4c <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800aa0a:	9b03      	ldr	r3, [sp, #12]
 800aa0c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800aa0e:	2b00      	cmp	r3, #0
 800aa10:	d00a      	beq.n	800aa28 <xQueueGenericSend+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 800aa12:	9b03      	ldr	r3, [sp, #12]
 800aa14:	f103 0324 	add.w	r3, r3, #36	; 0x24
 800aa18:	4618      	mov	r0, r3
 800aa1a:	f000 ffe5 	bl	800b9e8 <xTaskRemoveFromEventList>
 800aa1e:	4603      	mov	r3, r0
 800aa20:	2b01      	cmp	r3, #1
 800aa22:	d101      	bne.n	800aa28 <xQueueGenericSend+0x60>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
 800aa24:	f002 f82e 	bl	800ca84 <vPortYieldFromISR>
					}
				}

				taskEXIT_CRITICAL();
 800aa28:	f002 f86a 	bl	800cb00 <vPortExitCritical>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
 800aa2c:	f04f 0401 	mov.w	r4, #1
 800aa30:	e05a      	b.n	800aae8 <xQueueGenericSend+0x120>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
 800aa32:	9b01      	ldr	r3, [sp, #4]
 800aa34:	2b00      	cmp	r3, #0
 800aa36:	d104      	bne.n	800aa42 <xQueueGenericSend+0x7a>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 800aa38:	f002 f862 	bl	800cb00 <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 800aa3c:	f04f 0400 	mov.w	r4, #0
 800aa40:	e052      	b.n	800aae8 <xQueueGenericSend+0x120>
				}
				else if( xEntryTimeSet == pdFALSE )
 800aa42:	9b07      	ldr	r3, [sp, #28]
 800aa44:	2b00      	cmp	r3, #0
 800aa46:	d106      	bne.n	800aa56 <xQueueGenericSend+0x8e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 800aa48:	ab05      	add	r3, sp, #20
 800aa4a:	4618      	mov	r0, r3
 800aa4c:	f001 f83e 	bl	800bacc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 800aa50:	f04f 0301 	mov.w	r3, #1
 800aa54:	9307      	str	r3, [sp, #28]
				}
			}
		}
		taskEXIT_CRITICAL();
 800aa56:	f002 f853 	bl	800cb00 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 800aa5a:	f000 fc91 	bl	800b380 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800aa5e:	f002 f82b 	bl	800cab8 <vPortEnterCritical>
 800aa62:	9b03      	ldr	r3, [sp, #12]
 800aa64:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800aa66:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800aa6a:	d103      	bne.n	800aa74 <xQueueGenericSend+0xac>
 800aa6c:	9b03      	ldr	r3, [sp, #12]
 800aa6e:	f04f 0200 	mov.w	r2, #0
 800aa72:	645a      	str	r2, [r3, #68]	; 0x44
 800aa74:	9b03      	ldr	r3, [sp, #12]
 800aa76:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800aa78:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800aa7c:	d103      	bne.n	800aa86 <xQueueGenericSend+0xbe>
 800aa7e:	9b03      	ldr	r3, [sp, #12]
 800aa80:	f04f 0200 	mov.w	r2, #0
 800aa84:	649a      	str	r2, [r3, #72]	; 0x48
 800aa86:	f002 f83b 	bl	800cb00 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800aa8a:	aa05      	add	r2, sp, #20
 800aa8c:	ab01      	add	r3, sp, #4
 800aa8e:	4610      	mov	r0, r2
 800aa90:	4619      	mov	r1, r3
 800aa92:	f001 f83f 	bl	800bb14 <xTaskCheckForTimeOut>
 800aa96:	4603      	mov	r3, r0
 800aa98:	2b00      	cmp	r3, #0
 800aa9a:	d11e      	bne.n	800aada <xQueueGenericSend+0x112>
		{
			if( prvIsQueueFull( pxQueue ) )
 800aa9c:	9803      	ldr	r0, [sp, #12]
 800aa9e:	f000 fa7f 	bl	800afa0 <prvIsQueueFull>
 800aaa2:	4603      	mov	r3, r0
 800aaa4:	2b00      	cmp	r3, #0
 800aaa6:	d012      	beq.n	800aace <xQueueGenericSend+0x106>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800aaa8:	9b03      	ldr	r3, [sp, #12]
 800aaaa:	f103 0210 	add.w	r2, r3, #16
 800aaae:	9b01      	ldr	r3, [sp, #4]
 800aab0:	4610      	mov	r0, r2
 800aab2:	4619      	mov	r1, r3
 800aab4:	f000 ff16 	bl	800b8e4 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 800aab8:	9803      	ldr	r0, [sp, #12]
 800aaba:	f000 f9ef 	bl	800ae9c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
 800aabe:	f000 fc7f 	bl	800b3c0 <xTaskResumeAll>
 800aac2:	4603      	mov	r3, r0
 800aac4:	2b00      	cmp	r3, #0
 800aac6:	d192      	bne.n	800a9ee <xQueueGenericSend+0x26>
				{
					portYIELD_WITHIN_API();
 800aac8:	f001 ffdc 	bl	800ca84 <vPortYieldFromISR>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
 800aacc:	e78f      	b.n	800a9ee <xQueueGenericSend+0x26>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 800aace:	9803      	ldr	r0, [sp, #12]
 800aad0:	f000 f9e4 	bl	800ae9c <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800aad4:	f000 fc74 	bl	800b3c0 <xTaskResumeAll>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
 800aad8:	e789      	b.n	800a9ee <xQueueGenericSend+0x26>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 800aada:	9803      	ldr	r0, [sp, #12]
 800aadc:	f000 f9de 	bl	800ae9c <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800aae0:	f000 fc6e 	bl	800b3c0 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 800aae4:	f04f 0400 	mov.w	r4, #0
		}
	}
 800aae8:	462b      	mov	r3, r5
 800aaea:	f64a 10c9 	movw	r0, #43465	; 0xa9c9
 800aaee:	f6c0 0000 	movt	r0, #2048	; 0x800
 800aaf2:	4619      	mov	r1, r3
 800aaf4:	f002 f896 	bl	800cc24 <__cyg_profile_func_exit>
 800aaf8:	4623      	mov	r3, r4
}
 800aafa:	4618      	mov	r0, r3
 800aafc:	b009      	add	sp, #36	; 0x24
 800aafe:	bd30      	pop	{r4, r5, pc}

0800ab00 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
 800ab00:	b530      	push	{r4, r5, lr}
 800ab02:	b087      	sub	sp, #28
 800ab04:	4674      	mov	r4, lr
 800ab06:	9003      	str	r0, [sp, #12]
 800ab08:	9102      	str	r1, [sp, #8]
 800ab0a:	9201      	str	r2, [sp, #4]
 800ab0c:	9300      	str	r3, [sp, #0]
 800ab0e:	4623      	mov	r3, r4
 800ab10:	f64a 3001 	movw	r0, #43777	; 0xab01
 800ab14:	f6c0 0000 	movt	r0, #2048	; 0x800
 800ab18:	4619      	mov	r1, r3
 800ab1a:	f002 f875 	bl	800cc08 <__cyg_profile_func_enter>
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800ab1e:	f04f 0300 	mov.w	r3, #0
 800ab22:	9304      	str	r3, [sp, #16]
 800ab24:	f04f 0030 	mov.w	r0, #48	; 0x30
 800ab28:	f380 8811 	msr	BASEPRI, r0
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 800ab2c:	9b03      	ldr	r3, [sp, #12]
 800ab2e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800ab30:	9b03      	ldr	r3, [sp, #12]
 800ab32:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ab34:	429a      	cmp	r2, r3
 800ab36:	d225      	bcs.n	800ab84 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800ab38:	9803      	ldr	r0, [sp, #12]
 800ab3a:	9902      	ldr	r1, [sp, #8]
 800ab3c:	9a00      	ldr	r2, [sp, #0]
 800ab3e:	f000 f905 	bl	800ad4c <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
 800ab42:	9b03      	ldr	r3, [sp, #12]
 800ab44:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ab46:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800ab4a:	d111      	bne.n	800ab70 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800ab4c:	9b03      	ldr	r3, [sp, #12]
 800ab4e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ab50:	2b00      	cmp	r3, #0
 800ab52:	d013      	beq.n	800ab7c <xQueueGenericSendFromISR+0x7c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800ab54:	9b03      	ldr	r3, [sp, #12]
 800ab56:	f103 0324 	add.w	r3, r3, #36	; 0x24
 800ab5a:	4618      	mov	r0, r3
 800ab5c:	f000 ff44 	bl	800b9e8 <xTaskRemoveFromEventList>
 800ab60:	4603      	mov	r3, r0
 800ab62:	2b00      	cmp	r3, #0
 800ab64:	d00a      	beq.n	800ab7c <xQueueGenericSendFromISR+0x7c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
 800ab66:	9b01      	ldr	r3, [sp, #4]
 800ab68:	f04f 0201 	mov.w	r2, #1
 800ab6c:	601a      	str	r2, [r3, #0]
 800ab6e:	e005      	b.n	800ab7c <xQueueGenericSendFromISR+0x7c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
 800ab70:	9b03      	ldr	r3, [sp, #12]
 800ab72:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ab74:	f103 0201 	add.w	r2, r3, #1
 800ab78:	9b03      	ldr	r3, [sp, #12]
 800ab7a:	649a      	str	r2, [r3, #72]	; 0x48
			}

			xReturn = pdPASS;
 800ab7c:	f04f 0301 	mov.w	r3, #1
 800ab80:	9305      	str	r3, [sp, #20]
 800ab82:	e002      	b.n	800ab8a <xQueueGenericSendFromISR+0x8a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 800ab84:	f04f 0300 	mov.w	r3, #0
 800ab88:	9305      	str	r3, [sp, #20]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 800ab8a:	f04f 0000 	mov.w	r0, #0
 800ab8e:	f380 8811 	msr	BASEPRI, r0

	return xReturn;
 800ab92:	9d05      	ldr	r5, [sp, #20]
 800ab94:	4623      	mov	r3, r4
 800ab96:	f64a 3001 	movw	r0, #43777	; 0xab01
 800ab9a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800ab9e:	4619      	mov	r1, r3
 800aba0:	f002 f840 	bl	800cc24 <__cyg_profile_func_exit>
 800aba4:	462b      	mov	r3, r5
}
 800aba6:	4618      	mov	r0, r3
 800aba8:	b007      	add	sp, #28
 800abaa:	bd30      	pop	{r4, r5, pc}

0800abac <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
 800abac:	b530      	push	{r4, r5, lr}
 800abae:	b089      	sub	sp, #36	; 0x24
 800abb0:	4675      	mov	r5, lr
 800abb2:	9003      	str	r0, [sp, #12]
 800abb4:	9102      	str	r1, [sp, #8]
 800abb6:	9201      	str	r2, [sp, #4]
 800abb8:	9300      	str	r3, [sp, #0]
 800abba:	462b      	mov	r3, r5
 800abbc:	f64a 30ad 	movw	r0, #43949	; 0xabad
 800abc0:	f6c0 0000 	movt	r0, #2048	; 0x800
 800abc4:	4619      	mov	r1, r3
 800abc6:	f002 f81f 	bl	800cc08 <__cyg_profile_func_enter>
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 800abca:	f04f 0300 	mov.w	r3, #0
 800abce:	9307      	str	r3, [sp, #28]
 800abd0:	e000      	b.n	800abd4 <xQueueGenericReceive+0x28>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
 800abd2:	bf00      	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 800abd4:	f001 ff70 	bl	800cab8 <vPortEnterCritical>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 800abd8:	9b03      	ldr	r3, [sp, #12]
 800abda:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800abdc:	2b00      	cmp	r3, #0
 800abde:	d03f      	beq.n	800ac60 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
 800abe0:	9b03      	ldr	r3, [sp, #12]
 800abe2:	68db      	ldr	r3, [r3, #12]
 800abe4:	9306      	str	r3, [sp, #24]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800abe6:	9803      	ldr	r0, [sp, #12]
 800abe8:	9902      	ldr	r1, [sp, #8]
 800abea:	f000 f921 	bl	800ae30 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
 800abee:	9b00      	ldr	r3, [sp, #0]
 800abf0:	2b00      	cmp	r3, #0
 800abf2:	d11e      	bne.n	800ac32 <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
 800abf4:	9b03      	ldr	r3, [sp, #12]
 800abf6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800abf8:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 800abfc:	9b03      	ldr	r3, [sp, #12]
 800abfe:	639a      	str	r2, [r3, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800ac00:	9b03      	ldr	r3, [sp, #12]
 800ac02:	681b      	ldr	r3, [r3, #0]
 800ac04:	2b00      	cmp	r3, #0
 800ac06:	d104      	bne.n	800ac12 <xQueueGenericReceive+0x66>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 800ac08:	f001 f9d0 	bl	800bfac <xTaskGetCurrentTaskHandle>
 800ac0c:	4602      	mov	r2, r0
 800ac0e:	9b03      	ldr	r3, [sp, #12]
 800ac10:	605a      	str	r2, [r3, #4]
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800ac12:	9b03      	ldr	r3, [sp, #12]
 800ac14:	691b      	ldr	r3, [r3, #16]
 800ac16:	2b00      	cmp	r3, #0
 800ac18:	d01d      	beq.n	800ac56 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 800ac1a:	9b03      	ldr	r3, [sp, #12]
 800ac1c:	f103 0310 	add.w	r3, r3, #16
 800ac20:	4618      	mov	r0, r3
 800ac22:	f000 fee1 	bl	800b9e8 <xTaskRemoveFromEventList>
 800ac26:	4603      	mov	r3, r0
 800ac28:	2b01      	cmp	r3, #1
 800ac2a:	d114      	bne.n	800ac56 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
 800ac2c:	f001 ff2a 	bl	800ca84 <vPortYieldFromISR>
 800ac30:	e011      	b.n	800ac56 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
 800ac32:	9b03      	ldr	r3, [sp, #12]
 800ac34:	9a06      	ldr	r2, [sp, #24]
 800ac36:	60da      	str	r2, [r3, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800ac38:	9b03      	ldr	r3, [sp, #12]
 800ac3a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ac3c:	2b00      	cmp	r3, #0
 800ac3e:	d00a      	beq.n	800ac56 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800ac40:	9b03      	ldr	r3, [sp, #12]
 800ac42:	f103 0324 	add.w	r3, r3, #36	; 0x24
 800ac46:	4618      	mov	r0, r3
 800ac48:	f000 fece 	bl	800b9e8 <xTaskRemoveFromEventList>
 800ac4c:	4603      	mov	r3, r0
 800ac4e:	2b00      	cmp	r3, #0
 800ac50:	d001      	beq.n	800ac56 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
 800ac52:	f001 ff17 	bl	800ca84 <vPortYieldFromISR>
						}
					}

				}

				taskEXIT_CRITICAL();
 800ac56:	f001 ff53 	bl	800cb00 <vPortExitCritical>
				return pdPASS;
 800ac5a:	f04f 0401 	mov.w	r4, #1
 800ac5e:	e068      	b.n	800ad32 <xQueueGenericReceive+0x186>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
 800ac60:	9b01      	ldr	r3, [sp, #4]
 800ac62:	2b00      	cmp	r3, #0
 800ac64:	d104      	bne.n	800ac70 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 800ac66:	f001 ff4b 	bl	800cb00 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 800ac6a:	f04f 0400 	mov.w	r4, #0
 800ac6e:	e060      	b.n	800ad32 <xQueueGenericReceive+0x186>
				}
				else if( xEntryTimeSet == pdFALSE )
 800ac70:	9b07      	ldr	r3, [sp, #28]
 800ac72:	2b00      	cmp	r3, #0
 800ac74:	d106      	bne.n	800ac84 <xQueueGenericReceive+0xd8>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 800ac76:	ab04      	add	r3, sp, #16
 800ac78:	4618      	mov	r0, r3
 800ac7a:	f000 ff27 	bl	800bacc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 800ac7e:	f04f 0301 	mov.w	r3, #1
 800ac82:	9307      	str	r3, [sp, #28]
				}
			}
		}
		taskEXIT_CRITICAL();
 800ac84:	f001 ff3c 	bl	800cb00 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 800ac88:	f000 fb7a 	bl	800b380 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800ac8c:	f001 ff14 	bl	800cab8 <vPortEnterCritical>
 800ac90:	9b03      	ldr	r3, [sp, #12]
 800ac92:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ac94:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800ac98:	d103      	bne.n	800aca2 <xQueueGenericReceive+0xf6>
 800ac9a:	9b03      	ldr	r3, [sp, #12]
 800ac9c:	f04f 0200 	mov.w	r2, #0
 800aca0:	645a      	str	r2, [r3, #68]	; 0x44
 800aca2:	9b03      	ldr	r3, [sp, #12]
 800aca4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800aca6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800acaa:	d103      	bne.n	800acb4 <xQueueGenericReceive+0x108>
 800acac:	9b03      	ldr	r3, [sp, #12]
 800acae:	f04f 0200 	mov.w	r2, #0
 800acb2:	649a      	str	r2, [r3, #72]	; 0x48
 800acb4:	f001 ff24 	bl	800cb00 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800acb8:	aa04      	add	r2, sp, #16
 800acba:	ab01      	add	r3, sp, #4
 800acbc:	4610      	mov	r0, r2
 800acbe:	4619      	mov	r1, r3
 800acc0:	f000 ff28 	bl	800bb14 <xTaskCheckForTimeOut>
 800acc4:	4603      	mov	r3, r0
 800acc6:	2b00      	cmp	r3, #0
 800acc8:	d12c      	bne.n	800ad24 <xQueueGenericReceive+0x178>
		{
			if( prvIsQueueEmpty( pxQueue ) )
 800acca:	9803      	ldr	r0, [sp, #12]
 800accc:	f000 f944 	bl	800af58 <prvIsQueueEmpty>
 800acd0:	4603      	mov	r3, r0
 800acd2:	2b00      	cmp	r3, #0
 800acd4:	d020      	beq.n	800ad18 <xQueueGenericReceive+0x16c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800acd6:	9b03      	ldr	r3, [sp, #12]
 800acd8:	681b      	ldr	r3, [r3, #0]
 800acda:	2b00      	cmp	r3, #0
 800acdc:	d108      	bne.n	800acf0 <xQueueGenericReceive+0x144>
					{
						portENTER_CRITICAL();
 800acde:	f001 feeb 	bl	800cab8 <vPortEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 800ace2:	9b03      	ldr	r3, [sp, #12]
 800ace4:	685b      	ldr	r3, [r3, #4]
 800ace6:	4618      	mov	r0, r3
 800ace8:	f001 f9b0 	bl	800c04c <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
 800acec:	f001 ff08 	bl	800cb00 <vPortExitCritical>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 800acf0:	9b03      	ldr	r3, [sp, #12]
 800acf2:	f103 0224 	add.w	r2, r3, #36	; 0x24
 800acf6:	9b01      	ldr	r3, [sp, #4]
 800acf8:	4610      	mov	r0, r2
 800acfa:	4619      	mov	r1, r3
 800acfc:	f000 fdf2 	bl	800b8e4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800ad00:	9803      	ldr	r0, [sp, #12]
 800ad02:	f000 f8cb 	bl	800ae9c <prvUnlockQueue>
				if( !xTaskResumeAll() )
 800ad06:	f000 fb5b 	bl	800b3c0 <xTaskResumeAll>
 800ad0a:	4603      	mov	r3, r0
 800ad0c:	2b00      	cmp	r3, #0
 800ad0e:	f47f af60 	bne.w	800abd2 <xQueueGenericReceive+0x26>
				{
					portYIELD_WITHIN_API();
 800ad12:	f001 feb7 	bl	800ca84 <vPortYieldFromISR>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
 800ad16:	e75c      	b.n	800abd2 <xQueueGenericReceive+0x26>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 800ad18:	9803      	ldr	r0, [sp, #12]
 800ad1a:	f000 f8bf 	bl	800ae9c <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800ad1e:	f000 fb4f 	bl	800b3c0 <xTaskResumeAll>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
 800ad22:	e756      	b.n	800abd2 <xQueueGenericReceive+0x26>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
 800ad24:	9803      	ldr	r0, [sp, #12]
 800ad26:	f000 f8b9 	bl	800ae9c <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800ad2a:	f000 fb49 	bl	800b3c0 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
 800ad2e:	f04f 0400 	mov.w	r4, #0
		}
	}
 800ad32:	462b      	mov	r3, r5
 800ad34:	f64a 30ad 	movw	r0, #43949	; 0xabad
 800ad38:	f6c0 0000 	movt	r0, #2048	; 0x800
 800ad3c:	4619      	mov	r1, r3
 800ad3e:	f001 ff71 	bl	800cc24 <__cyg_profile_func_exit>
 800ad42:	4623      	mov	r3, r4
}
 800ad44:	4618      	mov	r0, r3
 800ad46:	b009      	add	sp, #36	; 0x24
 800ad48:	bd30      	pop	{r4, r5, pc}
 800ad4a:	bf00      	nop

0800ad4c <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
 800ad4c:	b510      	push	{r4, lr}
 800ad4e:	b084      	sub	sp, #16
 800ad50:	4674      	mov	r4, lr
 800ad52:	9003      	str	r0, [sp, #12]
 800ad54:	9102      	str	r1, [sp, #8]
 800ad56:	9201      	str	r2, [sp, #4]
 800ad58:	4623      	mov	r3, r4
 800ad5a:	f64a 504d 	movw	r0, #44365	; 0xad4d
 800ad5e:	f6c0 0000 	movt	r0, #2048	; 0x800
 800ad62:	4619      	mov	r1, r3
 800ad64:	f001 ff50 	bl	800cc08 <__cyg_profile_func_enter>
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 800ad68:	9b03      	ldr	r3, [sp, #12]
 800ad6a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ad6c:	2b00      	cmp	r3, #0
 800ad6e:	d10d      	bne.n	800ad8c <prvCopyDataToQueue+0x40>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800ad70:	9b03      	ldr	r3, [sp, #12]
 800ad72:	681b      	ldr	r3, [r3, #0]
 800ad74:	2b00      	cmp	r3, #0
 800ad76:	d14a      	bne.n	800ae0e <prvCopyDataToQueue+0xc2>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 800ad78:	9b03      	ldr	r3, [sp, #12]
 800ad7a:	685b      	ldr	r3, [r3, #4]
 800ad7c:	4618      	mov	r0, r3
 800ad7e:	f001 f9df 	bl	800c140 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 800ad82:	9b03      	ldr	r3, [sp, #12]
 800ad84:	f04f 0200 	mov.w	r2, #0
 800ad88:	605a      	str	r2, [r3, #4]
 800ad8a:	e040      	b.n	800ae0e <prvCopyDataToQueue+0xc2>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
 800ad8c:	9b01      	ldr	r3, [sp, #4]
 800ad8e:	2b00      	cmp	r3, #0
 800ad90:	d11b      	bne.n	800adca <prvCopyDataToQueue+0x7e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 800ad92:	9b03      	ldr	r3, [sp, #12]
 800ad94:	6899      	ldr	r1, [r3, #8]
 800ad96:	9b03      	ldr	r3, [sp, #12]
 800ad98:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ad9a:	9a02      	ldr	r2, [sp, #8]
 800ad9c:	4608      	mov	r0, r1
 800ad9e:	4611      	mov	r1, r2
 800ada0:	461a      	mov	r2, r3
 800ada2:	f002 fd59 	bl	800d858 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800ada6:	9b03      	ldr	r3, [sp, #12]
 800ada8:	689a      	ldr	r2, [r3, #8]
 800adaa:	9b03      	ldr	r3, [sp, #12]
 800adac:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800adae:	18d2      	adds	r2, r2, r3
 800adb0:	9b03      	ldr	r3, [sp, #12]
 800adb2:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 800adb4:	9b03      	ldr	r3, [sp, #12]
 800adb6:	689a      	ldr	r2, [r3, #8]
 800adb8:	9b03      	ldr	r3, [sp, #12]
 800adba:	685b      	ldr	r3, [r3, #4]
 800adbc:	429a      	cmp	r2, r3
 800adbe:	d326      	bcc.n	800ae0e <prvCopyDataToQueue+0xc2>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 800adc0:	9b03      	ldr	r3, [sp, #12]
 800adc2:	681a      	ldr	r2, [r3, #0]
 800adc4:	9b03      	ldr	r3, [sp, #12]
 800adc6:	609a      	str	r2, [r3, #8]
 800adc8:	e021      	b.n	800ae0e <prvCopyDataToQueue+0xc2>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 800adca:	9b03      	ldr	r3, [sp, #12]
 800adcc:	68d9      	ldr	r1, [r3, #12]
 800adce:	9b03      	ldr	r3, [sp, #12]
 800add0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800add2:	9a02      	ldr	r2, [sp, #8]
 800add4:	4608      	mov	r0, r1
 800add6:	4611      	mov	r1, r2
 800add8:	461a      	mov	r2, r3
 800adda:	f002 fd3d 	bl	800d858 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 800adde:	9b03      	ldr	r3, [sp, #12]
 800ade0:	68da      	ldr	r2, [r3, #12]
 800ade2:	9b03      	ldr	r3, [sp, #12]
 800ade4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ade6:	f1c3 0300 	rsb	r3, r3, #0
 800adea:	18d2      	adds	r2, r2, r3
 800adec:	9b03      	ldr	r3, [sp, #12]
 800adee:	60da      	str	r2, [r3, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 800adf0:	9b03      	ldr	r3, [sp, #12]
 800adf2:	68da      	ldr	r2, [r3, #12]
 800adf4:	9b03      	ldr	r3, [sp, #12]
 800adf6:	681b      	ldr	r3, [r3, #0]
 800adf8:	429a      	cmp	r2, r3
 800adfa:	d208      	bcs.n	800ae0e <prvCopyDataToQueue+0xc2>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 800adfc:	9b03      	ldr	r3, [sp, #12]
 800adfe:	685a      	ldr	r2, [r3, #4]
 800ae00:	9b03      	ldr	r3, [sp, #12]
 800ae02:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ae04:	f1c3 0300 	rsb	r3, r3, #0
 800ae08:	18d2      	adds	r2, r2, r3
 800ae0a:	9b03      	ldr	r3, [sp, #12]
 800ae0c:	60da      	str	r2, [r3, #12]
		}
	}

	++( pxQueue->uxMessagesWaiting );
 800ae0e:	9b03      	ldr	r3, [sp, #12]
 800ae10:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ae12:	f103 0201 	add.w	r2, r3, #1
 800ae16:	9b03      	ldr	r3, [sp, #12]
 800ae18:	639a      	str	r2, [r3, #56]	; 0x38
 800ae1a:	4623      	mov	r3, r4
 800ae1c:	f64a 504d 	movw	r0, #44365	; 0xad4d
 800ae20:	f6c0 0000 	movt	r0, #2048	; 0x800
 800ae24:	4619      	mov	r1, r3
 800ae26:	f001 fefd 	bl	800cc24 <__cyg_profile_func_exit>
}
 800ae2a:	b004      	add	sp, #16
 800ae2c:	bd10      	pop	{r4, pc}
 800ae2e:	bf00      	nop

0800ae30 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
 800ae30:	b510      	push	{r4, lr}
 800ae32:	b082      	sub	sp, #8
 800ae34:	4674      	mov	r4, lr
 800ae36:	9001      	str	r0, [sp, #4]
 800ae38:	9100      	str	r1, [sp, #0]
 800ae3a:	4623      	mov	r3, r4
 800ae3c:	f64a 6031 	movw	r0, #44593	; 0xae31
 800ae40:	f6c0 0000 	movt	r0, #2048	; 0x800
 800ae44:	4619      	mov	r1, r3
 800ae46:	f001 fedf 	bl	800cc08 <__cyg_profile_func_enter>
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 800ae4a:	9b01      	ldr	r3, [sp, #4]
 800ae4c:	681b      	ldr	r3, [r3, #0]
 800ae4e:	2b00      	cmp	r3, #0
 800ae50:	d01a      	beq.n	800ae88 <prvCopyDataFromQueue+0x58>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 800ae52:	9b01      	ldr	r3, [sp, #4]
 800ae54:	68da      	ldr	r2, [r3, #12]
 800ae56:	9b01      	ldr	r3, [sp, #4]
 800ae58:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ae5a:	18d2      	adds	r2, r2, r3
 800ae5c:	9b01      	ldr	r3, [sp, #4]
 800ae5e:	60da      	str	r2, [r3, #12]
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 800ae60:	9b01      	ldr	r3, [sp, #4]
 800ae62:	68da      	ldr	r2, [r3, #12]
 800ae64:	9b01      	ldr	r3, [sp, #4]
 800ae66:	685b      	ldr	r3, [r3, #4]
 800ae68:	429a      	cmp	r2, r3
 800ae6a:	d303      	bcc.n	800ae74 <prvCopyDataFromQueue+0x44>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
 800ae6c:	9b01      	ldr	r3, [sp, #4]
 800ae6e:	681a      	ldr	r2, [r3, #0]
 800ae70:	9b01      	ldr	r3, [sp, #4]
 800ae72:	60da      	str	r2, [r3, #12]
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 800ae74:	9b01      	ldr	r3, [sp, #4]
 800ae76:	68da      	ldr	r2, [r3, #12]
 800ae78:	9b01      	ldr	r3, [sp, #4]
 800ae7a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ae7c:	9900      	ldr	r1, [sp, #0]
 800ae7e:	4608      	mov	r0, r1
 800ae80:	4611      	mov	r1, r2
 800ae82:	461a      	mov	r2, r3
 800ae84:	f002 fce8 	bl	800d858 <memcpy>
 800ae88:	4623      	mov	r3, r4
 800ae8a:	f64a 6031 	movw	r0, #44593	; 0xae31
 800ae8e:	f6c0 0000 	movt	r0, #2048	; 0x800
 800ae92:	4619      	mov	r1, r3
 800ae94:	f001 fec6 	bl	800cc24 <__cyg_profile_func_exit>
	}
}
 800ae98:	b002      	add	sp, #8
 800ae9a:	bd10      	pop	{r4, pc}

0800ae9c <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
 800ae9c:	b510      	push	{r4, lr}
 800ae9e:	b082      	sub	sp, #8
 800aea0:	4674      	mov	r4, lr
 800aea2:	9001      	str	r0, [sp, #4]
 800aea4:	4623      	mov	r3, r4
 800aea6:	f64a 609d 	movw	r0, #44701	; 0xae9d
 800aeaa:	f6c0 0000 	movt	r0, #2048	; 0x800
 800aeae:	4619      	mov	r1, r3
 800aeb0:	f001 feaa 	bl	800cc08 <__cyg_profile_func_enter>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 800aeb4:	f001 fe00 	bl	800cab8 <vPortEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 800aeb8:	e014      	b.n	800aee4 <prvUnlockQueue+0x48>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800aeba:	9b01      	ldr	r3, [sp, #4]
 800aebc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800aebe:	2b00      	cmp	r3, #0
 800aec0:	d015      	beq.n	800aeee <prvUnlockQueue+0x52>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800aec2:	9b01      	ldr	r3, [sp, #4]
 800aec4:	f103 0324 	add.w	r3, r3, #36	; 0x24
 800aec8:	4618      	mov	r0, r3
 800aeca:	f000 fd8d 	bl	800b9e8 <xTaskRemoveFromEventList>
 800aece:	4603      	mov	r3, r0
 800aed0:	2b00      	cmp	r3, #0
 800aed2:	d001      	beq.n	800aed8 <prvUnlockQueue+0x3c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
 800aed4:	f000 fe7e 	bl	800bbd4 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
 800aed8:	9b01      	ldr	r3, [sp, #4]
 800aeda:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800aedc:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 800aee0:	9b01      	ldr	r3, [sp, #4]
 800aee2:	649a      	str	r2, [r3, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 800aee4:	9b01      	ldr	r3, [sp, #4]
 800aee6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800aee8:	2b00      	cmp	r3, #0
 800aeea:	dce6      	bgt.n	800aeba <prvUnlockQueue+0x1e>
 800aeec:	e000      	b.n	800aef0 <prvUnlockQueue+0x54>

				--( pxQueue->xTxLock );
			}
			else
			{
				break;
 800aeee:	bf00      	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
 800aef0:	9b01      	ldr	r3, [sp, #4]
 800aef2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800aef6:	649a      	str	r2, [r3, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
 800aef8:	f001 fe02 	bl	800cb00 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 800aefc:	f001 fddc 	bl	800cab8 <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 800af00:	e014      	b.n	800af2c <prvUnlockQueue+0x90>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800af02:	9b01      	ldr	r3, [sp, #4]
 800af04:	691b      	ldr	r3, [r3, #16]
 800af06:	2b00      	cmp	r3, #0
 800af08:	d015      	beq.n	800af36 <prvUnlockQueue+0x9a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800af0a:	9b01      	ldr	r3, [sp, #4]
 800af0c:	f103 0310 	add.w	r3, r3, #16
 800af10:	4618      	mov	r0, r3
 800af12:	f000 fd69 	bl	800b9e8 <xTaskRemoveFromEventList>
 800af16:	4603      	mov	r3, r0
 800af18:	2b00      	cmp	r3, #0
 800af1a:	d001      	beq.n	800af20 <prvUnlockQueue+0x84>
				{
					vTaskMissedYield();
 800af1c:	f000 fe5a 	bl	800bbd4 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
 800af20:	9b01      	ldr	r3, [sp, #4]
 800af22:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800af24:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 800af28:	9b01      	ldr	r3, [sp, #4]
 800af2a:	645a      	str	r2, [r3, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 800af2c:	9b01      	ldr	r3, [sp, #4]
 800af2e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800af30:	2b00      	cmp	r3, #0
 800af32:	dce6      	bgt.n	800af02 <prvUnlockQueue+0x66>
 800af34:	e000      	b.n	800af38 <prvUnlockQueue+0x9c>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
 800af36:	bf00      	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 800af38:	9b01      	ldr	r3, [sp, #4]
 800af3a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800af3e:	645a      	str	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
 800af40:	f001 fdde 	bl	800cb00 <vPortExitCritical>
 800af44:	4623      	mov	r3, r4
 800af46:	f64a 609d 	movw	r0, #44701	; 0xae9d
 800af4a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800af4e:	4619      	mov	r1, r3
 800af50:	f001 fe68 	bl	800cc24 <__cyg_profile_func_exit>
}
 800af54:	b002      	add	sp, #8
 800af56:	bd10      	pop	{r4, pc}

0800af58 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
 800af58:	b530      	push	{r4, r5, lr}
 800af5a:	b085      	sub	sp, #20
 800af5c:	4674      	mov	r4, lr
 800af5e:	9001      	str	r0, [sp, #4]
 800af60:	4623      	mov	r3, r4
 800af62:	f64a 7059 	movw	r0, #44889	; 0xaf59
 800af66:	f6c0 0000 	movt	r0, #2048	; 0x800
 800af6a:	4619      	mov	r1, r3
 800af6c:	f001 fe4c 	bl	800cc08 <__cyg_profile_func_enter>
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 800af70:	f001 fda2 	bl	800cab8 <vPortEnterCritical>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 800af74:	9b01      	ldr	r3, [sp, #4]
 800af76:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800af78:	2b00      	cmp	r3, #0
 800af7a:	bf14      	ite	ne
 800af7c:	2300      	movne	r3, #0
 800af7e:	2301      	moveq	r3, #1
 800af80:	9303      	str	r3, [sp, #12]
	taskEXIT_CRITICAL();
 800af82:	f001 fdbd 	bl	800cb00 <vPortExitCritical>

	return xReturn;
 800af86:	9d03      	ldr	r5, [sp, #12]
 800af88:	4623      	mov	r3, r4
 800af8a:	f64a 7059 	movw	r0, #44889	; 0xaf59
 800af8e:	f6c0 0000 	movt	r0, #2048	; 0x800
 800af92:	4619      	mov	r1, r3
 800af94:	f001 fe46 	bl	800cc24 <__cyg_profile_func_exit>
 800af98:	462b      	mov	r3, r5
}
 800af9a:	4618      	mov	r0, r3
 800af9c:	b005      	add	sp, #20
 800af9e:	bd30      	pop	{r4, r5, pc}

0800afa0 <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
 800afa0:	b530      	push	{r4, r5, lr}
 800afa2:	b085      	sub	sp, #20
 800afa4:	4674      	mov	r4, lr
 800afa6:	9001      	str	r0, [sp, #4]
 800afa8:	4623      	mov	r3, r4
 800afaa:	f64a 70a1 	movw	r0, #44961	; 0xafa1
 800afae:	f6c0 0000 	movt	r0, #2048	; 0x800
 800afb2:	4619      	mov	r1, r3
 800afb4:	f001 fe28 	bl	800cc08 <__cyg_profile_func_enter>
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 800afb8:	f001 fd7e 	bl	800cab8 <vPortEnterCritical>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 800afbc:	9b01      	ldr	r3, [sp, #4]
 800afbe:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800afc0:	9b01      	ldr	r3, [sp, #4]
 800afc2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800afc4:	429a      	cmp	r2, r3
 800afc6:	bf14      	ite	ne
 800afc8:	2300      	movne	r3, #0
 800afca:	2301      	moveq	r3, #1
 800afcc:	9303      	str	r3, [sp, #12]
	taskEXIT_CRITICAL();
 800afce:	f001 fd97 	bl	800cb00 <vPortExitCritical>

	return xReturn;
 800afd2:	9d03      	ldr	r5, [sp, #12]
 800afd4:	4623      	mov	r3, r4
 800afd6:	f64a 70a1 	movw	r0, #44961	; 0xafa1
 800afda:	f6c0 0000 	movt	r0, #2048	; 0x800
 800afde:	4619      	mov	r1, r3
 800afe0:	f001 fe20 	bl	800cc24 <__cyg_profile_func_exit>
 800afe4:	462b      	mov	r3, r5
}
 800afe6:	4618      	mov	r0, r3
 800afe8:	b005      	add	sp, #20
 800afea:	bd30      	pop	{r4, r5, pc}

0800afec <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
	{
 800afec:	b510      	push	{r4, lr}
 800afee:	b082      	sub	sp, #8
 800aff0:	4674      	mov	r4, lr
 800aff2:	9001      	str	r0, [sp, #4]
 800aff4:	9100      	str	r1, [sp, #0]
 800aff6:	4623      	mov	r3, r4
 800aff8:	f64a 70ed 	movw	r0, #45037	; 0xafed
 800affc:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b000:	4619      	mov	r1, r3
 800b002:	f001 fe01 	bl	800cc08 <__cyg_profile_func_enter>
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 800b006:	f001 fd57 	bl	800cab8 <vPortEnterCritical>
 800b00a:	9b01      	ldr	r3, [sp, #4]
 800b00c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800b00e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800b012:	d103      	bne.n	800b01c <vQueueWaitForMessageRestricted+0x30>
 800b014:	9b01      	ldr	r3, [sp, #4]
 800b016:	f04f 0200 	mov.w	r2, #0
 800b01a:	645a      	str	r2, [r3, #68]	; 0x44
 800b01c:	9b01      	ldr	r3, [sp, #4]
 800b01e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800b020:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800b024:	d103      	bne.n	800b02e <vQueueWaitForMessageRestricted+0x42>
 800b026:	9b01      	ldr	r3, [sp, #4]
 800b028:	f04f 0200 	mov.w	r2, #0
 800b02c:	649a      	str	r2, [r3, #72]	; 0x48
 800b02e:	f001 fd67 	bl	800cb00 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
 800b032:	9b01      	ldr	r3, [sp, #4]
 800b034:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b036:	2b00      	cmp	r3, #0
 800b038:	d106      	bne.n	800b048 <vQueueWaitForMessageRestricted+0x5c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 800b03a:	9b01      	ldr	r3, [sp, #4]
 800b03c:	f103 0324 	add.w	r3, r3, #36	; 0x24
 800b040:	4618      	mov	r0, r3
 800b042:	9900      	ldr	r1, [sp, #0]
 800b044:	f000 fc98 	bl	800b978 <vTaskPlaceOnEventListRestricted>
		}
		prvUnlockQueue( pxQueue );
 800b048:	9801      	ldr	r0, [sp, #4]
 800b04a:	f7ff ff27 	bl	800ae9c <prvUnlockQueue>
 800b04e:	4623      	mov	r3, r4
 800b050:	f64a 70ed 	movw	r0, #45037	; 0xafed
 800b054:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b058:	4619      	mov	r1, r3
 800b05a:	f001 fde3 	bl	800cc24 <__cyg_profile_func_exit>
	}
 800b05e:	b002      	add	sp, #8
 800b060:	bd10      	pop	{r4, pc}
 800b062:	bf00      	nop

0800b064 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 800b064:	b530      	push	{r4, r5, lr}
 800b066:	b08b      	sub	sp, #44	; 0x2c
 800b068:	4674      	mov	r4, lr
 800b06a:	9005      	str	r0, [sp, #20]
 800b06c:	9104      	str	r1, [sp, #16]
 800b06e:	9302      	str	r3, [sp, #8]
 800b070:	4613      	mov	r3, r2
 800b072:	f8ad 300e 	strh.w	r3, [sp, #14]
 800b076:	4623      	mov	r3, r4
 800b078:	f24b 0065 	movw	r0, #45157	; 0xb065
 800b07c:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b080:	4619      	mov	r1, r3
 800b082:	f001 fdc1 	bl	800cc08 <__cyg_profile_func_enter>
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 800b086:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 800b08a:	4618      	mov	r0, r3
 800b08c:	9910      	ldr	r1, [sp, #64]	; 0x40
 800b08e:	f000 ff25 	bl	800bedc <prvAllocateTCBAndStack>
 800b092:	9008      	str	r0, [sp, #32]

	if( pxNewTCB != NULL )
 800b094:	9b08      	ldr	r3, [sp, #32]
 800b096:	2b00      	cmp	r3, #0
 800b098:	f000 80aa 	beq.w	800b1f0 <xTaskGenericCreate+0x18c>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 800b09c:	9b08      	ldr	r3, [sp, #32]
 800b09e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800b0a0:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 800b0a4:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
 800b0a8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b0ac:	18d3      	adds	r3, r2, r3
 800b0ae:	9307      	str	r3, [sp, #28]
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
 800b0b0:	9b07      	ldr	r3, [sp, #28]
 800b0b2:	f023 0307 	bic.w	r3, r3, #7
 800b0b6:	9307      	str	r3, [sp, #28]
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 800b0b8:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 800b0bc:	9300      	str	r3, [sp, #0]
 800b0be:	9808      	ldr	r0, [sp, #32]
 800b0c0:	9904      	ldr	r1, [sp, #16]
 800b0c2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800b0c4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800b0c6:	f000 fdaf 	bl	800bc28 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pvParameters );
 800b0ca:	9b08      	ldr	r3, [sp, #32]
 800b0cc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b0ce:	9807      	ldr	r0, [sp, #28]
 800b0d0:	4619      	mov	r1, r3
 800b0d2:	9a05      	ldr	r2, [sp, #20]
 800b0d4:	9b02      	ldr	r3, [sp, #8]
 800b0d6:	f001 fbe5 	bl	800c8a4 <pxPortInitialiseStack>
 800b0da:	4602      	mov	r2, r0
 800b0dc:	9b08      	ldr	r3, [sp, #32]
 800b0de:	601a      	str	r2, [r3, #0]
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
 800b0e0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800b0e2:	2b00      	cmp	r3, #0
 800b0e4:	d002      	beq.n	800b0ec <xTaskGenericCreate+0x88>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 800b0e6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800b0e8:	9a08      	ldr	r2, [sp, #32]
 800b0ea:	601a      	str	r2, [r3, #0]
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
 800b0ec:	f001 fce4 	bl	800cab8 <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 800b0f0:	f240 533c 	movw	r3, #1340	; 0x53c
 800b0f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b0f8:	681b      	ldr	r3, [r3, #0]
 800b0fa:	f103 0201 	add.w	r2, r3, #1
 800b0fe:	f240 533c 	movw	r3, #1340	; 0x53c
 800b102:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b106:	601a      	str	r2, [r3, #0]
			if( pxCurrentTCB == NULL )
 800b108:	f240 4364 	movw	r3, #1124	; 0x464
 800b10c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b110:	681b      	ldr	r3, [r3, #0]
 800b112:	2b00      	cmp	r3, #0
 800b114:	d10f      	bne.n	800b136 <xTaskGenericCreate+0xd2>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 800b116:	f240 4364 	movw	r3, #1124	; 0x464
 800b11a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b11e:	9a08      	ldr	r2, [sp, #32]
 800b120:	601a      	str	r2, [r3, #0]

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 800b122:	f240 533c 	movw	r3, #1340	; 0x53c
 800b126:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b12a:	681b      	ldr	r3, [r3, #0]
 800b12c:	2b01      	cmp	r3, #1
 800b12e:	d118      	bne.n	800b162 <xTaskGenericCreate+0xfe>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
 800b130:	f000 fdc8 	bl	800bcc4 <prvInitialiseTaskLists>
 800b134:	e015      	b.n	800b162 <xTaskGenericCreate+0xfe>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 800b136:	f240 534c 	movw	r3, #1356	; 0x54c
 800b13a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b13e:	681b      	ldr	r3, [r3, #0]
 800b140:	2b00      	cmp	r3, #0
 800b142:	d10e      	bne.n	800b162 <xTaskGenericCreate+0xfe>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 800b144:	f240 4364 	movw	r3, #1124	; 0x464
 800b148:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b14c:	681b      	ldr	r3, [r3, #0]
 800b14e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b150:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b152:	429a      	cmp	r2, r3
 800b154:	d805      	bhi.n	800b162 <xTaskGenericCreate+0xfe>
					{
						pxCurrentTCB = pxNewTCB;
 800b156:	f240 4364 	movw	r3, #1124	; 0x464
 800b15a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b15e:	9a08      	ldr	r2, [sp, #32]
 800b160:	601a      	str	r2, [r3, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 800b162:	9b08      	ldr	r3, [sp, #32]
 800b164:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b166:	f240 5344 	movw	r3, #1348	; 0x544
 800b16a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b16e:	681b      	ldr	r3, [r3, #0]
 800b170:	429a      	cmp	r2, r3
 800b172:	d906      	bls.n	800b182 <xTaskGenericCreate+0x11e>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
 800b174:	9b08      	ldr	r3, [sp, #32]
 800b176:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b178:	f240 5344 	movw	r3, #1348	; 0x544
 800b17c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b180:	601a      	str	r2, [r3, #0]
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
 800b182:	f240 5360 	movw	r3, #1376	; 0x560
 800b186:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b18a:	681b      	ldr	r3, [r3, #0]
 800b18c:	f103 0201 	add.w	r2, r3, #1
 800b190:	f240 5360 	movw	r3, #1376	; 0x560
 800b194:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b198:	601a      	str	r2, [r3, #0]

			prvAddTaskToReadyQueue( pxNewTCB );
 800b19a:	9b08      	ldr	r3, [sp, #32]
 800b19c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b19e:	f240 5348 	movw	r3, #1352	; 0x548
 800b1a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b1a6:	681b      	ldr	r3, [r3, #0]
 800b1a8:	429a      	cmp	r2, r3
 800b1aa:	d906      	bls.n	800b1ba <xTaskGenericCreate+0x156>
 800b1ac:	9b08      	ldr	r3, [sp, #32]
 800b1ae:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b1b0:	f240 5348 	movw	r3, #1352	; 0x548
 800b1b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b1b8:	601a      	str	r2, [r3, #0]
 800b1ba:	9b08      	ldr	r3, [sp, #32]
 800b1bc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b1be:	4613      	mov	r3, r2
 800b1c0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b1c4:	189b      	adds	r3, r3, r2
 800b1c6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b1ca:	461a      	mov	r2, r3
 800b1cc:	f240 4368 	movw	r3, #1128	; 0x468
 800b1d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b1d4:	18d2      	adds	r2, r2, r3
 800b1d6:	9b08      	ldr	r3, [sp, #32]
 800b1d8:	f103 0304 	add.w	r3, r3, #4
 800b1dc:	4610      	mov	r0, r2
 800b1de:	4619      	mov	r1, r3
 800b1e0:	f7ff fac8 	bl	800a774 <vListInsertEnd>

			xReturn = pdPASS;
 800b1e4:	f04f 0301 	mov.w	r3, #1
 800b1e8:	9309      	str	r3, [sp, #36]	; 0x24
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 800b1ea:	f001 fc89 	bl	800cb00 <vPortExitCritical>
 800b1ee:	e002      	b.n	800b1f6 <xTaskGenericCreate+0x192>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 800b1f0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800b1f4:	9309      	str	r3, [sp, #36]	; 0x24
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
 800b1f6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800b1f8:	2b01      	cmp	r3, #1
 800b1fa:	d111      	bne.n	800b220 <xTaskGenericCreate+0x1bc>
	{
		if( xSchedulerRunning != pdFALSE )
 800b1fc:	f240 534c 	movw	r3, #1356	; 0x54c
 800b200:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b204:	681b      	ldr	r3, [r3, #0]
 800b206:	2b00      	cmp	r3, #0
 800b208:	d00a      	beq.n	800b220 <xTaskGenericCreate+0x1bc>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 800b20a:	f240 4364 	movw	r3, #1124	; 0x464
 800b20e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b212:	681b      	ldr	r3, [r3, #0]
 800b214:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b216:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b218:	429a      	cmp	r2, r3
 800b21a:	d201      	bcs.n	800b220 <xTaskGenericCreate+0x1bc>
			{
				portYIELD_WITHIN_API();
 800b21c:	f001 fc32 	bl	800ca84 <vPortYieldFromISR>
			}
		}
	}

	return xReturn;
 800b220:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800b222:	4623      	mov	r3, r4
 800b224:	f24b 0065 	movw	r0, #45157	; 0xb065
 800b228:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b22c:	4619      	mov	r1, r3
 800b22e:	f001 fcf9 	bl	800cc24 <__cyg_profile_func_exit>
 800b232:	462b      	mov	r3, r5
}
 800b234:	4618      	mov	r0, r3
 800b236:	b00b      	add	sp, #44	; 0x2c
 800b238:	bd30      	pop	{r4, r5, pc}
 800b23a:	bf00      	nop

0800b23c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 800b23c:	b510      	push	{r4, lr}
 800b23e:	b084      	sub	sp, #16
 800b240:	4674      	mov	r4, lr
 800b242:	9001      	str	r0, [sp, #4]
 800b244:	4623      	mov	r3, r4
 800b246:	f24b 203d 	movw	r0, #45629	; 0xb23d
 800b24a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b24e:	4619      	mov	r1, r3
 800b250:	f001 fcda 	bl	800cc08 <__cyg_profile_func_enter>
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 800b254:	f04f 0300 	mov.w	r3, #0
 800b258:	9303      	str	r3, [sp, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
 800b25a:	9b01      	ldr	r3, [sp, #4]
 800b25c:	2b00      	cmp	r3, #0
 800b25e:	d019      	beq.n	800b294 <vTaskDelay+0x58>
		{
			vTaskSuspendAll();
 800b260:	f000 f88e 	bl	800b380 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 800b264:	f240 5340 	movw	r3, #1344	; 0x540
 800b268:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b26c:	681a      	ldr	r2, [r3, #0]
 800b26e:	9b01      	ldr	r3, [sp, #4]
 800b270:	18d3      	adds	r3, r2, r3
 800b272:	9302      	str	r3, [sp, #8]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 800b274:	f240 4364 	movw	r3, #1124	; 0x464
 800b278:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b27c:	681b      	ldr	r3, [r3, #0]
 800b27e:	f103 0304 	add.w	r3, r3, #4
 800b282:	4618      	mov	r0, r3
 800b284:	f7ff faf4 	bl	800a870 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 800b288:	9802      	ldr	r0, [sp, #8]
 800b28a:	f000 fdd3 	bl	800be34 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 800b28e:	f000 f897 	bl	800b3c0 <xTaskResumeAll>
 800b292:	9003      	str	r0, [sp, #12]
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
 800b294:	9b03      	ldr	r3, [sp, #12]
 800b296:	2b00      	cmp	r3, #0
 800b298:	d101      	bne.n	800b29e <vTaskDelay+0x62>
		{
			portYIELD_WITHIN_API();
 800b29a:	f001 fbf3 	bl	800ca84 <vPortYieldFromISR>
 800b29e:	4623      	mov	r3, r4
 800b2a0:	f24b 203d 	movw	r0, #45629	; 0xb23d
 800b2a4:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b2a8:	4619      	mov	r1, r3
 800b2aa:	f001 fcbb 	bl	800cc24 <__cyg_profile_func_exit>
		}
	}
 800b2ae:	b004      	add	sp, #16
 800b2b0:	bd10      	pop	{r4, pc}
 800b2b2:	bf00      	nop

0800b2b4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
 800b2b4:	b510      	push	{r4, lr}
 800b2b6:	b086      	sub	sp, #24
 800b2b8:	4674      	mov	r4, lr
 800b2ba:	4623      	mov	r3, r4
 800b2bc:	f24b 20b5 	movw	r0, #45749	; 0xb2b5
 800b2c0:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b2c4:	4619      	mov	r1, r3
 800b2c6:	f001 fc9f 	bl	800cc08 <__cyg_profile_func_enter>
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
 800b2ca:	f04f 0300 	mov.w	r3, #0
 800b2ce:	9300      	str	r3, [sp, #0]
 800b2d0:	f04f 0300 	mov.w	r3, #0
 800b2d4:	9301      	str	r3, [sp, #4]
 800b2d6:	f04f 0300 	mov.w	r3, #0
 800b2da:	9302      	str	r3, [sp, #8]
 800b2dc:	f04f 0300 	mov.w	r3, #0
 800b2e0:	9303      	str	r3, [sp, #12]
 800b2e2:	f64b 4009 	movw	r0, #48137	; 0xbc09
 800b2e6:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b2ea:	f64d 21c0 	movw	r1, #56000	; 0xdac0
 800b2ee:	f6c0 0100 	movt	r1, #2048	; 0x800
 800b2f2:	f44f 7200 	mov.w	r2, #512	; 0x200
 800b2f6:	f04f 0300 	mov.w	r3, #0
 800b2fa:	f7ff feb3 	bl	800b064 <xTaskGenericCreate>
 800b2fe:	9005      	str	r0, [sp, #20]

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
 800b300:	9b05      	ldr	r3, [sp, #20]
 800b302:	2b01      	cmp	r3, #1
 800b304:	d102      	bne.n	800b30c <vTaskStartScheduler+0x58>
		{
			xReturn = xTimerCreateTimerTask();
 800b306:	f000 ff71 	bl	800c1ec <xTimerCreateTimerTask>
 800b30a:	9005      	str	r0, [sp, #20]
		}
	}
	#endif

	if( xReturn == pdPASS )
 800b30c:	9b05      	ldr	r3, [sp, #20]
 800b30e:	2b01      	cmp	r3, #1
 800b310:	d12b      	bne.n	800b36a <vTaskStartScheduler+0xb6>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
 800b312:	f04f 0030 	mov.w	r0, #48	; 0x30
 800b316:	f380 8811 	msr	BASEPRI, r0

		xSchedulerRunning = pdTRUE;
 800b31a:	f240 534c 	movw	r3, #1356	; 0x54c
 800b31e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b322:	f04f 0201 	mov.w	r2, #1
 800b326:	601a      	str	r2, [r3, #0]
		xTickCount = ( portTickType ) 0;
 800b328:	f240 5340 	movw	r3, #1344	; 0x540
 800b32c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b330:	f04f 0200 	mov.w	r2, #0
 800b334:	601a      	str	r2, [r3, #0]

		/* If configGENERATE_RUN_TIME_STATS is defined then the following
		macro must be defined to configure the timer/counter used to generate
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
 800b336:	f64e 53fc 	movw	r3, #60924	; 0xedfc
 800b33a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800b33e:	f64e 52fc 	movw	r2, #60924	; 0xedfc
 800b342:	f2ce 0200 	movt	r2, #57344	; 0xe000
 800b346:	6812      	ldr	r2, [r2, #0]
 800b348:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800b34c:	601a      	str	r2, [r3, #0]
 800b34e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800b352:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800b356:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800b35a:	f2ce 0200 	movt	r2, #57344	; 0xe000
 800b35e:	6812      	ldr	r2, [r2, #0]
 800b360:	f042 0201 	orr.w	r2, r2, #1
 800b364:	601a      	str	r2, [r3, #0]
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
 800b366:	f001 fb53 	bl	800ca10 <xPortStartScheduler>
 800b36a:	4623      	mov	r3, r4
 800b36c:	f24b 20b5 	movw	r0, #45749	; 0xb2b5
 800b370:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b374:	4619      	mov	r1, r3
 800b376:	f001 fc55 	bl	800cc24 <__cyg_profile_func_exit>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
 800b37a:	b006      	add	sp, #24
 800b37c:	bd10      	pop	{r4, pc}
 800b37e:	bf00      	nop

0800b380 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 800b380:	b510      	push	{r4, lr}
 800b382:	4674      	mov	r4, lr
 800b384:	4623      	mov	r3, r4
 800b386:	f24b 3081 	movw	r0, #45953	; 0xb381
 800b38a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b38e:	4619      	mov	r1, r3
 800b390:	f001 fc3a 	bl	800cc08 <__cyg_profile_func_enter>
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 800b394:	f240 5350 	movw	r3, #1360	; 0x550
 800b398:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b39c:	681b      	ldr	r3, [r3, #0]
 800b39e:	f103 0201 	add.w	r2, r3, #1
 800b3a2:	f240 5350 	movw	r3, #1360	; 0x550
 800b3a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b3aa:	601a      	str	r2, [r3, #0]
 800b3ac:	4623      	mov	r3, r4
 800b3ae:	f24b 3081 	movw	r0, #45953	; 0xb381
 800b3b2:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b3b6:	4619      	mov	r1, r3
 800b3b8:	f001 fc34 	bl	800cc24 <__cyg_profile_func_exit>
}
 800b3bc:	bd10      	pop	{r4, pc}
 800b3be:	bf00      	nop

0800b3c0 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 800b3c0:	b530      	push	{r4, r5, lr}
 800b3c2:	b083      	sub	sp, #12
 800b3c4:	4675      	mov	r5, lr
 800b3c6:	462b      	mov	r3, r5
 800b3c8:	f24b 30c1 	movw	r0, #46017	; 0xb3c1
 800b3cc:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b3d0:	4619      	mov	r1, r3
 800b3d2:	f001 fc19 	bl	800cc08 <__cyg_profile_func_enter>
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 800b3d6:	f04f 0300 	mov.w	r3, #0
 800b3da:	9301      	str	r3, [sp, #4]
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 800b3dc:	f001 fb6c 	bl	800cab8 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 800b3e0:	f240 5350 	movw	r3, #1360	; 0x550
 800b3e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b3e8:	681b      	ldr	r3, [r3, #0]
 800b3ea:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 800b3ee:	f240 5350 	movw	r3, #1360	; 0x550
 800b3f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b3f6:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 800b3f8:	f240 5350 	movw	r3, #1360	; 0x550
 800b3fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b400:	681b      	ldr	r3, [r3, #0]
 800b402:	2b00      	cmp	r3, #0
 800b404:	f040 8085 	bne.w	800b512 <xTaskResumeAll+0x152>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
 800b408:	f240 533c 	movw	r3, #1340	; 0x53c
 800b40c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b410:	681b      	ldr	r3, [r3, #0]
 800b412:	2b00      	cmp	r3, #0
 800b414:	d07d      	beq.n	800b512 <xTaskResumeAll+0x152>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
 800b416:	f04f 0300 	mov.w	r3, #0
 800b41a:	9300      	str	r3, [sp, #0]

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 800b41c:	e03c      	b.n	800b498 <xTaskResumeAll+0xd8>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 800b41e:	f240 43fc 	movw	r3, #1276	; 0x4fc
 800b422:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b426:	68db      	ldr	r3, [r3, #12]
 800b428:	68dc      	ldr	r4, [r3, #12]
					vListRemove( &( pxTCB->xEventListItem ) );
 800b42a:	f104 0318 	add.w	r3, r4, #24
 800b42e:	4618      	mov	r0, r3
 800b430:	f7ff fa1e 	bl	800a870 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
 800b434:	f104 0304 	add.w	r3, r4, #4
 800b438:	4618      	mov	r0, r3
 800b43a:	f7ff fa19 	bl	800a870 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 800b43e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800b440:	f240 5348 	movw	r3, #1352	; 0x548
 800b444:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b448:	681b      	ldr	r3, [r3, #0]
 800b44a:	429a      	cmp	r2, r3
 800b44c:	d905      	bls.n	800b45a <xTaskResumeAll+0x9a>
 800b44e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800b450:	f240 5348 	movw	r3, #1352	; 0x548
 800b454:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b458:	601a      	str	r2, [r3, #0]
 800b45a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800b45c:	4613      	mov	r3, r2
 800b45e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b462:	189b      	adds	r3, r3, r2
 800b464:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b468:	461a      	mov	r2, r3
 800b46a:	f240 4368 	movw	r3, #1128	; 0x468
 800b46e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b472:	18d2      	adds	r2, r2, r3
 800b474:	f104 0304 	add.w	r3, r4, #4
 800b478:	4610      	mov	r0, r2
 800b47a:	4619      	mov	r1, r3
 800b47c:	f7ff f97a 	bl	800a774 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800b480:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800b482:	f240 4364 	movw	r3, #1124	; 0x464
 800b486:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b48a:	681b      	ldr	r3, [r3, #0]
 800b48c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b48e:	429a      	cmp	r2, r3
 800b490:	d302      	bcc.n	800b498 <xTaskResumeAll+0xd8>
					{
						xYieldRequired = pdTRUE;
 800b492:	f04f 0301 	mov.w	r3, #1
 800b496:	9300      	str	r3, [sp, #0]
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 800b498:	f240 43fc 	movw	r3, #1276	; 0x4fc
 800b49c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b4a0:	681b      	ldr	r3, [r3, #0]
 800b4a2:	2b00      	cmp	r3, #0
 800b4a4:	d1bb      	bne.n	800b41e <xTaskResumeAll+0x5e>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 800b4a6:	f240 5354 	movw	r3, #1364	; 0x554
 800b4aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b4ae:	681b      	ldr	r3, [r3, #0]
 800b4b0:	2b00      	cmp	r3, #0
 800b4b2:	d018      	beq.n	800b4e6 <xTaskResumeAll+0x126>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 800b4b4:	e00d      	b.n	800b4d2 <xTaskResumeAll+0x112>
					{
						vTaskIncrementTick();
 800b4b6:	f000 f85d 	bl	800b574 <vTaskIncrementTick>
						--uxMissedTicks;
 800b4ba:	f240 5354 	movw	r3, #1364	; 0x554
 800b4be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b4c2:	681b      	ldr	r3, [r3, #0]
 800b4c4:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 800b4c8:	f240 5354 	movw	r3, #1364	; 0x554
 800b4cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b4d0:	601a      	str	r2, [r3, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 800b4d2:	f240 5354 	movw	r3, #1364	; 0x554
 800b4d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b4da:	681b      	ldr	r3, [r3, #0]
 800b4dc:	2b00      	cmp	r3, #0
 800b4de:	d1ea      	bne.n	800b4b6 <xTaskResumeAll+0xf6>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
 800b4e0:	f04f 0301 	mov.w	r3, #1
 800b4e4:	9300      	str	r3, [sp, #0]
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 800b4e6:	9b00      	ldr	r3, [sp, #0]
 800b4e8:	2b01      	cmp	r3, #1
 800b4ea:	d006      	beq.n	800b4fa <xTaskResumeAll+0x13a>
 800b4ec:	f240 5358 	movw	r3, #1368	; 0x558
 800b4f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b4f4:	681b      	ldr	r3, [r3, #0]
 800b4f6:	2b01      	cmp	r3, #1
 800b4f8:	d10b      	bne.n	800b512 <xTaskResumeAll+0x152>
				{
					xAlreadyYielded = pdTRUE;
 800b4fa:	f04f 0301 	mov.w	r3, #1
 800b4fe:	9301      	str	r3, [sp, #4]
					xMissedYield = pdFALSE;
 800b500:	f240 5358 	movw	r3, #1368	; 0x558
 800b504:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b508:	f04f 0200 	mov.w	r2, #0
 800b50c:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
 800b50e:	f001 fab9 	bl	800ca84 <vPortYieldFromISR>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
 800b512:	f001 faf5 	bl	800cb00 <vPortExitCritical>

	return xAlreadyYielded;
 800b516:	9c01      	ldr	r4, [sp, #4]
 800b518:	462b      	mov	r3, r5
 800b51a:	f24b 30c1 	movw	r0, #46017	; 0xb3c1
 800b51e:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b522:	4619      	mov	r1, r3
 800b524:	f001 fb7e 	bl	800cc24 <__cyg_profile_func_exit>
 800b528:	4623      	mov	r3, r4
}
 800b52a:	4618      	mov	r0, r3
 800b52c:	b003      	add	sp, #12
 800b52e:	bd30      	pop	{r4, r5, pc}

0800b530 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
 800b530:	b530      	push	{r4, r5, lr}
 800b532:	b083      	sub	sp, #12
 800b534:	4674      	mov	r4, lr
 800b536:	4623      	mov	r3, r4
 800b538:	f24b 5031 	movw	r0, #46385	; 0xb531
 800b53c:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b540:	4619      	mov	r1, r3
 800b542:	f001 fb61 	bl	800cc08 <__cyg_profile_func_enter>
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
 800b546:	f001 fab7 	bl	800cab8 <vPortEnterCritical>
	{
		xTicks = xTickCount;
 800b54a:	f240 5340 	movw	r3, #1344	; 0x540
 800b54e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b552:	681b      	ldr	r3, [r3, #0]
 800b554:	9301      	str	r3, [sp, #4]
	}
	taskEXIT_CRITICAL();
 800b556:	f001 fad3 	bl	800cb00 <vPortExitCritical>

	return xTicks;
 800b55a:	9d01      	ldr	r5, [sp, #4]
 800b55c:	4623      	mov	r3, r4
 800b55e:	f24b 5031 	movw	r0, #46385	; 0xb531
 800b562:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b566:	4619      	mov	r1, r3
 800b568:	f001 fb5c 	bl	800cc24 <__cyg_profile_func_exit>
 800b56c:	462b      	mov	r3, r5
}
 800b56e:	4618      	mov	r0, r3
 800b570:	b003      	add	sp, #12
 800b572:	bd30      	pop	{r4, r5, pc}

0800b574 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
 800b574:	b510      	push	{r4, lr}
 800b576:	b084      	sub	sp, #16
 800b578:	4674      	mov	r4, lr
 800b57a:	4623      	mov	r3, r4
 800b57c:	f24b 5075 	movw	r0, #46453	; 0xb575
 800b580:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b584:	4619      	mov	r1, r3
 800b586:	f001 fb3f 	bl	800cc08 <__cyg_profile_func_enter>
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 800b58a:	f240 5350 	movw	r3, #1360	; 0x550
 800b58e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b592:	681b      	ldr	r3, [r3, #0]
 800b594:	2b00      	cmp	r3, #0
 800b596:	f040 80c0 	bne.w	800b71a <vTaskIncrementTick+0x1a6>
	{
		++xTickCount;
 800b59a:	f240 5340 	movw	r3, #1344	; 0x540
 800b59e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b5a2:	681b      	ldr	r3, [r3, #0]
 800b5a4:	f103 0201 	add.w	r2, r3, #1
 800b5a8:	f240 5340 	movw	r3, #1344	; 0x540
 800b5ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b5b0:	601a      	str	r2, [r3, #0]
		if( xTickCount == ( portTickType ) 0 )
 800b5b2:	f240 5340 	movw	r3, #1344	; 0x540
 800b5b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b5ba:	681b      	ldr	r3, [r3, #0]
 800b5bc:	2b00      	cmp	r3, #0
 800b5be:	d140      	bne.n	800b642 <vTaskIncrementTick+0xce>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
 800b5c0:	f240 43f4 	movw	r3, #1268	; 0x4f4
 800b5c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b5c8:	681b      	ldr	r3, [r3, #0]
 800b5ca:	9303      	str	r3, [sp, #12]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 800b5cc:	f240 43f8 	movw	r3, #1272	; 0x4f8
 800b5d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b5d4:	681a      	ldr	r2, [r3, #0]
 800b5d6:	f240 43f4 	movw	r3, #1268	; 0x4f4
 800b5da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b5de:	601a      	str	r2, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
 800b5e0:	f240 43f8 	movw	r3, #1272	; 0x4f8
 800b5e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b5e8:	9a03      	ldr	r2, [sp, #12]
 800b5ea:	601a      	str	r2, [r3, #0]
			xNumOfOverflows++;
 800b5ec:	f240 535c 	movw	r3, #1372	; 0x55c
 800b5f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b5f4:	681b      	ldr	r3, [r3, #0]
 800b5f6:	f103 0201 	add.w	r2, r3, #1
 800b5fa:	f240 535c 	movw	r3, #1372	; 0x55c
 800b5fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b602:	601a      	str	r2, [r3, #0]
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800b604:	f240 43f4 	movw	r3, #1268	; 0x4f4
 800b608:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b60c:	681b      	ldr	r3, [r3, #0]
 800b60e:	681b      	ldr	r3, [r3, #0]
 800b610:	2b00      	cmp	r3, #0
 800b612:	d107      	bne.n	800b624 <vTaskIncrementTick+0xb0>
				/* The new current delayed list is empty.  Set 
				xNextTaskUnblockTime to the maximum possible value so it is 
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until 
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
 800b614:	f240 4330 	movw	r3, #1072	; 0x430
 800b618:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b61c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800b620:	601a      	str	r2, [r3, #0]
 800b622:	e00e      	b.n	800b642 <vTaskIncrementTick+0xce>
			{
				/* The new current delayed list is not empty, get the value of 
				the item at the head of the delayed list.  This is the time at 
				which the task at the head of the delayed list should be removed 
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800b624:	f240 43f4 	movw	r3, #1268	; 0x4f4
 800b628:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b62c:	681b      	ldr	r3, [r3, #0]
 800b62e:	68db      	ldr	r3, [r3, #12]
 800b630:	68db      	ldr	r3, [r3, #12]
 800b632:	9302      	str	r3, [sp, #8]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 800b634:	9b02      	ldr	r3, [sp, #8]
 800b636:	685a      	ldr	r2, [r3, #4]
 800b638:	f240 4330 	movw	r3, #1072	; 0x430
 800b63c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b640:	601a      	str	r2, [r3, #0]
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
 800b642:	f240 5340 	movw	r3, #1344	; 0x540
 800b646:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b64a:	681a      	ldr	r2, [r3, #0]
 800b64c:	f240 4330 	movw	r3, #1072	; 0x430
 800b650:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b654:	681b      	ldr	r3, [r3, #0]
 800b656:	429a      	cmp	r2, r3
 800b658:	d36b      	bcc.n	800b732 <vTaskIncrementTick+0x1be>
 800b65a:	f240 43f4 	movw	r3, #1268	; 0x4f4
 800b65e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b662:	681b      	ldr	r3, [r3, #0]
 800b664:	681b      	ldr	r3, [r3, #0]
 800b666:	2b00      	cmp	r3, #0
 800b668:	d107      	bne.n	800b67a <vTaskIncrementTick+0x106>
 800b66a:	f240 4330 	movw	r3, #1072	; 0x430
 800b66e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b672:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800b676:	601a      	str	r2, [r3, #0]
 800b678:	e05b      	b.n	800b732 <vTaskIncrementTick+0x1be>
 800b67a:	f240 43f4 	movw	r3, #1268	; 0x4f4
 800b67e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b682:	681b      	ldr	r3, [r3, #0]
 800b684:	68db      	ldr	r3, [r3, #12]
 800b686:	68db      	ldr	r3, [r3, #12]
 800b688:	9302      	str	r3, [sp, #8]
 800b68a:	9b02      	ldr	r3, [sp, #8]
 800b68c:	685b      	ldr	r3, [r3, #4]
 800b68e:	9301      	str	r3, [sp, #4]
 800b690:	f240 5340 	movw	r3, #1344	; 0x540
 800b694:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b698:	681a      	ldr	r2, [r3, #0]
 800b69a:	9b01      	ldr	r3, [sp, #4]
 800b69c:	429a      	cmp	r2, r3
 800b69e:	d206      	bcs.n	800b6ae <vTaskIncrementTick+0x13a>
 800b6a0:	f240 4330 	movw	r3, #1072	; 0x430
 800b6a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b6a8:	9a01      	ldr	r2, [sp, #4]
 800b6aa:	601a      	str	r2, [r3, #0]
 800b6ac:	e041      	b.n	800b732 <vTaskIncrementTick+0x1be>
 800b6ae:	9b02      	ldr	r3, [sp, #8]
 800b6b0:	f103 0304 	add.w	r3, r3, #4
 800b6b4:	4618      	mov	r0, r3
 800b6b6:	f7ff f8db 	bl	800a870 <vListRemove>
 800b6ba:	9b02      	ldr	r3, [sp, #8]
 800b6bc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b6be:	2b00      	cmp	r3, #0
 800b6c0:	d005      	beq.n	800b6ce <vTaskIncrementTick+0x15a>
 800b6c2:	9b02      	ldr	r3, [sp, #8]
 800b6c4:	f103 0318 	add.w	r3, r3, #24
 800b6c8:	4618      	mov	r0, r3
 800b6ca:	f7ff f8d1 	bl	800a870 <vListRemove>
 800b6ce:	9b02      	ldr	r3, [sp, #8]
 800b6d0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b6d2:	f240 5348 	movw	r3, #1352	; 0x548
 800b6d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b6da:	681b      	ldr	r3, [r3, #0]
 800b6dc:	429a      	cmp	r2, r3
 800b6de:	d906      	bls.n	800b6ee <vTaskIncrementTick+0x17a>
 800b6e0:	9b02      	ldr	r3, [sp, #8]
 800b6e2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b6e4:	f240 5348 	movw	r3, #1352	; 0x548
 800b6e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b6ec:	601a      	str	r2, [r3, #0]
 800b6ee:	9b02      	ldr	r3, [sp, #8]
 800b6f0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b6f2:	4613      	mov	r3, r2
 800b6f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b6f8:	189b      	adds	r3, r3, r2
 800b6fa:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b6fe:	461a      	mov	r2, r3
 800b700:	f240 4368 	movw	r3, #1128	; 0x468
 800b704:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b708:	18d2      	adds	r2, r2, r3
 800b70a:	9b02      	ldr	r3, [sp, #8]
 800b70c:	f103 0304 	add.w	r3, r3, #4
 800b710:	4610      	mov	r0, r2
 800b712:	4619      	mov	r1, r3
 800b714:	f7ff f82e 	bl	800a774 <vListInsertEnd>
 800b718:	e79f      	b.n	800b65a <vTaskIncrementTick+0xe6>
	}
	else
	{
		++uxMissedTicks;
 800b71a:	f240 5354 	movw	r3, #1364	; 0x554
 800b71e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b722:	681b      	ldr	r3, [r3, #0]
 800b724:	f103 0201 	add.w	r2, r3, #1
 800b728:	f240 5354 	movw	r3, #1364	; 0x554
 800b72c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b730:	601a      	str	r2, [r3, #0]
 800b732:	4623      	mov	r3, r4
 800b734:	f24b 5075 	movw	r0, #46453	; 0xb575
 800b738:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b73c:	4619      	mov	r1, r3
 800b73e:	f001 fa71 	bl	800cc24 <__cyg_profile_func_exit>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
 800b742:	b004      	add	sp, #16
 800b744:	bd10      	pop	{r4, pc}
 800b746:	bf00      	nop

0800b748 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 800b748:	b510      	push	{r4, lr}
 800b74a:	b082      	sub	sp, #8
 800b74c:	4674      	mov	r4, lr
 800b74e:	4623      	mov	r3, r4
 800b750:	f24b 7049 	movw	r0, #46921	; 0xb749
 800b754:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b758:	4619      	mov	r1, r3
 800b75a:	f001 fa55 	bl	800cc08 <__cyg_profile_func_enter>
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 800b75e:	f240 5350 	movw	r3, #1360	; 0x550
 800b762:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b766:	681b      	ldr	r3, [r3, #0]
 800b768:	2b00      	cmp	r3, #0
 800b76a:	d007      	beq.n	800b77c <vTaskSwitchContext+0x34>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 800b76c:	f240 5358 	movw	r3, #1368	; 0x558
 800b770:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b774:	f04f 0201 	mov.w	r2, #1
 800b778:	601a      	str	r2, [r3, #0]
 800b77a:	e0a8      	b.n	800b8ce <vTaskSwitchContext+0x186>
			unsigned long ulTempCounter;
			
				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
				#else
					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
 800b77c:	f241 0304 	movw	r3, #4100	; 0x1004
 800b780:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800b784:	681b      	ldr	r3, [r3, #0]
 800b786:	9301      	str	r3, [sp, #4]
				/* Add the amount of time the task has been running to the accumulated
				time so far.  The time the task started running was stored in
				ulTaskSwitchedInTime.  Note that there is no overflow protection here
				so count values are only valid until the timer overflows.  Generally
				this will be about 1 hour assuming a 1uS timer increment. */
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
 800b788:	f240 4364 	movw	r3, #1124	; 0x464
 800b78c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b790:	681a      	ldr	r2, [r3, #0]
 800b792:	6c91      	ldr	r1, [r2, #72]	; 0x48
 800b794:	f240 5364 	movw	r3, #1380	; 0x564
 800b798:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b79c:	681b      	ldr	r3, [r3, #0]
 800b79e:	9801      	ldr	r0, [sp, #4]
 800b7a0:	1ac3      	subs	r3, r0, r3
 800b7a2:	18cb      	adds	r3, r1, r3
 800b7a4:	6493      	str	r3, [r2, #72]	; 0x48
				ulTaskSwitchedInTime = ulTempCounter;
 800b7a6:	f240 5364 	movw	r3, #1380	; 0x564
 800b7aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b7ae:	9a01      	ldr	r2, [sp, #4]
 800b7b0:	601a      	str	r2, [r3, #0]
		}
		#endif
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 800b7b2:	f240 4364 	movw	r3, #1124	; 0x464
 800b7b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b7ba:	681b      	ldr	r3, [r3, #0]
 800b7bc:	681a      	ldr	r2, [r3, #0]
 800b7be:	f240 4364 	movw	r3, #1124	; 0x464
 800b7c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b7c6:	681b      	ldr	r3, [r3, #0]
 800b7c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b7ca:	429a      	cmp	r2, r3
 800b7cc:	d80f      	bhi.n	800b7ee <vTaskSwitchContext+0xa6>
 800b7ce:	f240 4364 	movw	r3, #1124	; 0x464
 800b7d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b7d6:	681a      	ldr	r2, [r3, #0]
 800b7d8:	f240 4364 	movw	r3, #1124	; 0x464
 800b7dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b7e0:	681b      	ldr	r3, [r3, #0]
 800b7e2:	f103 0334 	add.w	r3, r3, #52	; 0x34
 800b7e6:	4610      	mov	r0, r2
 800b7e8:	4619      	mov	r1, r3
 800b7ea:	f7fc fccb 	bl	8008184 <vApplicationStackOverflowHook>
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
 800b7ee:	f240 4364 	movw	r3, #1124	; 0x464
 800b7f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b7f6:	681b      	ldr	r3, [r3, #0]
 800b7f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b7fa:	4618      	mov	r0, r3
 800b7fc:	f64d 21fc 	movw	r1, #56060	; 0xdafc
 800b800:	f6c0 0100 	movt	r1, #2048	; 0x800
 800b804:	f04f 0214 	mov.w	r2, #20
 800b808:	f001 fff6 	bl	800d7f8 <memcmp>
 800b80c:	4603      	mov	r3, r0
 800b80e:	2b00      	cmp	r3, #0
 800b810:	d01d      	beq.n	800b84e <vTaskSwitchContext+0x106>
 800b812:	f240 4364 	movw	r3, #1124	; 0x464
 800b816:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b81a:	681a      	ldr	r2, [r3, #0]
 800b81c:	f240 4364 	movw	r3, #1124	; 0x464
 800b820:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b824:	681b      	ldr	r3, [r3, #0]
 800b826:	f103 0334 	add.w	r3, r3, #52	; 0x34
 800b82a:	4610      	mov	r0, r2
 800b82c:	4619      	mov	r1, r3
 800b82e:	f7fc fca9 	bl	8008184 <vApplicationStackOverflowHook>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 800b832:	e00c      	b.n	800b84e <vTaskSwitchContext+0x106>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
 800b834:	f240 5348 	movw	r3, #1352	; 0x548
 800b838:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b83c:	681b      	ldr	r3, [r3, #0]
 800b83e:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 800b842:	f240 5348 	movw	r3, #1352	; 0x548
 800b846:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b84a:	601a      	str	r2, [r3, #0]
 800b84c:	e000      	b.n	800b850 <vTaskSwitchContext+0x108>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 800b84e:	bf00      	nop
 800b850:	f240 5348 	movw	r3, #1352	; 0x548
 800b854:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b858:	681a      	ldr	r2, [r3, #0]
 800b85a:	4613      	mov	r3, r2
 800b85c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b860:	189b      	adds	r3, r3, r2
 800b862:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b866:	461a      	mov	r2, r3
 800b868:	f240 4368 	movw	r3, #1128	; 0x468
 800b86c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b870:	18d3      	adds	r3, r2, r3
 800b872:	681b      	ldr	r3, [r3, #0]
 800b874:	2b00      	cmp	r3, #0
 800b876:	d0dd      	beq.n	800b834 <vTaskSwitchContext+0xec>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 800b878:	f240 5348 	movw	r3, #1352	; 0x548
 800b87c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b880:	681a      	ldr	r2, [r3, #0]
 800b882:	4613      	mov	r3, r2
 800b884:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b888:	189b      	adds	r3, r3, r2
 800b88a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b88e:	461a      	mov	r2, r3
 800b890:	f240 4368 	movw	r3, #1128	; 0x468
 800b894:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b898:	18d3      	adds	r3, r2, r3
 800b89a:	9300      	str	r3, [sp, #0]
 800b89c:	9b00      	ldr	r3, [sp, #0]
 800b89e:	685b      	ldr	r3, [r3, #4]
 800b8a0:	685a      	ldr	r2, [r3, #4]
 800b8a2:	9b00      	ldr	r3, [sp, #0]
 800b8a4:	605a      	str	r2, [r3, #4]
 800b8a6:	9b00      	ldr	r3, [sp, #0]
 800b8a8:	685a      	ldr	r2, [r3, #4]
 800b8aa:	9b00      	ldr	r3, [sp, #0]
 800b8ac:	f103 0308 	add.w	r3, r3, #8
 800b8b0:	429a      	cmp	r2, r3
 800b8b2:	d104      	bne.n	800b8be <vTaskSwitchContext+0x176>
 800b8b4:	9b00      	ldr	r3, [sp, #0]
 800b8b6:	685b      	ldr	r3, [r3, #4]
 800b8b8:	685a      	ldr	r2, [r3, #4]
 800b8ba:	9b00      	ldr	r3, [sp, #0]
 800b8bc:	605a      	str	r2, [r3, #4]
 800b8be:	9b00      	ldr	r3, [sp, #0]
 800b8c0:	685b      	ldr	r3, [r3, #4]
 800b8c2:	68da      	ldr	r2, [r3, #12]
 800b8c4:	f240 4364 	movw	r3, #1124	; 0x464
 800b8c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b8cc:	601a      	str	r2, [r3, #0]
 800b8ce:	4623      	mov	r3, r4
 800b8d0:	f24b 7049 	movw	r0, #46921	; 0xb749
 800b8d4:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b8d8:	4619      	mov	r1, r3
 800b8da:	f001 f9a3 	bl	800cc24 <__cyg_profile_func_exit>
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
 800b8de:	b002      	add	sp, #8
 800b8e0:	bd10      	pop	{r4, pc}
 800b8e2:	bf00      	nop

0800b8e4 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
 800b8e4:	b510      	push	{r4, lr}
 800b8e6:	b084      	sub	sp, #16
 800b8e8:	4674      	mov	r4, lr
 800b8ea:	9001      	str	r0, [sp, #4]
 800b8ec:	9100      	str	r1, [sp, #0]
 800b8ee:	4623      	mov	r3, r4
 800b8f0:	f64b 00e5 	movw	r0, #47333	; 0xb8e5
 800b8f4:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b8f8:	4619      	mov	r1, r3
 800b8fa:	f001 f985 	bl	800cc08 <__cyg_profile_func_enter>
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 800b8fe:	f240 4364 	movw	r3, #1124	; 0x464
 800b902:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b906:	681b      	ldr	r3, [r3, #0]
 800b908:	f103 0318 	add.w	r3, r3, #24
 800b90c:	9801      	ldr	r0, [sp, #4]
 800b90e:	4619      	mov	r1, r3
 800b910:	f7fe ff66 	bl	800a7e0 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 800b914:	f240 4364 	movw	r3, #1124	; 0x464
 800b918:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b91c:	681b      	ldr	r3, [r3, #0]
 800b91e:	f103 0304 	add.w	r3, r3, #4
 800b922:	4618      	mov	r0, r3
 800b924:	f7fe ffa4 	bl	800a870 <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
 800b928:	9b00      	ldr	r3, [sp, #0]
 800b92a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800b92e:	d10e      	bne.n	800b94e <vTaskPlaceOnEventList+0x6a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 800b930:	f240 4364 	movw	r3, #1124	; 0x464
 800b934:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b938:	681b      	ldr	r3, [r3, #0]
 800b93a:	f103 0304 	add.w	r3, r3, #4
 800b93e:	f240 5028 	movw	r0, #1320	; 0x528
 800b942:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800b946:	4619      	mov	r1, r3
 800b948:	f7fe ff14 	bl	800a774 <vListInsertEnd>
 800b94c:	e00a      	b.n	800b964 <vTaskPlaceOnEventList+0x80>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
 800b94e:	f240 5340 	movw	r3, #1344	; 0x540
 800b952:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b956:	681a      	ldr	r2, [r3, #0]
 800b958:	9b00      	ldr	r3, [sp, #0]
 800b95a:	18d3      	adds	r3, r2, r3
 800b95c:	9303      	str	r3, [sp, #12]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 800b95e:	9803      	ldr	r0, [sp, #12]
 800b960:	f000 fa68 	bl	800be34 <prvAddCurrentTaskToDelayedList>
 800b964:	4623      	mov	r3, r4
 800b966:	f64b 00e5 	movw	r0, #47333	; 0xb8e5
 800b96a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b96e:	4619      	mov	r1, r3
 800b970:	f001 f958 	bl	800cc24 <__cyg_profile_func_exit>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
 800b974:	b004      	add	sp, #16
 800b976:	bd10      	pop	{r4, pc}

0800b978 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
	{
 800b978:	b510      	push	{r4, lr}
 800b97a:	b084      	sub	sp, #16
 800b97c:	4674      	mov	r4, lr
 800b97e:	9001      	str	r0, [sp, #4]
 800b980:	9100      	str	r1, [sp, #0]
 800b982:	4623      	mov	r3, r4
 800b984:	f64b 1079 	movw	r0, #47481	; 0xb979
 800b988:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b98c:	4619      	mov	r1, r3
 800b98e:	f001 f93b 	bl	800cc08 <__cyg_profile_func_enter>
	
		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 800b992:	f240 4364 	movw	r3, #1124	; 0x464
 800b996:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b99a:	681b      	ldr	r3, [r3, #0]
 800b99c:	f103 0318 	add.w	r3, r3, #24
 800b9a0:	9801      	ldr	r0, [sp, #4]
 800b9a2:	4619      	mov	r1, r3
 800b9a4:	f7fe fee6 	bl	800a774 <vListInsertEnd>

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 800b9a8:	f240 4364 	movw	r3, #1124	; 0x464
 800b9ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b9b0:	681b      	ldr	r3, [r3, #0]
 800b9b2:	f103 0304 	add.w	r3, r3, #4
 800b9b6:	4618      	mov	r0, r3
 800b9b8:	f7fe ff5a 	bl	800a870 <vListRemove>

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
 800b9bc:	f240 5340 	movw	r3, #1344	; 0x540
 800b9c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b9c4:	681a      	ldr	r2, [r3, #0]
 800b9c6:	9b00      	ldr	r3, [sp, #0]
 800b9c8:	18d3      	adds	r3, r2, r3
 800b9ca:	9303      	str	r3, [sp, #12]
		prvAddCurrentTaskToDelayedList( xTimeToWake );
 800b9cc:	9803      	ldr	r0, [sp, #12]
 800b9ce:	f000 fa31 	bl	800be34 <prvAddCurrentTaskToDelayedList>
 800b9d2:	4623      	mov	r3, r4
 800b9d4:	f64b 1079 	movw	r0, #47481	; 0xb979
 800b9d8:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b9dc:	4619      	mov	r1, r3
 800b9de:	f001 f921 	bl	800cc24 <__cyg_profile_func_exit>
	}
 800b9e2:	b004      	add	sp, #16
 800b9e4:	bd10      	pop	{r4, pc}
 800b9e6:	bf00      	nop

0800b9e8 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
 800b9e8:	b530      	push	{r4, r5, lr}
 800b9ea:	b085      	sub	sp, #20
 800b9ec:	4674      	mov	r4, lr
 800b9ee:	9001      	str	r0, [sp, #4]
 800b9f0:	4623      	mov	r3, r4
 800b9f2:	f64b 10e9 	movw	r0, #47593	; 0xb9e9
 800b9f6:	f6c0 0000 	movt	r0, #2048	; 0x800
 800b9fa:	4619      	mov	r1, r3
 800b9fc:	f001 f904 	bl	800cc08 <__cyg_profile_func_enter>
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 800ba00:	9b01      	ldr	r3, [sp, #4]
 800ba02:	68db      	ldr	r3, [r3, #12]
 800ba04:	68db      	ldr	r3, [r3, #12]
 800ba06:	9302      	str	r3, [sp, #8]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800ba08:	9b02      	ldr	r3, [sp, #8]
 800ba0a:	f103 0318 	add.w	r3, r3, #24
 800ba0e:	4618      	mov	r0, r3
 800ba10:	f7fe ff2e 	bl	800a870 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 800ba14:	f240 5350 	movw	r3, #1360	; 0x550
 800ba18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ba1c:	681b      	ldr	r3, [r3, #0]
 800ba1e:	2b00      	cmp	r3, #0
 800ba20:	d12b      	bne.n	800ba7a <xTaskRemoveFromEventList+0x92>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 800ba22:	9b02      	ldr	r3, [sp, #8]
 800ba24:	f103 0304 	add.w	r3, r3, #4
 800ba28:	4618      	mov	r0, r3
 800ba2a:	f7fe ff21 	bl	800a870 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
 800ba2e:	9b02      	ldr	r3, [sp, #8]
 800ba30:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ba32:	f240 5348 	movw	r3, #1352	; 0x548
 800ba36:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ba3a:	681b      	ldr	r3, [r3, #0]
 800ba3c:	429a      	cmp	r2, r3
 800ba3e:	d906      	bls.n	800ba4e <xTaskRemoveFromEventList+0x66>
 800ba40:	9b02      	ldr	r3, [sp, #8]
 800ba42:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ba44:	f240 5348 	movw	r3, #1352	; 0x548
 800ba48:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ba4c:	601a      	str	r2, [r3, #0]
 800ba4e:	9b02      	ldr	r3, [sp, #8]
 800ba50:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ba52:	4613      	mov	r3, r2
 800ba54:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800ba58:	189b      	adds	r3, r3, r2
 800ba5a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800ba5e:	461a      	mov	r2, r3
 800ba60:	f240 4368 	movw	r3, #1128	; 0x468
 800ba64:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ba68:	18d2      	adds	r2, r2, r3
 800ba6a:	9b02      	ldr	r3, [sp, #8]
 800ba6c:	f103 0304 	add.w	r3, r3, #4
 800ba70:	4610      	mov	r0, r2
 800ba72:	4619      	mov	r1, r3
 800ba74:	f7fe fe7e 	bl	800a774 <vListInsertEnd>
 800ba78:	e009      	b.n	800ba8e <xTaskRemoveFromEventList+0xa6>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800ba7a:	9b02      	ldr	r3, [sp, #8]
 800ba7c:	f103 0318 	add.w	r3, r3, #24
 800ba80:	f240 40fc 	movw	r0, #1276	; 0x4fc
 800ba84:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800ba88:	4619      	mov	r1, r3
 800ba8a:	f7fe fe73 	bl	800a774 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800ba8e:	9b02      	ldr	r3, [sp, #8]
 800ba90:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ba92:	f240 4364 	movw	r3, #1124	; 0x464
 800ba96:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ba9a:	681b      	ldr	r3, [r3, #0]
 800ba9c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ba9e:	429a      	cmp	r2, r3
 800baa0:	d303      	bcc.n	800baaa <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
 800baa2:	f04f 0301 	mov.w	r3, #1
 800baa6:	9303      	str	r3, [sp, #12]
 800baa8:	e002      	b.n	800bab0 <xTaskRemoveFromEventList+0xc8>
	}
	else
	{
		xReturn = pdFALSE;
 800baaa:	f04f 0300 	mov.w	r3, #0
 800baae:	9303      	str	r3, [sp, #12]
	}

	return xReturn;
 800bab0:	9d03      	ldr	r5, [sp, #12]
 800bab2:	4623      	mov	r3, r4
 800bab4:	f64b 10e9 	movw	r0, #47593	; 0xb9e9
 800bab8:	f6c0 0000 	movt	r0, #2048	; 0x800
 800babc:	4619      	mov	r1, r3
 800babe:	f001 f8b1 	bl	800cc24 <__cyg_profile_func_exit>
 800bac2:	462b      	mov	r3, r5
}
 800bac4:	4618      	mov	r0, r3
 800bac6:	b005      	add	sp, #20
 800bac8:	bd30      	pop	{r4, r5, pc}
 800baca:	bf00      	nop

0800bacc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
 800bacc:	b510      	push	{r4, lr}
 800bace:	b082      	sub	sp, #8
 800bad0:	4674      	mov	r4, lr
 800bad2:	9001      	str	r0, [sp, #4]
 800bad4:	4623      	mov	r3, r4
 800bad6:	f64b 20cd 	movw	r0, #47821	; 0xbacd
 800bada:	f6c0 0000 	movt	r0, #2048	; 0x800
 800bade:	4619      	mov	r1, r3
 800bae0:	f001 f892 	bl	800cc08 <__cyg_profile_func_enter>
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800bae4:	f240 535c 	movw	r3, #1372	; 0x55c
 800bae8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800baec:	681a      	ldr	r2, [r3, #0]
 800baee:	9b01      	ldr	r3, [sp, #4]
 800baf0:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 800baf2:	f240 5340 	movw	r3, #1344	; 0x540
 800baf6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800bafa:	681a      	ldr	r2, [r3, #0]
 800bafc:	9b01      	ldr	r3, [sp, #4]
 800bafe:	605a      	str	r2, [r3, #4]
 800bb00:	4623      	mov	r3, r4
 800bb02:	f64b 20cd 	movw	r0, #47821	; 0xbacd
 800bb06:	f6c0 0000 	movt	r0, #2048	; 0x800
 800bb0a:	4619      	mov	r1, r3
 800bb0c:	f001 f88a 	bl	800cc24 <__cyg_profile_func_exit>
}
 800bb10:	b002      	add	sp, #8
 800bb12:	bd10      	pop	{r4, pc}

0800bb14 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
 800bb14:	b530      	push	{r4, r5, lr}
 800bb16:	b085      	sub	sp, #20
 800bb18:	4674      	mov	r4, lr
 800bb1a:	9001      	str	r0, [sp, #4]
 800bb1c:	9100      	str	r1, [sp, #0]
 800bb1e:	4623      	mov	r3, r4
 800bb20:	f64b 3015 	movw	r0, #47893	; 0xbb15
 800bb24:	f6c0 0000 	movt	r0, #2048	; 0x800
 800bb28:	4619      	mov	r1, r3
 800bb2a:	f001 f86d 	bl	800cc08 <__cyg_profile_func_enter>
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
 800bb2e:	f000 ffc3 	bl	800cab8 <vPortEnterCritical>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 800bb32:	9b00      	ldr	r3, [sp, #0]
 800bb34:	681b      	ldr	r3, [r3, #0]
 800bb36:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800bb3a:	d103      	bne.n	800bb44 <xTaskCheckForTimeOut+0x30>
			{
				xReturn = pdFALSE;
 800bb3c:	f04f 0300 	mov.w	r3, #0
 800bb40:	9303      	str	r3, [sp, #12]
 800bb42:	e038      	b.n	800bbb6 <xTaskCheckForTimeOut+0xa2>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
 800bb44:	9b01      	ldr	r3, [sp, #4]
 800bb46:	681a      	ldr	r2, [r3, #0]
 800bb48:	f240 535c 	movw	r3, #1372	; 0x55c
 800bb4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800bb50:	681b      	ldr	r3, [r3, #0]
 800bb52:	429a      	cmp	r2, r3
 800bb54:	d00c      	beq.n	800bb70 <xTaskCheckForTimeOut+0x5c>
 800bb56:	9b01      	ldr	r3, [sp, #4]
 800bb58:	685a      	ldr	r2, [r3, #4]
 800bb5a:	f240 5340 	movw	r3, #1344	; 0x540
 800bb5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800bb62:	681b      	ldr	r3, [r3, #0]
 800bb64:	429a      	cmp	r2, r3
 800bb66:	d803      	bhi.n	800bb70 <xTaskCheckForTimeOut+0x5c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
 800bb68:	f04f 0301 	mov.w	r3, #1
 800bb6c:	9303      	str	r3, [sp, #12]
 800bb6e:	e022      	b.n	800bbb6 <xTaskCheckForTimeOut+0xa2>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
 800bb70:	f240 5340 	movw	r3, #1344	; 0x540
 800bb74:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800bb78:	681a      	ldr	r2, [r3, #0]
 800bb7a:	9b01      	ldr	r3, [sp, #4]
 800bb7c:	685b      	ldr	r3, [r3, #4]
 800bb7e:	1ad2      	subs	r2, r2, r3
 800bb80:	9b00      	ldr	r3, [sp, #0]
 800bb82:	681b      	ldr	r3, [r3, #0]
 800bb84:	429a      	cmp	r2, r3
 800bb86:	d213      	bcs.n	800bbb0 <xTaskCheckForTimeOut+0x9c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 800bb88:	9b00      	ldr	r3, [sp, #0]
 800bb8a:	681a      	ldr	r2, [r3, #0]
 800bb8c:	9b01      	ldr	r3, [sp, #4]
 800bb8e:	6859      	ldr	r1, [r3, #4]
 800bb90:	f240 5340 	movw	r3, #1344	; 0x540
 800bb94:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800bb98:	681b      	ldr	r3, [r3, #0]
 800bb9a:	1acb      	subs	r3, r1, r3
 800bb9c:	18d2      	adds	r2, r2, r3
 800bb9e:	9b00      	ldr	r3, [sp, #0]
 800bba0:	601a      	str	r2, [r3, #0]
			vTaskSetTimeOutState( pxTimeOut );
 800bba2:	9801      	ldr	r0, [sp, #4]
 800bba4:	f7ff ff92 	bl	800bacc <vTaskSetTimeOutState>
			xReturn = pdFALSE;
 800bba8:	f04f 0300 	mov.w	r3, #0
 800bbac:	9303      	str	r3, [sp, #12]
 800bbae:	e002      	b.n	800bbb6 <xTaskCheckForTimeOut+0xa2>
		}
		else
		{
			xReturn = pdTRUE;
 800bbb0:	f04f 0301 	mov.w	r3, #1
 800bbb4:	9303      	str	r3, [sp, #12]
		}
	}
	taskEXIT_CRITICAL();
 800bbb6:	f000 ffa3 	bl	800cb00 <vPortExitCritical>

	return xReturn;
 800bbba:	9d03      	ldr	r5, [sp, #12]
 800bbbc:	4623      	mov	r3, r4
 800bbbe:	f64b 3015 	movw	r0, #47893	; 0xbb15
 800bbc2:	f6c0 0000 	movt	r0, #2048	; 0x800
 800bbc6:	4619      	mov	r1, r3
 800bbc8:	f001 f82c 	bl	800cc24 <__cyg_profile_func_exit>
 800bbcc:	462b      	mov	r3, r5
}
 800bbce:	4618      	mov	r0, r3
 800bbd0:	b005      	add	sp, #20
 800bbd2:	bd30      	pop	{r4, r5, pc}

0800bbd4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 800bbd4:	b510      	push	{r4, lr}
 800bbd6:	4674      	mov	r4, lr
 800bbd8:	4623      	mov	r3, r4
 800bbda:	f64b 30d5 	movw	r0, #48085	; 0xbbd5
 800bbde:	f6c0 0000 	movt	r0, #2048	; 0x800
 800bbe2:	4619      	mov	r1, r3
 800bbe4:	f001 f810 	bl	800cc08 <__cyg_profile_func_enter>
	xMissedYield = pdTRUE;
 800bbe8:	f240 5358 	movw	r3, #1368	; 0x558
 800bbec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800bbf0:	f04f 0201 	mov.w	r2, #1
 800bbf4:	601a      	str	r2, [r3, #0]
 800bbf6:	4623      	mov	r3, r4
 800bbf8:	f64b 30d5 	movw	r0, #48085	; 0xbbd5
 800bbfc:	f6c0 0000 	movt	r0, #2048	; 0x800
 800bc00:	4619      	mov	r1, r3
 800bc02:	f001 f80f 	bl	800cc24 <__cyg_profile_func_exit>
}
 800bc06:	bd10      	pop	{r4, pc}

0800bc08 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 800bc08:	b500      	push	{lr}
 800bc0a:	b083      	sub	sp, #12
 800bc0c:	4673      	mov	r3, lr
 800bc0e:	9001      	str	r0, [sp, #4]
 800bc10:	f64b 4009 	movw	r0, #48137	; 0xbc09
 800bc14:	f6c0 0000 	movt	r0, #2048	; 0x800
 800bc18:	4619      	mov	r1, r3
 800bc1a:	f000 fff5 	bl	800cc08 <__cyg_profile_func_enter>
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
 800bc1e:	f000 f8b1 	bl	800bd84 <prvCheckTasksWaitingTermination>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
 800bc22:	f7fc fb61 	bl	80082e8 <vApplicationIdleHook>
		}
		#endif
	}
 800bc26:	e7fa      	b.n	800bc1e <prvIdleTask+0x16>

0800bc28 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
 800bc28:	b510      	push	{r4, lr}
 800bc2a:	b084      	sub	sp, #16
 800bc2c:	4674      	mov	r4, lr
 800bc2e:	9003      	str	r0, [sp, #12]
 800bc30:	9102      	str	r1, [sp, #8]
 800bc32:	9201      	str	r2, [sp, #4]
 800bc34:	9300      	str	r3, [sp, #0]
 800bc36:	4623      	mov	r3, r4
 800bc38:	f64b 4029 	movw	r0, #48169	; 0xbc29
 800bc3c:	f6c0 0000 	movt	r0, #2048	; 0x800
 800bc40:	4619      	mov	r1, r3
 800bc42:	f000 ffe1 	bl	800cc08 <__cyg_profile_func_enter>
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 800bc46:	9b03      	ldr	r3, [sp, #12]
 800bc48:	f103 0334 	add.w	r3, r3, #52	; 0x34
 800bc4c:	4618      	mov	r0, r3
 800bc4e:	9902      	ldr	r1, [sp, #8]
 800bc50:	f04f 0210 	mov.w	r2, #16
 800bc54:	f001 febe 	bl	800d9d4 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
 800bc58:	9b03      	ldr	r3, [sp, #12]
 800bc5a:	f04f 0200 	mov.w	r2, #0
 800bc5e:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
 800bc62:	9b01      	ldr	r3, [sp, #4]
 800bc64:	2b04      	cmp	r3, #4
 800bc66:	d902      	bls.n	800bc6e <prvInitialiseTCBVariables+0x46>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 800bc68:	f04f 0304 	mov.w	r3, #4
 800bc6c:	9301      	str	r3, [sp, #4]
	}

	pxTCB->uxPriority = uxPriority;
 800bc6e:	9b03      	ldr	r3, [sp, #12]
 800bc70:	9a01      	ldr	r2, [sp, #4]
 800bc72:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 800bc74:	9b03      	ldr	r3, [sp, #12]
 800bc76:	9a01      	ldr	r2, [sp, #4]
 800bc78:	645a      	str	r2, [r3, #68]	; 0x44
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 800bc7a:	9b03      	ldr	r3, [sp, #12]
 800bc7c:	f103 0304 	add.w	r3, r3, #4
 800bc80:	4618      	mov	r0, r3
 800bc82:	f7fe fd5d 	bl	800a740 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 800bc86:	9b03      	ldr	r3, [sp, #12]
 800bc88:	f103 0318 	add.w	r3, r3, #24
 800bc8c:	4618      	mov	r0, r3
 800bc8e:	f7fe fd57 	bl	800a740 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 800bc92:	9b03      	ldr	r3, [sp, #12]
 800bc94:	9a03      	ldr	r2, [sp, #12]
 800bc96:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 800bc98:	9b01      	ldr	r3, [sp, #4]
 800bc9a:	f1c3 0205 	rsb	r2, r3, #5
 800bc9e:	9b03      	ldr	r3, [sp, #12]
 800bca0:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 800bca2:	9b03      	ldr	r3, [sp, #12]
 800bca4:	9a03      	ldr	r2, [sp, #12]
 800bca6:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif

	#if ( configGENERATE_RUN_TIME_STATS == 1 )
	{
		pxTCB->ulRunTimeCounter = 0UL;
 800bca8:	9b03      	ldr	r3, [sp, #12]
 800bcaa:	f04f 0200 	mov.w	r2, #0
 800bcae:	649a      	str	r2, [r3, #72]	; 0x48
 800bcb0:	4623      	mov	r3, r4
 800bcb2:	f64b 4029 	movw	r0, #48169	; 0xbc29
 800bcb6:	f6c0 0000 	movt	r0, #2048	; 0x800
 800bcba:	4619      	mov	r1, r3
 800bcbc:	f000 ffb2 	bl	800cc24 <__cyg_profile_func_exit>
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
 800bcc0:	b004      	add	sp, #16
 800bcc2:	bd10      	pop	{r4, pc}

0800bcc4 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
 800bcc4:	b510      	push	{r4, lr}
 800bcc6:	b082      	sub	sp, #8
 800bcc8:	4674      	mov	r4, lr
 800bcca:	4623      	mov	r3, r4
 800bccc:	f64b 40c5 	movw	r0, #48325	; 0xbcc5
 800bcd0:	f6c0 0000 	movt	r0, #2048	; 0x800
 800bcd4:	4619      	mov	r1, r3
 800bcd6:	f000 ff97 	bl	800cc08 <__cyg_profile_func_enter>
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 800bcda:	f04f 0300 	mov.w	r3, #0
 800bcde:	9301      	str	r3, [sp, #4]
 800bce0:	e013      	b.n	800bd0a <prvInitialiseTaskLists+0x46>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 800bce2:	9a01      	ldr	r2, [sp, #4]
 800bce4:	4613      	mov	r3, r2
 800bce6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800bcea:	189b      	adds	r3, r3, r2
 800bcec:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800bcf0:	461a      	mov	r2, r3
 800bcf2:	f240 4368 	movw	r3, #1128	; 0x468
 800bcf6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800bcfa:	18d3      	adds	r3, r2, r3
 800bcfc:	4618      	mov	r0, r3
 800bcfe:	f7fe fcf1 	bl	800a6e4 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 800bd02:	9b01      	ldr	r3, [sp, #4]
 800bd04:	f103 0301 	add.w	r3, r3, #1
 800bd08:	9301      	str	r3, [sp, #4]
 800bd0a:	9b01      	ldr	r3, [sp, #4]
 800bd0c:	2b04      	cmp	r3, #4
 800bd0e:	d9e8      	bls.n	800bce2 <prvInitialiseTaskLists+0x1e>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 800bd10:	f240 40cc 	movw	r0, #1228	; 0x4cc
 800bd14:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800bd18:	f7fe fce4 	bl	800a6e4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 800bd1c:	f240 40e0 	movw	r0, #1248	; 0x4e0
 800bd20:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800bd24:	f7fe fcde 	bl	800a6e4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
 800bd28:	f240 40fc 	movw	r0, #1276	; 0x4fc
 800bd2c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800bd30:	f7fe fcd8 	bl	800a6e4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 800bd34:	f240 5010 	movw	r0, #1296	; 0x510
 800bd38:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800bd3c:	f7fe fcd2 	bl	800a6e4 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
 800bd40:	f240 5028 	movw	r0, #1320	; 0x528
 800bd44:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800bd48:	f7fe fccc 	bl	800a6e4 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 800bd4c:	f240 43f4 	movw	r3, #1268	; 0x4f4
 800bd50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800bd54:	f240 42cc 	movw	r2, #1228	; 0x4cc
 800bd58:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800bd5c:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800bd5e:	f240 43f8 	movw	r3, #1272	; 0x4f8
 800bd62:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800bd66:	f240 42e0 	movw	r2, #1248	; 0x4e0
 800bd6a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800bd6e:	601a      	str	r2, [r3, #0]
 800bd70:	4623      	mov	r3, r4
 800bd72:	f64b 40c5 	movw	r0, #48325	; 0xbcc5
 800bd76:	f6c0 0000 	movt	r0, #2048	; 0x800
 800bd7a:	4619      	mov	r1, r3
 800bd7c:	f000 ff52 	bl	800cc24 <__cyg_profile_func_exit>
}
 800bd80:	b002      	add	sp, #8
 800bd82:	bd10      	pop	{r4, pc}

0800bd84 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 800bd84:	b510      	push	{r4, lr}
 800bd86:	b082      	sub	sp, #8
 800bd88:	4674      	mov	r4, lr
 800bd8a:	4623      	mov	r3, r4
 800bd8c:	f64b 5085 	movw	r0, #48517	; 0xbd85
 800bd90:	f6c0 0000 	movt	r0, #2048	; 0x800
 800bd94:	4619      	mov	r1, r3
 800bd96:	f000 ff37 	bl	800cc08 <__cyg_profile_func_enter>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
 800bd9a:	f240 5324 	movw	r3, #1316	; 0x524
 800bd9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800bda2:	681b      	ldr	r3, [r3, #0]
 800bda4:	2b00      	cmp	r3, #0
 800bda6:	d039      	beq.n	800be1c <prvCheckTasksWaitingTermination+0x98>
		{
			vTaskSuspendAll();
 800bda8:	f7ff faea 	bl	800b380 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 800bdac:	f240 5310 	movw	r3, #1296	; 0x510
 800bdb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800bdb4:	681b      	ldr	r3, [r3, #0]
 800bdb6:	2b00      	cmp	r3, #0
 800bdb8:	bf14      	ite	ne
 800bdba:	2300      	movne	r3, #0
 800bdbc:	2301      	moveq	r3, #1
 800bdbe:	9301      	str	r3, [sp, #4]
			xTaskResumeAll();
 800bdc0:	f7ff fafe 	bl	800b3c0 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 800bdc4:	9b01      	ldr	r3, [sp, #4]
 800bdc6:	2b00      	cmp	r3, #0
 800bdc8:	d128      	bne.n	800be1c <prvCheckTasksWaitingTermination+0x98>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
 800bdca:	f000 fe75 	bl	800cab8 <vPortEnterCritical>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 800bdce:	4b18      	ldr	r3, [pc, #96]	; (800be30 <prvCheckTasksWaitingTermination+0xac>)
 800bdd0:	685b      	ldr	r3, [r3, #4]
 800bdd2:	68db      	ldr	r3, [r3, #12]
 800bdd4:	9300      	str	r3, [sp, #0]
					vListRemove( &( pxTCB->xGenericListItem ) );
 800bdd6:	9b00      	ldr	r3, [sp, #0]
 800bdd8:	f103 0304 	add.w	r3, r3, #4
 800bddc:	4618      	mov	r0, r3
 800bdde:	f7fe fd47 	bl	800a870 <vListRemove>
					--uxCurrentNumberOfTasks;
 800bde2:	f240 533c 	movw	r3, #1340	; 0x53c
 800bde6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800bdea:	681b      	ldr	r3, [r3, #0]
 800bdec:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 800bdf0:	f240 533c 	movw	r3, #1340	; 0x53c
 800bdf4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800bdf8:	601a      	str	r2, [r3, #0]
					--uxTasksDeleted;
 800bdfa:	f240 5324 	movw	r3, #1316	; 0x524
 800bdfe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800be02:	681b      	ldr	r3, [r3, #0]
 800be04:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 800be08:	f240 5324 	movw	r3, #1316	; 0x524
 800be0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800be10:	601a      	str	r2, [r3, #0]
				}
				taskEXIT_CRITICAL();
 800be12:	f000 fe75 	bl	800cb00 <vPortExitCritical>

				prvDeleteTCB( pxTCB );
 800be16:	9800      	ldr	r0, [sp, #0]
 800be18:	f000 f8aa 	bl	800bf70 <prvDeleteTCB>
 800be1c:	4623      	mov	r3, r4
 800be1e:	f64b 5085 	movw	r0, #48517	; 0xbd85
 800be22:	f6c0 0000 	movt	r0, #2048	; 0x800
 800be26:	4619      	mov	r1, r3
 800be28:	f000 fefc 	bl	800cc24 <__cyg_profile_func_exit>
			}
		}
	}
	#endif
}
 800be2c:	b002      	add	sp, #8
 800be2e:	bd10      	pop	{r4, pc}
 800be30:	20000518 	.word	0x20000518

0800be34 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
 800be34:	b510      	push	{r4, lr}
 800be36:	b082      	sub	sp, #8
 800be38:	4674      	mov	r4, lr
 800be3a:	9001      	str	r0, [sp, #4]
 800be3c:	4623      	mov	r3, r4
 800be3e:	f64b 6035 	movw	r0, #48693	; 0xbe35
 800be42:	f6c0 0000 	movt	r0, #2048	; 0x800
 800be46:	4619      	mov	r1, r3
 800be48:	f000 fede 	bl	800cc08 <__cyg_profile_func_enter>
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 800be4c:	f240 4364 	movw	r3, #1124	; 0x464
 800be50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800be54:	681b      	ldr	r3, [r3, #0]
 800be56:	9a01      	ldr	r2, [sp, #4]
 800be58:	605a      	str	r2, [r3, #4]

	if( xTimeToWake < xTickCount )
 800be5a:	f240 5340 	movw	r3, #1344	; 0x540
 800be5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800be62:	681b      	ldr	r3, [r3, #0]
 800be64:	9a01      	ldr	r2, [sp, #4]
 800be66:	429a      	cmp	r2, r3
 800be68:	d210      	bcs.n	800be8c <prvAddCurrentTaskToDelayedList+0x58>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 800be6a:	f240 43f8 	movw	r3, #1272	; 0x4f8
 800be6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800be72:	681a      	ldr	r2, [r3, #0]
 800be74:	f240 4364 	movw	r3, #1124	; 0x464
 800be78:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800be7c:	681b      	ldr	r3, [r3, #0]
 800be7e:	f103 0304 	add.w	r3, r3, #4
 800be82:	4610      	mov	r0, r2
 800be84:	4619      	mov	r1, r3
 800be86:	f7fe fcab 	bl	800a7e0 <vListInsert>
 800be8a:	e01d      	b.n	800bec8 <prvAddCurrentTaskToDelayedList+0x94>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 800be8c:	f240 43f4 	movw	r3, #1268	; 0x4f4
 800be90:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800be94:	681a      	ldr	r2, [r3, #0]
 800be96:	f240 4364 	movw	r3, #1124	; 0x464
 800be9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800be9e:	681b      	ldr	r3, [r3, #0]
 800bea0:	f103 0304 	add.w	r3, r3, #4
 800bea4:	4610      	mov	r0, r2
 800bea6:	4619      	mov	r1, r3
 800bea8:	f7fe fc9a 	bl	800a7e0 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 800beac:	f240 4330 	movw	r3, #1072	; 0x430
 800beb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800beb4:	681b      	ldr	r3, [r3, #0]
 800beb6:	9a01      	ldr	r2, [sp, #4]
 800beb8:	429a      	cmp	r2, r3
 800beba:	d205      	bcs.n	800bec8 <prvAddCurrentTaskToDelayedList+0x94>
		{
			xNextTaskUnblockTime = xTimeToWake;
 800bebc:	f240 4330 	movw	r3, #1072	; 0x430
 800bec0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800bec4:	9a01      	ldr	r2, [sp, #4]
 800bec6:	601a      	str	r2, [r3, #0]
 800bec8:	4623      	mov	r3, r4
 800beca:	f64b 6035 	movw	r0, #48693	; 0xbe35
 800bece:	f6c0 0000 	movt	r0, #2048	; 0x800
 800bed2:	4619      	mov	r1, r3
 800bed4:	f000 fea6 	bl	800cc24 <__cyg_profile_func_exit>
		}
	}
}
 800bed8:	b002      	add	sp, #8
 800beda:	bd10      	pop	{r4, pc}

0800bedc <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
 800bedc:	b530      	push	{r4, r5, lr}
 800bede:	b085      	sub	sp, #20
 800bee0:	4674      	mov	r4, lr
 800bee2:	4603      	mov	r3, r0
 800bee4:	9100      	str	r1, [sp, #0]
 800bee6:	f8ad 3006 	strh.w	r3, [sp, #6]
 800beea:	4623      	mov	r3, r4
 800beec:	f64b 60dd 	movw	r0, #48861	; 0xbedd
 800bef0:	f6c0 0000 	movt	r0, #2048	; 0x800
 800bef4:	4619      	mov	r1, r3
 800bef6:	f000 fe87 	bl	800cc08 <__cyg_profile_func_enter>
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 800befa:	f04f 004c 	mov.w	r0, #76	; 0x4c
 800befe:	f001 fbf9 	bl	800d6f4 <pvPortMalloc>
 800bf02:	9003      	str	r0, [sp, #12]

	if( pxNewTCB != NULL )
 800bf04:	9b03      	ldr	r3, [sp, #12]
 800bf06:	2b00      	cmp	r3, #0
 800bf08:	d025      	beq.n	800bf56 <prvAllocateTCBAndStack+0x7a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
 800bf0a:	9b00      	ldr	r3, [sp, #0]
 800bf0c:	2b00      	cmp	r3, #0
 800bf0e:	d108      	bne.n	800bf22 <prvAllocateTCBAndStack+0x46>
 800bf10:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800bf14:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800bf18:	4618      	mov	r0, r3
 800bf1a:	f001 fbeb 	bl	800d6f4 <pvPortMalloc>
 800bf1e:	4603      	mov	r3, r0
 800bf20:	e000      	b.n	800bf24 <prvAllocateTCBAndStack+0x48>
 800bf22:	9b00      	ldr	r3, [sp, #0]
 800bf24:	9a03      	ldr	r2, [sp, #12]
 800bf26:	6313      	str	r3, [r2, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 800bf28:	9b03      	ldr	r3, [sp, #12]
 800bf2a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bf2c:	2b00      	cmp	r3, #0
 800bf2e:	d106      	bne.n	800bf3e <prvAllocateTCBAndStack+0x62>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 800bf30:	9803      	ldr	r0, [sp, #12]
 800bf32:	f001 fc0b 	bl	800d74c <vPortFree>
			pxNewTCB = NULL;
 800bf36:	f04f 0300 	mov.w	r3, #0
 800bf3a:	9303      	str	r3, [sp, #12]
 800bf3c:	e00b      	b.n	800bf56 <prvAllocateTCBAndStack+0x7a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
 800bf3e:	9b03      	ldr	r3, [sp, #12]
 800bf40:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800bf42:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800bf46:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800bf4a:	4610      	mov	r0, r2
 800bf4c:	f04f 01a5 	mov.w	r1, #165	; 0xa5
 800bf50:	461a      	mov	r2, r3
 800bf52:	f001 fcc5 	bl	800d8e0 <memset>
		}
	}

	return pxNewTCB;
 800bf56:	9d03      	ldr	r5, [sp, #12]
 800bf58:	4623      	mov	r3, r4
 800bf5a:	f64b 60dd 	movw	r0, #48861	; 0xbedd
 800bf5e:	f6c0 0000 	movt	r0, #2048	; 0x800
 800bf62:	4619      	mov	r1, r3
 800bf64:	f000 fe5e 	bl	800cc24 <__cyg_profile_func_exit>
 800bf68:	462b      	mov	r3, r5
}
 800bf6a:	4618      	mov	r0, r3
 800bf6c:	b005      	add	sp, #20
 800bf6e:	bd30      	pop	{r4, r5, pc}

0800bf70 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
 800bf70:	b510      	push	{r4, lr}
 800bf72:	b082      	sub	sp, #8
 800bf74:	4674      	mov	r4, lr
 800bf76:	9001      	str	r0, [sp, #4]
 800bf78:	4623      	mov	r3, r4
 800bf7a:	f64b 7071 	movw	r0, #49009	; 0xbf71
 800bf7e:	f6c0 0000 	movt	r0, #2048	; 0x800
 800bf82:	4619      	mov	r1, r3
 800bf84:	f000 fe40 	bl	800cc08 <__cyg_profile_func_enter>
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 800bf88:	9b01      	ldr	r3, [sp, #4]
 800bf8a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bf8c:	4618      	mov	r0, r3
 800bf8e:	f001 fbdd 	bl	800d74c <vPortFree>
		vPortFree( pxTCB );
 800bf92:	9801      	ldr	r0, [sp, #4]
 800bf94:	f001 fbda 	bl	800d74c <vPortFree>
 800bf98:	4623      	mov	r3, r4
 800bf9a:	f64b 7071 	movw	r0, #49009	; 0xbf71
 800bf9e:	f6c0 0000 	movt	r0, #2048	; 0x800
 800bfa2:	4619      	mov	r1, r3
 800bfa4:	f000 fe3e 	bl	800cc24 <__cyg_profile_func_exit>
	}
 800bfa8:	b002      	add	sp, #8
 800bfaa:	bd10      	pop	{r4, pc}

0800bfac <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
 800bfac:	b530      	push	{r4, r5, lr}
 800bfae:	b083      	sub	sp, #12
 800bfb0:	4674      	mov	r4, lr
 800bfb2:	4623      	mov	r3, r4
 800bfb4:	f64b 70ad 	movw	r0, #49069	; 0xbfad
 800bfb8:	f6c0 0000 	movt	r0, #2048	; 0x800
 800bfbc:	4619      	mov	r1, r3
 800bfbe:	f000 fe23 	bl	800cc08 <__cyg_profile_func_enter>
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 800bfc2:	f240 4364 	movw	r3, #1124	; 0x464
 800bfc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800bfca:	681b      	ldr	r3, [r3, #0]
 800bfcc:	9301      	str	r3, [sp, #4]

		return xReturn;
 800bfce:	9d01      	ldr	r5, [sp, #4]
 800bfd0:	4623      	mov	r3, r4
 800bfd2:	f64b 70ad 	movw	r0, #49069	; 0xbfad
 800bfd6:	f6c0 0000 	movt	r0, #2048	; 0x800
 800bfda:	4619      	mov	r1, r3
 800bfdc:	f000 fe22 	bl	800cc24 <__cyg_profile_func_exit>
 800bfe0:	462b      	mov	r3, r5
	}
 800bfe2:	4618      	mov	r0, r3
 800bfe4:	b003      	add	sp, #12
 800bfe6:	bd30      	pop	{r4, r5, pc}

0800bfe8 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
 800bfe8:	b530      	push	{r4, r5, lr}
 800bfea:	b083      	sub	sp, #12
 800bfec:	4674      	mov	r4, lr
 800bfee:	4623      	mov	r3, r4
 800bff0:	f64b 70e9 	movw	r0, #49129	; 0xbfe9
 800bff4:	f6c0 0000 	movt	r0, #2048	; 0x800
 800bff8:	4619      	mov	r1, r3
 800bffa:	f000 fe05 	bl	800cc08 <__cyg_profile_func_enter>
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
 800bffe:	f240 534c 	movw	r3, #1356	; 0x54c
 800c002:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c006:	681b      	ldr	r3, [r3, #0]
 800c008:	2b00      	cmp	r3, #0
 800c00a:	d103      	bne.n	800c014 <xTaskGetSchedulerState+0x2c>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
 800c00c:	f04f 0300 	mov.w	r3, #0
 800c010:	9301      	str	r3, [sp, #4]
 800c012:	e00d      	b.n	800c030 <xTaskGetSchedulerState+0x48>
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 800c014:	f240 5350 	movw	r3, #1360	; 0x550
 800c018:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c01c:	681b      	ldr	r3, [r3, #0]
 800c01e:	2b00      	cmp	r3, #0
 800c020:	d103      	bne.n	800c02a <xTaskGetSchedulerState+0x42>
			{
				xReturn = taskSCHEDULER_RUNNING;
 800c022:	f04f 0301 	mov.w	r3, #1
 800c026:	9301      	str	r3, [sp, #4]
 800c028:	e002      	b.n	800c030 <xTaskGetSchedulerState+0x48>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
 800c02a:	f04f 0302 	mov.w	r3, #2
 800c02e:	9301      	str	r3, [sp, #4]
			}
		}

		return xReturn;
 800c030:	9d01      	ldr	r5, [sp, #4]
 800c032:	4623      	mov	r3, r4
 800c034:	f64b 70e9 	movw	r0, #49129	; 0xbfe9
 800c038:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c03c:	4619      	mov	r1, r3
 800c03e:	f000 fdf1 	bl	800cc24 <__cyg_profile_func_exit>
 800c042:	462b      	mov	r3, r5
	}
 800c044:	4618      	mov	r0, r3
 800c046:	b003      	add	sp, #12
 800c048:	bd30      	pop	{r4, r5, pc}
 800c04a:	bf00      	nop

0800c04c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
 800c04c:	b510      	push	{r4, lr}
 800c04e:	b084      	sub	sp, #16
 800c050:	4674      	mov	r4, lr
 800c052:	9001      	str	r0, [sp, #4]
 800c054:	4623      	mov	r3, r4
 800c056:	f24c 004d 	movw	r0, #49229	; 0xc04d
 800c05a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c05e:	4619      	mov	r1, r3
 800c060:	f000 fdd2 	bl	800cc08 <__cyg_profile_func_enter>
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 800c064:	9b01      	ldr	r3, [sp, #4]
 800c066:	9303      	str	r3, [sp, #12]

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 800c068:	9b03      	ldr	r3, [sp, #12]
 800c06a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c06c:	f240 4364 	movw	r3, #1124	; 0x464
 800c070:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c074:	681b      	ldr	r3, [r3, #0]
 800c076:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c078:	429a      	cmp	r2, r3
 800c07a:	d257      	bcs.n	800c12c <vTaskPriorityInherit+0xe0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
 800c07c:	f240 4364 	movw	r3, #1124	; 0x464
 800c080:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c084:	681b      	ldr	r3, [r3, #0]
 800c086:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c088:	f1c3 0205 	rsb	r2, r3, #5
 800c08c:	9b03      	ldr	r3, [sp, #12]
 800c08e:	619a      	str	r2, [r3, #24]

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
 800c090:	9b03      	ldr	r3, [sp, #12]
 800c092:	6959      	ldr	r1, [r3, #20]
 800c094:	9b03      	ldr	r3, [sp, #12]
 800c096:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c098:	4613      	mov	r3, r2
 800c09a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c09e:	189b      	adds	r3, r3, r2
 800c0a0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c0a4:	461a      	mov	r2, r3
 800c0a6:	f240 4368 	movw	r3, #1128	; 0x468
 800c0aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c0ae:	18d3      	adds	r3, r2, r3
 800c0b0:	4299      	cmp	r1, r3
 800c0b2:	d133      	bne.n	800c11c <vTaskPriorityInherit+0xd0>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
 800c0b4:	9b03      	ldr	r3, [sp, #12]
 800c0b6:	f103 0304 	add.w	r3, r3, #4
 800c0ba:	4618      	mov	r0, r3
 800c0bc:	f7fe fbd8 	bl	800a870 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 800c0c0:	f240 4364 	movw	r3, #1124	; 0x464
 800c0c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c0c8:	681b      	ldr	r3, [r3, #0]
 800c0ca:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c0cc:	9b03      	ldr	r3, [sp, #12]
 800c0ce:	62da      	str	r2, [r3, #44]	; 0x2c
				prvAddTaskToReadyQueue( pxTCB );
 800c0d0:	9b03      	ldr	r3, [sp, #12]
 800c0d2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c0d4:	f240 5348 	movw	r3, #1352	; 0x548
 800c0d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c0dc:	681b      	ldr	r3, [r3, #0]
 800c0de:	429a      	cmp	r2, r3
 800c0e0:	d906      	bls.n	800c0f0 <vTaskPriorityInherit+0xa4>
 800c0e2:	9b03      	ldr	r3, [sp, #12]
 800c0e4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c0e6:	f240 5348 	movw	r3, #1352	; 0x548
 800c0ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c0ee:	601a      	str	r2, [r3, #0]
 800c0f0:	9b03      	ldr	r3, [sp, #12]
 800c0f2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c0f4:	4613      	mov	r3, r2
 800c0f6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c0fa:	189b      	adds	r3, r3, r2
 800c0fc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c100:	461a      	mov	r2, r3
 800c102:	f240 4368 	movw	r3, #1128	; 0x468
 800c106:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c10a:	18d2      	adds	r2, r2, r3
 800c10c:	9b03      	ldr	r3, [sp, #12]
 800c10e:	f103 0304 	add.w	r3, r3, #4
 800c112:	4610      	mov	r0, r2
 800c114:	4619      	mov	r1, r3
 800c116:	f7fe fb2d 	bl	800a774 <vListInsertEnd>
 800c11a:	e007      	b.n	800c12c <vTaskPriorityInherit+0xe0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 800c11c:	f240 4364 	movw	r3, #1124	; 0x464
 800c120:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c124:	681b      	ldr	r3, [r3, #0]
 800c126:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c128:	9b03      	ldr	r3, [sp, #12]
 800c12a:	62da      	str	r2, [r3, #44]	; 0x2c
 800c12c:	4623      	mov	r3, r4
 800c12e:	f24c 004d 	movw	r0, #49229	; 0xc04d
 800c132:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c136:	4619      	mov	r1, r3
 800c138:	f000 fd74 	bl	800cc24 <__cyg_profile_func_exit>
			}
		}
	}
 800c13c:	b004      	add	sp, #16
 800c13e:	bd10      	pop	{r4, pc}

0800c140 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
 800c140:	b510      	push	{r4, lr}
 800c142:	b084      	sub	sp, #16
 800c144:	4674      	mov	r4, lr
 800c146:	9001      	str	r0, [sp, #4]
 800c148:	4623      	mov	r3, r4
 800c14a:	f24c 1041 	movw	r0, #49473	; 0xc141
 800c14e:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c152:	4619      	mov	r1, r3
 800c154:	f000 fd58 	bl	800cc08 <__cyg_profile_func_enter>
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 800c158:	9b01      	ldr	r3, [sp, #4]
 800c15a:	9303      	str	r3, [sp, #12]

		if( pxMutexHolder != NULL )
 800c15c:	9b01      	ldr	r3, [sp, #4]
 800c15e:	2b00      	cmp	r3, #0
 800c160:	d03a      	beq.n	800c1d8 <vTaskPriorityDisinherit+0x98>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800c162:	9b03      	ldr	r3, [sp, #12]
 800c164:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c166:	9b03      	ldr	r3, [sp, #12]
 800c168:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c16a:	429a      	cmp	r2, r3
 800c16c:	d034      	beq.n	800c1d8 <vTaskPriorityDisinherit+0x98>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
 800c16e:	9b03      	ldr	r3, [sp, #12]
 800c170:	f103 0304 	add.w	r3, r3, #4
 800c174:	4618      	mov	r0, r3
 800c176:	f7fe fb7b 	bl	800a870 <vListRemove>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
 800c17a:	9b03      	ldr	r3, [sp, #12]
 800c17c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800c17e:	9b03      	ldr	r3, [sp, #12]
 800c180:	62da      	str	r2, [r3, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
 800c182:	9b03      	ldr	r3, [sp, #12]
 800c184:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c186:	f1c3 0205 	rsb	r2, r3, #5
 800c18a:	9b03      	ldr	r3, [sp, #12]
 800c18c:	619a      	str	r2, [r3, #24]
				prvAddTaskToReadyQueue( pxTCB );
 800c18e:	9b03      	ldr	r3, [sp, #12]
 800c190:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c192:	f240 5348 	movw	r3, #1352	; 0x548
 800c196:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c19a:	681b      	ldr	r3, [r3, #0]
 800c19c:	429a      	cmp	r2, r3
 800c19e:	d906      	bls.n	800c1ae <vTaskPriorityDisinherit+0x6e>
 800c1a0:	9b03      	ldr	r3, [sp, #12]
 800c1a2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c1a4:	f240 5348 	movw	r3, #1352	; 0x548
 800c1a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c1ac:	601a      	str	r2, [r3, #0]
 800c1ae:	9b03      	ldr	r3, [sp, #12]
 800c1b0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c1b2:	4613      	mov	r3, r2
 800c1b4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c1b8:	189b      	adds	r3, r3, r2
 800c1ba:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c1be:	461a      	mov	r2, r3
 800c1c0:	f240 4368 	movw	r3, #1128	; 0x468
 800c1c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c1c8:	18d2      	adds	r2, r2, r3
 800c1ca:	9b03      	ldr	r3, [sp, #12]
 800c1cc:	f103 0304 	add.w	r3, r3, #4
 800c1d0:	4610      	mov	r0, r2
 800c1d2:	4619      	mov	r1, r3
 800c1d4:	f7fe face 	bl	800a774 <vListInsertEnd>
 800c1d8:	4623      	mov	r3, r4
 800c1da:	f24c 1041 	movw	r0, #49473	; 0xc141
 800c1de:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c1e2:	4619      	mov	r1, r3
 800c1e4:	f000 fd1e 	bl	800cc24 <__cyg_profile_func_exit>
			}
		}
	}
 800c1e8:	b004      	add	sp, #16
 800c1ea:	bd10      	pop	{r4, pc}

0800c1ec <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

portBASE_TYPE xTimerCreateTimerTask( void )
{
 800c1ec:	b530      	push	{r4, r5, lr}
 800c1ee:	b087      	sub	sp, #28
 800c1f0:	4674      	mov	r4, lr
 800c1f2:	4623      	mov	r3, r4
 800c1f4:	f24c 10ed 	movw	r0, #49645	; 0xc1ed
 800c1f8:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c1fc:	4619      	mov	r1, r3
 800c1fe:	f000 fd03 	bl	800cc08 <__cyg_profile_func_enter>
portBASE_TYPE xReturn = pdFAIL;
 800c202:	f04f 0300 	mov.w	r3, #0
 800c206:	9305      	str	r3, [sp, #20]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
 800c208:	f000 fb04 	bl	800c814 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
 800c20c:	f240 5398 	movw	r3, #1432	; 0x598
 800c210:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c214:	681b      	ldr	r3, [r3, #0]
 800c216:	2b00      	cmp	r3, #0
 800c218:	d01a      	beq.n	800c250 <xTimerCreateTimerTask+0x64>
	{
		xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY, NULL);
 800c21a:	f04f 0304 	mov.w	r3, #4
 800c21e:	9300      	str	r3, [sp, #0]
 800c220:	f04f 0300 	mov.w	r3, #0
 800c224:	9301      	str	r3, [sp, #4]
 800c226:	f04f 0300 	mov.w	r3, #0
 800c22a:	9302      	str	r3, [sp, #8]
 800c22c:	f04f 0300 	mov.w	r3, #0
 800c230:	9303      	str	r3, [sp, #12]
 800c232:	f24c 30bd 	movw	r0, #50109	; 0xc3bd
 800c236:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c23a:	f64d 3110 	movw	r1, #56080	; 0xdb10
 800c23e:	f6c0 0100 	movt	r1, #2048	; 0x800
 800c242:	f44f 7200 	mov.w	r2, #512	; 0x200
 800c246:	f04f 0300 	mov.w	r3, #0
 800c24a:	f7fe ff0b 	bl	800b064 <xTaskGenericCreate>
 800c24e:	9005      	str	r0, [sp, #20]
	}

	configASSERT( xReturn );
	return xReturn;
 800c250:	9d05      	ldr	r5, [sp, #20]
 800c252:	4623      	mov	r3, r4
 800c254:	f24c 10ed 	movw	r0, #49645	; 0xc1ed
 800c258:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c25c:	4619      	mov	r1, r3
 800c25e:	f000 fce1 	bl	800cc24 <__cyg_profile_func_exit>
 800c262:	462b      	mov	r3, r5
}
 800c264:	4618      	mov	r0, r3
 800c266:	b007      	add	sp, #28
 800c268:	bd30      	pop	{r4, r5, pc}
 800c26a:	bf00      	nop

0800c26c <xTimerGenericCommand>:
	return ( xTimerHandle ) pxNewTimer;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
 800c26c:	b530      	push	{r4, r5, lr}
 800c26e:	b089      	sub	sp, #36	; 0x24
 800c270:	4674      	mov	r4, lr
 800c272:	9003      	str	r0, [sp, #12]
 800c274:	9102      	str	r1, [sp, #8]
 800c276:	9201      	str	r2, [sp, #4]
 800c278:	9300      	str	r3, [sp, #0]
 800c27a:	4623      	mov	r3, r4
 800c27c:	f24c 206d 	movw	r0, #49773	; 0xc26d
 800c280:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c284:	4619      	mov	r1, r3
 800c286:	f000 fcbf 	bl	800cc08 <__cyg_profile_func_enter>
portBASE_TYPE xReturn = pdFAIL;
 800c28a:	f04f 0300 	mov.w	r3, #0
 800c28e:	9307      	str	r3, [sp, #28]
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 800c290:	f240 5398 	movw	r3, #1432	; 0x598
 800c294:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c298:	681b      	ldr	r3, [r3, #0]
 800c29a:	2b00      	cmp	r3, #0
 800c29c:	d03a      	beq.n	800c314 <xTimerGenericCommand+0xa8>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 800c29e:	9b02      	ldr	r3, [sp, #8]
 800c2a0:	9304      	str	r3, [sp, #16]
		xMessage.xMessageValue = xOptionalValue;
 800c2a2:	9b01      	ldr	r3, [sp, #4]
 800c2a4:	9305      	str	r3, [sp, #20]
		xMessage.pxTimer = ( xTIMER * ) xTimer;
 800c2a6:	9b03      	ldr	r3, [sp, #12]
 800c2a8:	9306      	str	r3, [sp, #24]

		if( pxHigherPriorityTaskWoken == NULL )
 800c2aa:	9b00      	ldr	r3, [sp, #0]
 800c2ac:	2b00      	cmp	r3, #0
 800c2ae:	d123      	bne.n	800c2f8 <xTimerGenericCommand+0x8c>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 800c2b0:	f7ff fe9a 	bl	800bfe8 <xTaskGetSchedulerState>
 800c2b4:	4603      	mov	r3, r0
 800c2b6:	2b01      	cmp	r3, #1
 800c2b8:	d10e      	bne.n	800c2d8 <xTimerGenericCommand+0x6c>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
 800c2ba:	f240 5398 	movw	r3, #1432	; 0x598
 800c2be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c2c2:	681a      	ldr	r2, [r3, #0]
 800c2c4:	ab04      	add	r3, sp, #16
 800c2c6:	4610      	mov	r0, r2
 800c2c8:	4619      	mov	r1, r3
 800c2ca:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800c2cc:	f04f 0300 	mov.w	r3, #0
 800c2d0:	f7fe fb7a 	bl	800a9c8 <xQueueGenericSend>
 800c2d4:	9007      	str	r0, [sp, #28]
 800c2d6:	e01d      	b.n	800c314 <xTimerGenericCommand+0xa8>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 800c2d8:	f240 5398 	movw	r3, #1432	; 0x598
 800c2dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c2e0:	681a      	ldr	r2, [r3, #0]
 800c2e2:	ab04      	add	r3, sp, #16
 800c2e4:	4610      	mov	r0, r2
 800c2e6:	4619      	mov	r1, r3
 800c2e8:	f04f 0200 	mov.w	r2, #0
 800c2ec:	f04f 0300 	mov.w	r3, #0
 800c2f0:	f7fe fb6a 	bl	800a9c8 <xQueueGenericSend>
 800c2f4:	9007      	str	r0, [sp, #28]
 800c2f6:	e00d      	b.n	800c314 <xTimerGenericCommand+0xa8>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 800c2f8:	f240 5398 	movw	r3, #1432	; 0x598
 800c2fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c300:	681a      	ldr	r2, [r3, #0]
 800c302:	ab04      	add	r3, sp, #16
 800c304:	4610      	mov	r0, r2
 800c306:	4619      	mov	r1, r3
 800c308:	9a00      	ldr	r2, [sp, #0]
 800c30a:	f04f 0300 	mov.w	r3, #0
 800c30e:	f7fe fbf7 	bl	800ab00 <xQueueGenericSendFromISR>
 800c312:	9007      	str	r0, [sp, #28]
		}
		
		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}
	
	return xReturn;
 800c314:	9d07      	ldr	r5, [sp, #28]
 800c316:	4623      	mov	r3, r4
 800c318:	f24c 206d 	movw	r0, #49773	; 0xc26d
 800c31c:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c320:	4619      	mov	r1, r3
 800c322:	f000 fc7f 	bl	800cc24 <__cyg_profile_func_exit>
 800c326:	462b      	mov	r3, r5
}
 800c328:	4618      	mov	r0, r3
 800c32a:	b009      	add	sp, #36	; 0x24
 800c32c:	bd30      	pop	{r4, r5, pc}
 800c32e:	bf00      	nop

0800c330 <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( portTickType xNextExpireTime, portTickType xTimeNow )
{
 800c330:	b510      	push	{r4, lr}
 800c332:	b086      	sub	sp, #24
 800c334:	4674      	mov	r4, lr
 800c336:	9003      	str	r0, [sp, #12]
 800c338:	9102      	str	r1, [sp, #8]
 800c33a:	4623      	mov	r3, r4
 800c33c:	f24c 3031 	movw	r0, #49969	; 0xc331
 800c340:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c344:	4619      	mov	r1, r3
 800c346:	f000 fc5f 	bl	800cc08 <__cyg_profile_func_enter>
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 800c34a:	f240 5390 	movw	r3, #1424	; 0x590
 800c34e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c352:	681b      	ldr	r3, [r3, #0]
 800c354:	68db      	ldr	r3, [r3, #12]
 800c356:	68db      	ldr	r3, [r3, #12]
 800c358:	9305      	str	r3, [sp, #20]
	vListRemove( &( pxTimer->xTimerListItem ) );
 800c35a:	9b05      	ldr	r3, [sp, #20]
 800c35c:	f103 0304 	add.w	r3, r3, #4
 800c360:	4618      	mov	r0, r3
 800c362:	f7fe fa85 	bl	800a870 <vListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 800c366:	9b05      	ldr	r3, [sp, #20]
 800c368:	69db      	ldr	r3, [r3, #28]
 800c36a:	2b01      	cmp	r3, #1
 800c36c:	d118      	bne.n	800c3a0 <prvProcessExpiredTimer+0x70>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
 800c36e:	9b05      	ldr	r3, [sp, #20]
 800c370:	699a      	ldr	r2, [r3, #24]
 800c372:	9b03      	ldr	r3, [sp, #12]
 800c374:	18d3      	adds	r3, r2, r3
 800c376:	9805      	ldr	r0, [sp, #20]
 800c378:	4619      	mov	r1, r3
 800c37a:	9a02      	ldr	r2, [sp, #8]
 800c37c:	9b03      	ldr	r3, [sp, #12]
 800c37e:	f000 f8ef 	bl	800c560 <prvInsertTimerInActiveList>
 800c382:	4603      	mov	r3, r0
 800c384:	2b01      	cmp	r3, #1
 800c386:	d10b      	bne.n	800c3a0 <prvProcessExpiredTimer+0x70>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
 800c388:	f04f 0300 	mov.w	r3, #0
 800c38c:	9300      	str	r3, [sp, #0]
 800c38e:	9805      	ldr	r0, [sp, #20]
 800c390:	f04f 0100 	mov.w	r1, #0
 800c394:	9a03      	ldr	r2, [sp, #12]
 800c396:	f04f 0300 	mov.w	r3, #0
 800c39a:	f7ff ff67 	bl	800c26c <xTimerGenericCommand>
 800c39e:	9004      	str	r0, [sp, #16]
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 800c3a0:	9b05      	ldr	r3, [sp, #20]
 800c3a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c3a4:	9805      	ldr	r0, [sp, #20]
 800c3a6:	4798      	blx	r3
 800c3a8:	4623      	mov	r3, r4
 800c3aa:	f24c 3031 	movw	r0, #49969	; 0xc331
 800c3ae:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c3b2:	4619      	mov	r1, r3
 800c3b4:	f000 fc36 	bl	800cc24 <__cyg_profile_func_exit>
}
 800c3b8:	b006      	add	sp, #24
 800c3ba:	bd10      	pop	{r4, pc}

0800c3bc <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
 800c3bc:	b500      	push	{lr}
 800c3be:	b085      	sub	sp, #20
 800c3c0:	4673      	mov	r3, lr
 800c3c2:	9001      	str	r0, [sp, #4]
 800c3c4:	f24c 30bd 	movw	r0, #50109	; 0xc3bd
 800c3c8:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c3cc:	4619      	mov	r1, r3
 800c3ce:	f000 fc1b 	bl	800cc08 <__cyg_profile_func_enter>

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 800c3d2:	ab02      	add	r3, sp, #8
 800c3d4:	4618      	mov	r0, r3
 800c3d6:	f000 f851 	bl	800c47c <prvGetNextExpireTime>
 800c3da:	9003      	str	r0, [sp, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 800c3dc:	9b02      	ldr	r3, [sp, #8]
 800c3de:	9803      	ldr	r0, [sp, #12]
 800c3e0:	4619      	mov	r1, r3
 800c3e2:	f000 f803 	bl	800c3ec <prvProcessTimerOrBlockTask>
		
		/* Empty the command queue. */
		prvProcessReceivedCommands();		
 800c3e6:	f000 f915 	bl	800c614 <prvProcessReceivedCommands>
	}
 800c3ea:	e7f2      	b.n	800c3d2 <prvTimerTask+0x16>

0800c3ec <prvProcessTimerOrBlockTask>:
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
 800c3ec:	b510      	push	{r4, lr}
 800c3ee:	b084      	sub	sp, #16
 800c3f0:	4674      	mov	r4, lr
 800c3f2:	9001      	str	r0, [sp, #4]
 800c3f4:	9100      	str	r1, [sp, #0]
 800c3f6:	4623      	mov	r3, r4
 800c3f8:	f24c 30ed 	movw	r0, #50157	; 0xc3ed
 800c3fc:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c400:	4619      	mov	r1, r3
 800c402:	f000 fc01 	bl	800cc08 <__cyg_profile_func_enter>
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
 800c406:	f7fe ffbb 	bl	800b380 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 800c40a:	ab02      	add	r3, sp, #8
 800c40c:	4618      	mov	r0, r3
 800c40e:	f000 f86b 	bl	800c4e8 <prvSampleTimeNow>
 800c412:	9003      	str	r0, [sp, #12]
		if( xTimerListsWereSwitched == pdFALSE )
 800c414:	9b02      	ldr	r3, [sp, #8]
 800c416:	2b00      	cmp	r3, #0
 800c418:	d121      	bne.n	800c45e <prvProcessTimerOrBlockTask+0x72>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 800c41a:	9b00      	ldr	r3, [sp, #0]
 800c41c:	2b00      	cmp	r3, #0
 800c41e:	d10a      	bne.n	800c436 <prvProcessTimerOrBlockTask+0x4a>
 800c420:	9a01      	ldr	r2, [sp, #4]
 800c422:	9b03      	ldr	r3, [sp, #12]
 800c424:	429a      	cmp	r2, r3
 800c426:	d806      	bhi.n	800c436 <prvProcessTimerOrBlockTask+0x4a>
			{
				xTaskResumeAll();
 800c428:	f7fe ffca 	bl	800b3c0 <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 800c42c:	9801      	ldr	r0, [sp, #4]
 800c42e:	9903      	ldr	r1, [sp, #12]
 800c430:	f7ff ff7e 	bl	800c330 <prvProcessExpiredTimer>
 800c434:	e017      	b.n	800c466 <prvProcessTimerOrBlockTask+0x7a>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
 800c436:	f240 5398 	movw	r3, #1432	; 0x598
 800c43a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c43e:	681a      	ldr	r2, [r3, #0]
 800c440:	9901      	ldr	r1, [sp, #4]
 800c442:	9b03      	ldr	r3, [sp, #12]
 800c444:	1acb      	subs	r3, r1, r3
 800c446:	4610      	mov	r0, r2
 800c448:	4619      	mov	r1, r3
 800c44a:	f7fe fdcf 	bl	800afec <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
 800c44e:	f7fe ffb7 	bl	800b3c0 <xTaskResumeAll>
 800c452:	4603      	mov	r3, r0
 800c454:	2b00      	cmp	r3, #0
 800c456:	d105      	bne.n	800c464 <prvProcessTimerOrBlockTask+0x78>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
 800c458:	f000 fb14 	bl	800ca84 <vPortYieldFromISR>
 800c45c:	e002      	b.n	800c464 <prvProcessTimerOrBlockTask+0x78>
				}
			}
		}
		else
		{
			xTaskResumeAll();
 800c45e:	f7fe ffaf 	bl	800b3c0 <xTaskResumeAll>
 800c462:	e000      	b.n	800c466 <prvProcessTimerOrBlockTask+0x7a>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
 800c464:	bf00      	nop
				}
			}
		}
		else
		{
			xTaskResumeAll();
 800c466:	4623      	mov	r3, r4
 800c468:	f24c 30ed 	movw	r0, #50157	; 0xc3ed
 800c46c:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c470:	4619      	mov	r1, r3
 800c472:	f000 fbd7 	bl	800cc24 <__cyg_profile_func_exit>
		}
	}
}
 800c476:	b004      	add	sp, #16
 800c478:	bd10      	pop	{r4, pc}
 800c47a:	bf00      	nop

0800c47c <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static portTickType prvGetNextExpireTime( portBASE_TYPE *pxListWasEmpty )
{
 800c47c:	b530      	push	{r4, r5, lr}
 800c47e:	b085      	sub	sp, #20
 800c480:	4674      	mov	r4, lr
 800c482:	9001      	str	r0, [sp, #4]
 800c484:	4623      	mov	r3, r4
 800c486:	f24c 407d 	movw	r0, #50301	; 0xc47d
 800c48a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c48e:	4619      	mov	r1, r3
 800c490:	f000 fbba 	bl	800cc08 <__cyg_profile_func_enter>
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 800c494:	f240 5390 	movw	r3, #1424	; 0x590
 800c498:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c49c:	681b      	ldr	r3, [r3, #0]
 800c49e:	681b      	ldr	r3, [r3, #0]
 800c4a0:	2b00      	cmp	r3, #0
 800c4a2:	bf14      	ite	ne
 800c4a4:	2200      	movne	r2, #0
 800c4a6:	2201      	moveq	r2, #1
 800c4a8:	9b01      	ldr	r3, [sp, #4]
 800c4aa:	601a      	str	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
 800c4ac:	9b01      	ldr	r3, [sp, #4]
 800c4ae:	681b      	ldr	r3, [r3, #0]
 800c4b0:	2b00      	cmp	r3, #0
 800c4b2:	d108      	bne.n	800c4c6 <prvGetNextExpireTime+0x4a>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800c4b4:	f240 5390 	movw	r3, #1424	; 0x590
 800c4b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c4bc:	681b      	ldr	r3, [r3, #0]
 800c4be:	68db      	ldr	r3, [r3, #12]
 800c4c0:	681b      	ldr	r3, [r3, #0]
 800c4c2:	9303      	str	r3, [sp, #12]
 800c4c4:	e002      	b.n	800c4cc <prvGetNextExpireTime+0x50>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
 800c4c6:	f04f 0300 	mov.w	r3, #0
 800c4ca:	9303      	str	r3, [sp, #12]
	}

	return xNextExpireTime;
 800c4cc:	9d03      	ldr	r5, [sp, #12]
 800c4ce:	4623      	mov	r3, r4
 800c4d0:	f24c 407d 	movw	r0, #50301	; 0xc47d
 800c4d4:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c4d8:	4619      	mov	r1, r3
 800c4da:	f000 fba3 	bl	800cc24 <__cyg_profile_func_exit>
 800c4de:	462b      	mov	r3, r5
}
 800c4e0:	4618      	mov	r0, r3
 800c4e2:	b005      	add	sp, #20
 800c4e4:	bd30      	pop	{r4, r5, pc}
 800c4e6:	bf00      	nop

0800c4e8 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
 800c4e8:	b530      	push	{r4, r5, lr}
 800c4ea:	b085      	sub	sp, #20
 800c4ec:	4674      	mov	r4, lr
 800c4ee:	9001      	str	r0, [sp, #4]
 800c4f0:	4623      	mov	r3, r4
 800c4f2:	f24c 40e9 	movw	r0, #50409	; 0xc4e9
 800c4f6:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c4fa:	4619      	mov	r1, r3
 800c4fc:	f000 fb84 	bl	800cc08 <__cyg_profile_func_enter>
portTickType xTimeNow;
static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
 800c500:	f7ff f816 	bl	800b530 <xTaskGetTickCount>
 800c504:	9003      	str	r0, [sp, #12]
	
	if( xTimeNow < xLastTime )
 800c506:	f240 539c 	movw	r3, #1436	; 0x59c
 800c50a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c50e:	681b      	ldr	r3, [r3, #0]
 800c510:	9a03      	ldr	r2, [sp, #12]
 800c512:	429a      	cmp	r2, r3
 800c514:	d20c      	bcs.n	800c530 <prvSampleTimeNow+0x48>
	{
		prvSwitchTimerLists( xLastTime );
 800c516:	f240 539c 	movw	r3, #1436	; 0x59c
 800c51a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c51e:	681b      	ldr	r3, [r3, #0]
 800c520:	4618      	mov	r0, r3
 800c522:	f000 f8fb 	bl	800c71c <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 800c526:	9b01      	ldr	r3, [sp, #4]
 800c528:	f04f 0201 	mov.w	r2, #1
 800c52c:	601a      	str	r2, [r3, #0]
 800c52e:	e003      	b.n	800c538 <prvSampleTimeNow+0x50>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
 800c530:	9b01      	ldr	r3, [sp, #4]
 800c532:	f04f 0200 	mov.w	r2, #0
 800c536:	601a      	str	r2, [r3, #0]
	}
	
	xLastTime = xTimeNow;
 800c538:	f240 539c 	movw	r3, #1436	; 0x59c
 800c53c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c540:	9a03      	ldr	r2, [sp, #12]
 800c542:	601a      	str	r2, [r3, #0]
	
	return xTimeNow;
 800c544:	9d03      	ldr	r5, [sp, #12]
 800c546:	4623      	mov	r3, r4
 800c548:	f24c 40e9 	movw	r0, #50409	; 0xc4e9
 800c54c:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c550:	4619      	mov	r1, r3
 800c552:	f000 fb67 	bl	800cc24 <__cyg_profile_func_exit>
 800c556:	462b      	mov	r3, r5
}
 800c558:	4618      	mov	r0, r3
 800c55a:	b005      	add	sp, #20
 800c55c:	bd30      	pop	{r4, r5, pc}
 800c55e:	bf00      	nop

0800c560 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
 800c560:	b530      	push	{r4, r5, lr}
 800c562:	b087      	sub	sp, #28
 800c564:	4674      	mov	r4, lr
 800c566:	9003      	str	r0, [sp, #12]
 800c568:	9102      	str	r1, [sp, #8]
 800c56a:	9201      	str	r2, [sp, #4]
 800c56c:	9300      	str	r3, [sp, #0]
 800c56e:	4623      	mov	r3, r4
 800c570:	f24c 5061 	movw	r0, #50529	; 0xc561
 800c574:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c578:	4619      	mov	r1, r3
 800c57a:	f000 fb45 	bl	800cc08 <__cyg_profile_func_enter>
portBASE_TYPE xProcessTimerNow = pdFALSE;
 800c57e:	f04f 0300 	mov.w	r3, #0
 800c582:	9305      	str	r3, [sp, #20]

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 800c584:	9b03      	ldr	r3, [sp, #12]
 800c586:	9a02      	ldr	r2, [sp, #8]
 800c588:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 800c58a:	9b03      	ldr	r3, [sp, #12]
 800c58c:	9a03      	ldr	r2, [sp, #12]
 800c58e:	611a      	str	r2, [r3, #16]
	
	if( xNextExpiryTime <= xTimeNow )
 800c590:	9a02      	ldr	r2, [sp, #8]
 800c592:	9b01      	ldr	r3, [sp, #4]
 800c594:	429a      	cmp	r2, r3
 800c596:	d817      	bhi.n	800c5c8 <prvInsertTimerInActiveList+0x68>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
 800c598:	9a01      	ldr	r2, [sp, #4]
 800c59a:	9b00      	ldr	r3, [sp, #0]
 800c59c:	1ad2      	subs	r2, r2, r3
 800c59e:	9b03      	ldr	r3, [sp, #12]
 800c5a0:	699b      	ldr	r3, [r3, #24]
 800c5a2:	429a      	cmp	r2, r3
 800c5a4:	d303      	bcc.n	800c5ae <prvInsertTimerInActiveList+0x4e>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 800c5a6:	f04f 0301 	mov.w	r3, #1
 800c5aa:	9305      	str	r3, [sp, #20]
 800c5ac:	e024      	b.n	800c5f8 <prvInsertTimerInActiveList+0x98>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 800c5ae:	f240 5394 	movw	r3, #1428	; 0x594
 800c5b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c5b6:	681a      	ldr	r2, [r3, #0]
 800c5b8:	9b03      	ldr	r3, [sp, #12]
 800c5ba:	f103 0304 	add.w	r3, r3, #4
 800c5be:	4610      	mov	r0, r2
 800c5c0:	4619      	mov	r1, r3
 800c5c2:	f7fe f90d 	bl	800a7e0 <vListInsert>
 800c5c6:	e017      	b.n	800c5f8 <prvInsertTimerInActiveList+0x98>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 800c5c8:	9a01      	ldr	r2, [sp, #4]
 800c5ca:	9b00      	ldr	r3, [sp, #0]
 800c5cc:	429a      	cmp	r2, r3
 800c5ce:	d207      	bcs.n	800c5e0 <prvInsertTimerInActiveList+0x80>
 800c5d0:	9a02      	ldr	r2, [sp, #8]
 800c5d2:	9b00      	ldr	r3, [sp, #0]
 800c5d4:	429a      	cmp	r2, r3
 800c5d6:	d303      	bcc.n	800c5e0 <prvInsertTimerInActiveList+0x80>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
 800c5d8:	f04f 0301 	mov.w	r3, #1
 800c5dc:	9305      	str	r3, [sp, #20]
 800c5de:	e00b      	b.n	800c5f8 <prvInsertTimerInActiveList+0x98>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800c5e0:	f240 5390 	movw	r3, #1424	; 0x590
 800c5e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c5e8:	681a      	ldr	r2, [r3, #0]
 800c5ea:	9b03      	ldr	r3, [sp, #12]
 800c5ec:	f103 0304 	add.w	r3, r3, #4
 800c5f0:	4610      	mov	r0, r2
 800c5f2:	4619      	mov	r1, r3
 800c5f4:	f7fe f8f4 	bl	800a7e0 <vListInsert>
		}
	}

	return xProcessTimerNow;
 800c5f8:	9d05      	ldr	r5, [sp, #20]
 800c5fa:	4623      	mov	r3, r4
 800c5fc:	f24c 5061 	movw	r0, #50529	; 0xc561
 800c600:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c604:	4619      	mov	r1, r3
 800c606:	f000 fb0d 	bl	800cc24 <__cyg_profile_func_exit>
 800c60a:	462b      	mov	r3, r5
}
 800c60c:	4618      	mov	r0, r3
 800c60e:	b007      	add	sp, #28
 800c610:	bd30      	pop	{r4, r5, pc}
 800c612:	bf00      	nop

0800c614 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
 800c614:	b510      	push	{r4, lr}
 800c616:	b08a      	sub	sp, #40	; 0x28
 800c618:	4674      	mov	r4, lr
 800c61a:	4623      	mov	r3, r4
 800c61c:	f24c 6015 	movw	r0, #50709	; 0xc615
 800c620:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c624:	4619      	mov	r1, r3
 800c626:	f000 faef 	bl	800cc08 <__cyg_profile_func_enter>
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 800c62a:	ab03      	add	r3, sp, #12
 800c62c:	4618      	mov	r0, r3
 800c62e:	f7ff ff5b 	bl	800c4e8 <prvSampleTimeNow>
 800c632:	9009      	str	r0, [sp, #36]	; 0x24

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
 800c634:	e057      	b.n	800c6e6 <prvProcessReceivedCommands+0xd2>
	{
		pxTimer = xMessage.pxTimer;
 800c636:	9b06      	ldr	r3, [sp, #24]
 800c638:	9308      	str	r3, [sp, #32]

		/* Is the timer already in a list of active timers?  When the command
		is trmCOMMAND_PROCESS_TIMER_OVERFLOW, the timer will be NULL as the
		command is to the task rather than to an individual timer. */
		if( pxTimer != NULL )
 800c63a:	9b08      	ldr	r3, [sp, #32]
 800c63c:	2b00      	cmp	r3, #0
 800c63e:	d009      	beq.n	800c654 <prvProcessReceivedCommands+0x40>
		{
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
 800c640:	9b08      	ldr	r3, [sp, #32]
 800c642:	695b      	ldr	r3, [r3, #20]
 800c644:	2b00      	cmp	r3, #0
 800c646:	d005      	beq.n	800c654 <prvProcessReceivedCommands+0x40>
			{
				/* The timer is in a list, remove it. */
				vListRemove( &( pxTimer->xTimerListItem ) );
 800c648:	9b08      	ldr	r3, [sp, #32]
 800c64a:	f103 0304 	add.w	r3, r3, #4
 800c64e:	4618      	mov	r0, r3
 800c650:	f7fe f90e 	bl	800a870 <vListRemove>
			}
		}

		traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.xMessageValue );
		
		switch( xMessage.xMessageID )
 800c654:	9b04      	ldr	r3, [sp, #16]
 800c656:	2b03      	cmp	r3, #3
 800c658:	d842      	bhi.n	800c6e0 <prvProcessReceivedCommands+0xcc>
 800c65a:	a201      	add	r2, pc, #4	; (adr r2, 800c660 <prvProcessReceivedCommands+0x4c>)
 800c65c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c660:	0800c671 	.word	0x0800c671
 800c664:	0800c6e1 	.word	0x0800c6e1
 800c668:	0800c6bd 	.word	0x0800c6bd
 800c66c:	0800c6d9 	.word	0x0800c6d9
		{
			case tmrCOMMAND_START :	
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
 800c670:	9a05      	ldr	r2, [sp, #20]
 800c672:	9b08      	ldr	r3, [sp, #32]
 800c674:	699b      	ldr	r3, [r3, #24]
 800c676:	18d2      	adds	r2, r2, r3
 800c678:	9b05      	ldr	r3, [sp, #20]
 800c67a:	9808      	ldr	r0, [sp, #32]
 800c67c:	4611      	mov	r1, r2
 800c67e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800c680:	f7ff ff6e 	bl	800c560 <prvInsertTimerInActiveList>
 800c684:	4603      	mov	r3, r0
 800c686:	2b01      	cmp	r3, #1
 800c688:	d12c      	bne.n	800c6e4 <prvProcessReceivedCommands+0xd0>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 800c68a:	9b08      	ldr	r3, [sp, #32]
 800c68c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c68e:	9808      	ldr	r0, [sp, #32]
 800c690:	4798      	blx	r3

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 800c692:	9b08      	ldr	r3, [sp, #32]
 800c694:	69db      	ldr	r3, [r3, #28]
 800c696:	2b01      	cmp	r3, #1
 800c698:	d124      	bne.n	800c6e4 <prvProcessReceivedCommands+0xd0>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 800c69a:	9a05      	ldr	r2, [sp, #20]
 800c69c:	9b08      	ldr	r3, [sp, #32]
 800c69e:	699b      	ldr	r3, [r3, #24]
 800c6a0:	18d3      	adds	r3, r2, r3
 800c6a2:	f04f 0200 	mov.w	r2, #0
 800c6a6:	9200      	str	r2, [sp, #0]
 800c6a8:	9808      	ldr	r0, [sp, #32]
 800c6aa:	f04f 0100 	mov.w	r1, #0
 800c6ae:	461a      	mov	r2, r3
 800c6b0:	f04f 0300 	mov.w	r3, #0
 800c6b4:	f7ff fdda 	bl	800c26c <xTimerGenericCommand>
 800c6b8:	9007      	str	r0, [sp, #28]
						configASSERT( xResult );
						( void ) xResult;
					}
				}
				break;
 800c6ba:	e013      	b.n	800c6e4 <prvProcessReceivedCommands+0xd0>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
 800c6bc:	9a05      	ldr	r2, [sp, #20]
 800c6be:	9b08      	ldr	r3, [sp, #32]
 800c6c0:	619a      	str	r2, [r3, #24]
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 800c6c2:	9b08      	ldr	r3, [sp, #32]
 800c6c4:	699a      	ldr	r2, [r3, #24]
 800c6c6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c6c8:	18d3      	adds	r3, r2, r3
 800c6ca:	9808      	ldr	r0, [sp, #32]
 800c6cc:	4619      	mov	r1, r3
 800c6ce:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800c6d0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c6d2:	f7ff ff45 	bl	800c560 <prvInsertTimerInActiveList>
				break;
 800c6d6:	e006      	b.n	800c6e6 <prvProcessReceivedCommands+0xd2>

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
 800c6d8:	9808      	ldr	r0, [sp, #32]
 800c6da:	f001 f837 	bl	800d74c <vPortFree>
				break;
 800c6de:	e002      	b.n	800c6e6 <prvProcessReceivedCommands+0xd2>

			default	:			
				/* Don't expect to get here. */
				break;
 800c6e0:	bf00      	nop
 800c6e2:	e000      	b.n	800c6e6 <prvProcessReceivedCommands+0xd2>
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
						configASSERT( xResult );
						( void ) xResult;
					}
				}
				break;
 800c6e4:	bf00      	nop

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
 800c6e6:	f240 5398 	movw	r3, #1432	; 0x598
 800c6ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c6ee:	681a      	ldr	r2, [r3, #0]
 800c6f0:	ab04      	add	r3, sp, #16
 800c6f2:	4610      	mov	r0, r2
 800c6f4:	4619      	mov	r1, r3
 800c6f6:	f04f 0200 	mov.w	r2, #0
 800c6fa:	f04f 0300 	mov.w	r3, #0
 800c6fe:	f7fe fa55 	bl	800abac <xQueueGenericReceive>
 800c702:	4603      	mov	r3, r0
 800c704:	2b00      	cmp	r3, #0
 800c706:	d196      	bne.n	800c636 <prvProcessReceivedCommands+0x22>
 800c708:	4623      	mov	r3, r4
 800c70a:	f24c 6015 	movw	r0, #50709	; 0xc615
 800c70e:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c712:	4619      	mov	r1, r3
 800c714:	f000 fa86 	bl	800cc24 <__cyg_profile_func_exit>
			default	:			
				/* Don't expect to get here. */
				break;
		}
	}
}
 800c718:	b00a      	add	sp, #40	; 0x28
 800c71a:	bd10      	pop	{r4, pc}

0800c71c <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( portTickType xLastTime )
{
 800c71c:	b510      	push	{r4, lr}
 800c71e:	b08a      	sub	sp, #40	; 0x28
 800c720:	4674      	mov	r4, lr
 800c722:	9003      	str	r0, [sp, #12]
 800c724:	4623      	mov	r3, r4
 800c726:	f24c 701d 	movw	r0, #50973	; 0xc71d
 800c72a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c72e:	4619      	mov	r1, r3
 800c730:	f000 fa6a 	bl	800cc08 <__cyg_profile_func_enter>
	
	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 800c734:	e045      	b.n	800c7c2 <prvSwitchTimerLists+0xa6>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800c736:	f240 5390 	movw	r3, #1424	; 0x590
 800c73a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c73e:	681b      	ldr	r3, [r3, #0]
 800c740:	68db      	ldr	r3, [r3, #12]
 800c742:	681b      	ldr	r3, [r3, #0]
 800c744:	9309      	str	r3, [sp, #36]	; 0x24

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 800c746:	f240 5390 	movw	r3, #1424	; 0x590
 800c74a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c74e:	681b      	ldr	r3, [r3, #0]
 800c750:	68db      	ldr	r3, [r3, #12]
 800c752:	68db      	ldr	r3, [r3, #12]
 800c754:	9308      	str	r3, [sp, #32]
		vListRemove( &( pxTimer->xTimerListItem ) );
 800c756:	9b08      	ldr	r3, [sp, #32]
 800c758:	f103 0304 	add.w	r3, r3, #4
 800c75c:	4618      	mov	r0, r3
 800c75e:	f7fe f887 	bl	800a870 <vListRemove>

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 800c762:	9b08      	ldr	r3, [sp, #32]
 800c764:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c766:	9808      	ldr	r0, [sp, #32]
 800c768:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 800c76a:	9b08      	ldr	r3, [sp, #32]
 800c76c:	69db      	ldr	r3, [r3, #28]
 800c76e:	2b01      	cmp	r3, #1
 800c770:	d127      	bne.n	800c7c2 <prvSwitchTimerLists+0xa6>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 800c772:	9b08      	ldr	r3, [sp, #32]
 800c774:	699a      	ldr	r2, [r3, #24]
 800c776:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c778:	18d3      	adds	r3, r2, r3
 800c77a:	9307      	str	r3, [sp, #28]
			if( xReloadTime > xNextExpireTime )
 800c77c:	9a07      	ldr	r2, [sp, #28]
 800c77e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c780:	429a      	cmp	r2, r3
 800c782:	d912      	bls.n	800c7aa <prvSwitchTimerLists+0x8e>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 800c784:	9b08      	ldr	r3, [sp, #32]
 800c786:	9a07      	ldr	r2, [sp, #28]
 800c788:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 800c78a:	9b08      	ldr	r3, [sp, #32]
 800c78c:	9a08      	ldr	r2, [sp, #32]
 800c78e:	611a      	str	r2, [r3, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800c790:	f240 5390 	movw	r3, #1424	; 0x590
 800c794:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c798:	681a      	ldr	r2, [r3, #0]
 800c79a:	9b08      	ldr	r3, [sp, #32]
 800c79c:	f103 0304 	add.w	r3, r3, #4
 800c7a0:	4610      	mov	r0, r2
 800c7a2:	4619      	mov	r1, r3
 800c7a4:	f7fe f81c 	bl	800a7e0 <vListInsert>
 800c7a8:	e00b      	b.n	800c7c2 <prvSwitchTimerLists+0xa6>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
 800c7aa:	f04f 0300 	mov.w	r3, #0
 800c7ae:	9300      	str	r3, [sp, #0]
 800c7b0:	9808      	ldr	r0, [sp, #32]
 800c7b2:	f04f 0100 	mov.w	r1, #0
 800c7b6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800c7b8:	f04f 0300 	mov.w	r3, #0
 800c7bc:	f7ff fd56 	bl	800c26c <xTimerGenericCommand>
 800c7c0:	9006      	str	r0, [sp, #24]
	
	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 800c7c2:	f240 5390 	movw	r3, #1424	; 0x590
 800c7c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c7ca:	681b      	ldr	r3, [r3, #0]
 800c7cc:	681b      	ldr	r3, [r3, #0]
 800c7ce:	2b00      	cmp	r3, #0
 800c7d0:	d1b1      	bne.n	800c736 <prvSwitchTimerLists+0x1a>
				( void ) xResult;
			}
		}
	}

	pxTemp = pxCurrentTimerList;
 800c7d2:	f240 5390 	movw	r3, #1424	; 0x590
 800c7d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c7da:	681b      	ldr	r3, [r3, #0]
 800c7dc:	9305      	str	r3, [sp, #20]
	pxCurrentTimerList = pxOverflowTimerList;
 800c7de:	f240 5394 	movw	r3, #1428	; 0x594
 800c7e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c7e6:	681a      	ldr	r2, [r3, #0]
 800c7e8:	f240 5390 	movw	r3, #1424	; 0x590
 800c7ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c7f0:	601a      	str	r2, [r3, #0]
	pxOverflowTimerList = pxTemp;
 800c7f2:	f240 5394 	movw	r3, #1428	; 0x594
 800c7f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c7fa:	9a05      	ldr	r2, [sp, #20]
 800c7fc:	601a      	str	r2, [r3, #0]
 800c7fe:	4623      	mov	r3, r4
 800c800:	f24c 701d 	movw	r0, #50973	; 0xc71d
 800c804:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c808:	4619      	mov	r1, r3
 800c80a:	f000 fa0b 	bl	800cc24 <__cyg_profile_func_exit>
}
 800c80e:	b00a      	add	sp, #40	; 0x28
 800c810:	bd10      	pop	{r4, pc}
 800c812:	bf00      	nop

0800c814 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 800c814:	b510      	push	{r4, lr}
 800c816:	4674      	mov	r4, lr
 800c818:	4623      	mov	r3, r4
 800c81a:	f64c 0015 	movw	r0, #51221	; 0xc815
 800c81e:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c822:	4619      	mov	r1, r3
 800c824:	f000 f9f0 	bl	800cc08 <__cyg_profile_func_enter>
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 800c828:	f000 f946 	bl	800cab8 <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 800c82c:	f240 5398 	movw	r3, #1432	; 0x598
 800c830:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c834:	681b      	ldr	r3, [r3, #0]
 800c836:	2b00      	cmp	r3, #0
 800c838:	d129      	bne.n	800c88e <prvCheckForValidListAndQueue+0x7a>
		{
			vListInitialise( &xActiveTimerList1 );
 800c83a:	f240 5068 	movw	r0, #1384	; 0x568
 800c83e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800c842:	f7fd ff4f 	bl	800a6e4 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 800c846:	f240 507c 	movw	r0, #1404	; 0x57c
 800c84a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800c84e:	f7fd ff49 	bl	800a6e4 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 800c852:	f240 5390 	movw	r3, #1424	; 0x590
 800c856:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c85a:	f240 5268 	movw	r2, #1384	; 0x568
 800c85e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800c862:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
 800c864:	f240 5394 	movw	r3, #1428	; 0x594
 800c868:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c86c:	f240 527c 	movw	r2, #1404	; 0x57c
 800c870:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800c874:	601a      	str	r2, [r3, #0]
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
 800c876:	f04f 000a 	mov.w	r0, #10
 800c87a:	f04f 010c 	mov.w	r1, #12
 800c87e:	f7fe f82d 	bl	800a8dc <xQueueCreate>
 800c882:	4602      	mov	r2, r0
 800c884:	f240 5398 	movw	r3, #1432	; 0x598
 800c888:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c88c:	601a      	str	r2, [r3, #0]
		}
	}
	taskEXIT_CRITICAL();
 800c88e:	f000 f937 	bl	800cb00 <vPortExitCritical>
 800c892:	4623      	mov	r3, r4
 800c894:	f64c 0015 	movw	r0, #51221	; 0xc815
 800c898:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c89c:	4619      	mov	r1, r3
 800c89e:	f000 f9c1 	bl	800cc24 <__cyg_profile_func_exit>
}
 800c8a2:	bd10      	pop	{r4, pc}

0800c8a4 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, portSTACK_TYPE *pxStartOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
 800c8a4:	b530      	push	{r4, r5, lr}
 800c8a6:	b085      	sub	sp, #20
 800c8a8:	4674      	mov	r4, lr
 800c8aa:	9003      	str	r0, [sp, #12]
 800c8ac:	9102      	str	r1, [sp, #8]
 800c8ae:	9201      	str	r2, [sp, #4]
 800c8b0:	9300      	str	r3, [sp, #0]
 800c8b2:	4623      	mov	r3, r4
 800c8b4:	f64c 00a5 	movw	r0, #51365	; 0xc8a5
 800c8b8:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c8bc:	4619      	mov	r1, r3
 800c8be:	f000 f9a3 	bl	800cc08 <__cyg_profile_func_enter>
	/* Simulate the stack frame as it would be created by a context switch interrupt. */
	/* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*--pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800c8c2:	9b03      	ldr	r3, [sp, #12]
 800c8c4:	f1a3 0304 	sub.w	r3, r3, #4
 800c8c8:	9303      	str	r3, [sp, #12]
 800c8ca:	9b03      	ldr	r3, [sp, #12]
 800c8cc:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800c8d0:	601a      	str	r2, [r3, #0]
	*--pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
 800c8d2:	9b03      	ldr	r3, [sp, #12]
 800c8d4:	f1a3 0304 	sub.w	r3, r3, #4
 800c8d8:	9303      	str	r3, [sp, #12]
 800c8da:	9a01      	ldr	r2, [sp, #4]
 800c8dc:	9b03      	ldr	r3, [sp, #12]
 800c8de:	601a      	str	r2, [r3, #0]
	*--pxTopOfStack = 0;	/* LR */
 800c8e0:	9b03      	ldr	r3, [sp, #12]
 800c8e2:	f1a3 0304 	sub.w	r3, r3, #4
 800c8e6:	9303      	str	r3, [sp, #12]
 800c8e8:	9b03      	ldr	r3, [sp, #12]
 800c8ea:	f04f 0200 	mov.w	r2, #0
 800c8ee:	601a      	str	r2, [r3, #0]
	*--pxTopOfStack = 0;	/* R12 */
 800c8f0:	9b03      	ldr	r3, [sp, #12]
 800c8f2:	f1a3 0304 	sub.w	r3, r3, #4
 800c8f6:	9303      	str	r3, [sp, #12]
 800c8f8:	9b03      	ldr	r3, [sp, #12]
 800c8fa:	f04f 0200 	mov.w	r2, #0
 800c8fe:	601a      	str	r2, [r3, #0]
	*--pxTopOfStack = 0;	/* R3 */
 800c900:	9b03      	ldr	r3, [sp, #12]
 800c902:	f1a3 0304 	sub.w	r3, r3, #4
 800c906:	9303      	str	r3, [sp, #12]
 800c908:	9b03      	ldr	r3, [sp, #12]
 800c90a:	f04f 0200 	mov.w	r2, #0
 800c90e:	601a      	str	r2, [r3, #0]
	*--pxTopOfStack = 0;	/* R2 */
 800c910:	9b03      	ldr	r3, [sp, #12]
 800c912:	f1a3 0304 	sub.w	r3, r3, #4
 800c916:	9303      	str	r3, [sp, #12]
 800c918:	9b03      	ldr	r3, [sp, #12]
 800c91a:	f04f 0200 	mov.w	r2, #0
 800c91e:	601a      	str	r2, [r3, #0]
	*--pxTopOfStack = 0;	/* R1 */
 800c920:	9b03      	ldr	r3, [sp, #12]
 800c922:	f1a3 0304 	sub.w	r3, r3, #4
 800c926:	9303      	str	r3, [sp, #12]
 800c928:	9b03      	ldr	r3, [sp, #12]
 800c92a:	f04f 0200 	mov.w	r2, #0
 800c92e:	601a      	str	r2, [r3, #0]
	*--pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
 800c930:	9b03      	ldr	r3, [sp, #12]
 800c932:	f1a3 0304 	sub.w	r3, r3, #4
 800c936:	9303      	str	r3, [sp, #12]
 800c938:	9a00      	ldr	r2, [sp, #0]
 800c93a:	9b03      	ldr	r3, [sp, #12]
 800c93c:	601a      	str	r2, [r3, #0]
	*--pxTopOfStack = 0;	/* R11 */
 800c93e:	9b03      	ldr	r3, [sp, #12]
 800c940:	f1a3 0304 	sub.w	r3, r3, #4
 800c944:	9303      	str	r3, [sp, #12]
 800c946:	9b03      	ldr	r3, [sp, #12]
 800c948:	f04f 0200 	mov.w	r2, #0
 800c94c:	601a      	str	r2, [r3, #0]
	*--pxTopOfStack = ( portSTACK_TYPE ) pxStartOfStack + 64; /* R10 with room for a full context save */
 800c94e:	9b03      	ldr	r3, [sp, #12]
 800c950:	f1a3 0304 	sub.w	r3, r3, #4
 800c954:	9303      	str	r3, [sp, #12]
 800c956:	9b02      	ldr	r3, [sp, #8]
 800c958:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800c95c:	9b03      	ldr	r3, [sp, #12]
 800c95e:	601a      	str	r2, [r3, #0]
	*--pxTopOfStack = 0;	/* R9 */
 800c960:	9b03      	ldr	r3, [sp, #12]
 800c962:	f1a3 0304 	sub.w	r3, r3, #4
 800c966:	9303      	str	r3, [sp, #12]
 800c968:	9b03      	ldr	r3, [sp, #12]
 800c96a:	f04f 0200 	mov.w	r2, #0
 800c96e:	601a      	str	r2, [r3, #0]
	*--pxTopOfStack = 0;	/* R8 */
 800c970:	9b03      	ldr	r3, [sp, #12]
 800c972:	f1a3 0304 	sub.w	r3, r3, #4
 800c976:	9303      	str	r3, [sp, #12]
 800c978:	9b03      	ldr	r3, [sp, #12]
 800c97a:	f04f 0200 	mov.w	r2, #0
 800c97e:	601a      	str	r2, [r3, #0]
	*--pxTopOfStack = 0;	/* R7 */
 800c980:	9b03      	ldr	r3, [sp, #12]
 800c982:	f1a3 0304 	sub.w	r3, r3, #4
 800c986:	9303      	str	r3, [sp, #12]
 800c988:	9b03      	ldr	r3, [sp, #12]
 800c98a:	f04f 0200 	mov.w	r2, #0
 800c98e:	601a      	str	r2, [r3, #0]
	*--pxTopOfStack = 0;	/* R6 */
 800c990:	9b03      	ldr	r3, [sp, #12]
 800c992:	f1a3 0304 	sub.w	r3, r3, #4
 800c996:	9303      	str	r3, [sp, #12]
 800c998:	9b03      	ldr	r3, [sp, #12]
 800c99a:	f04f 0200 	mov.w	r2, #0
 800c99e:	601a      	str	r2, [r3, #0]
	*--pxTopOfStack = 0;	/* R5 */
 800c9a0:	9b03      	ldr	r3, [sp, #12]
 800c9a2:	f1a3 0304 	sub.w	r3, r3, #4
 800c9a6:	9303      	str	r3, [sp, #12]
 800c9a8:	9b03      	ldr	r3, [sp, #12]
 800c9aa:	f04f 0200 	mov.w	r2, #0
 800c9ae:	601a      	str	r2, [r3, #0]
	*--pxTopOfStack = 0;	/* R4 */
 800c9b0:	9b03      	ldr	r3, [sp, #12]
 800c9b2:	f1a3 0304 	sub.w	r3, r3, #4
 800c9b6:	9303      	str	r3, [sp, #12]
 800c9b8:	9b03      	ldr	r3, [sp, #12]
 800c9ba:	f04f 0200 	mov.w	r2, #0
 800c9be:	601a      	str	r2, [r3, #0]

	return pxTopOfStack;
 800c9c0:	9d03      	ldr	r5, [sp, #12]
 800c9c2:	4623      	mov	r3, r4
 800c9c4:	f64c 00a5 	movw	r0, #51365	; 0xc8a5
 800c9c8:	f6c0 0000 	movt	r0, #2048	; 0x800
 800c9cc:	4619      	mov	r1, r3
 800c9ce:	f000 f929 	bl	800cc24 <__cyg_profile_func_exit>
 800c9d2:	462b      	mov	r3, r5
}
 800c9d4:	4618      	mov	r0, r3
 800c9d6:	b005      	add	sp, #20
 800c9d8:	bd30      	pop	{r4, r5, pc}
 800c9da:	bf00      	nop

0800c9dc <vPortSVCHandler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 800c9dc:	4b06      	ldr	r3, [pc, #24]	; (800c9f8 <pxCurrentTCBConst2>)
 800c9de:	6819      	ldr	r1, [r3, #0]
 800c9e0:	6808      	ldr	r0, [r1, #0]
 800c9e2:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800c9e6:	f380 8809 	msr	PSP, r0
 800c9ea:	f04f 0000 	mov.w	r0, #0
 800c9ee:	f380 8811 	msr	BASEPRI, r0
 800c9f2:	f04e 0e0d 	orr.w	lr, lr, #13
 800c9f6:	4770      	bx	lr

0800c9f8 <pxCurrentTCBConst2>:
 800c9f8:	20000464 	.word	0x20000464

0800c9fc <vPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

void vPortStartFirstTask( void )
{
	__asm volatile(
 800c9fc:	4803      	ldr	r0, [pc, #12]	; (800ca0c <vPortStartFirstTask+0x10>)
 800c9fe:	6800      	ldr	r0, [r0, #0]
 800ca00:	6800      	ldr	r0, [r0, #0]
 800ca02:	f380 8808 	msr	MSP, r0
 800ca06:	b662      	cpsie	i
 800ca08:	df00      	.short	0xdf00
 800ca0a:	bf00      	nop
 800ca0c:	e000ed08 	.word	0xe000ed08

0800ca10 <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
 800ca10:	b538      	push	{r3, r4, r5, lr}
 800ca12:	4674      	mov	r4, lr
 800ca14:	4623      	mov	r3, r4
 800ca16:	f64c 2011 	movw	r0, #51729	; 0xca11
 800ca1a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800ca1e:	4619      	mov	r1, r3
 800ca20:	f000 f8f2 	bl	800cc08 <__cyg_profile_func_enter>
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 800ca24:	f64e 5320 	movw	r3, #60704	; 0xed20
 800ca28:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800ca2c:	f64e 5220 	movw	r2, #60704	; 0xed20
 800ca30:	f2ce 0200 	movt	r2, #57344	; 0xe000
 800ca34:	6812      	ldr	r2, [r2, #0]
 800ca36:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 800ca3a:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 800ca3c:	f64e 5320 	movw	r3, #60704	; 0xed20
 800ca40:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800ca44:	f64e 5220 	movw	r2, #60704	; 0xed20
 800ca48:	f2ce 0200 	movt	r2, #57344	; 0xe000
 800ca4c:	6812      	ldr	r2, [r2, #0]
 800ca4e:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 800ca52:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 800ca54:	f000 f8b4 	bl	800cbc0 <prvSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 800ca58:	f240 4334 	movw	r3, #1076	; 0x434
 800ca5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ca60:	f04f 0200 	mov.w	r2, #0
 800ca64:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
 800ca66:	f7ff ffc9 	bl	800c9fc <vPortStartFirstTask>

	/* Should not get here! */
	return 0;
 800ca6a:	f04f 0500 	mov.w	r5, #0
 800ca6e:	4623      	mov	r3, r4
 800ca70:	f64c 2011 	movw	r0, #51729	; 0xca11
 800ca74:	f6c0 0000 	movt	r0, #2048	; 0x800
 800ca78:	4619      	mov	r1, r3
 800ca7a:	f000 f8d3 	bl	800cc24 <__cyg_profile_func_exit>
 800ca7e:	462b      	mov	r3, r5
}
 800ca80:	4618      	mov	r0, r3
 800ca82:	bd38      	pop	{r3, r4, r5, pc}

0800ca84 <vPortYieldFromISR>:
	is nothing to return to.  */
}
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
 800ca84:	b510      	push	{r4, lr}
 800ca86:	4674      	mov	r4, lr
 800ca88:	4623      	mov	r3, r4
 800ca8a:	f64c 2085 	movw	r0, #51845	; 0xca85
 800ca8e:	f6c0 0000 	movt	r0, #2048	; 0x800
 800ca92:	4619      	mov	r1, r3
 800ca94:	f000 f8b8 	bl	800cc08 <__cyg_profile_func_enter>
	/* Set a PendSV to request a context switch. */
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 800ca98:	f64e 5304 	movw	r3, #60676	; 0xed04
 800ca9c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800caa0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800caa4:	601a      	str	r2, [r3, #0]
 800caa6:	4623      	mov	r3, r4
 800caa8:	f64c 2085 	movw	r0, #51845	; 0xca85
 800caac:	f6c0 0000 	movt	r0, #2048	; 0x800
 800cab0:	4619      	mov	r1, r3
 800cab2:	f000 f8b7 	bl	800cc24 <__cyg_profile_func_exit>
}
 800cab6:	bd10      	pop	{r4, pc}

0800cab8 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 800cab8:	b510      	push	{r4, lr}
 800caba:	4674      	mov	r4, lr
 800cabc:	4623      	mov	r3, r4
 800cabe:	f64c 20b9 	movw	r0, #51897	; 0xcab9
 800cac2:	f6c0 0000 	movt	r0, #2048	; 0x800
 800cac6:	4619      	mov	r1, r3
 800cac8:	f000 f89e 	bl	800cc08 <__cyg_profile_func_enter>
	portDISABLE_INTERRUPTS();
 800cacc:	f04f 0030 	mov.w	r0, #48	; 0x30
 800cad0:	f380 8811 	msr	BASEPRI, r0
	uxCriticalNesting++;
 800cad4:	f240 4334 	movw	r3, #1076	; 0x434
 800cad8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cadc:	681b      	ldr	r3, [r3, #0]
 800cade:	f103 0201 	add.w	r2, r3, #1
 800cae2:	f240 4334 	movw	r3, #1076	; 0x434
 800cae6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800caea:	601a      	str	r2, [r3, #0]
 800caec:	4623      	mov	r3, r4
 800caee:	f64c 20b9 	movw	r0, #51897	; 0xcab9
 800caf2:	f6c0 0000 	movt	r0, #2048	; 0x800
 800caf6:	4619      	mov	r1, r3
 800caf8:	f000 f894 	bl	800cc24 <__cyg_profile_func_exit>
}
 800cafc:	bd10      	pop	{r4, pc}
 800cafe:	bf00      	nop

0800cb00 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 800cb00:	b510      	push	{r4, lr}
 800cb02:	4674      	mov	r4, lr
 800cb04:	4623      	mov	r3, r4
 800cb06:	f64c 3001 	movw	r0, #51969	; 0xcb01
 800cb0a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800cb0e:	4619      	mov	r1, r3
 800cb10:	f000 f87a 	bl	800cc08 <__cyg_profile_func_enter>
	uxCriticalNesting--;
 800cb14:	f240 4334 	movw	r3, #1076	; 0x434
 800cb18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cb1c:	681b      	ldr	r3, [r3, #0]
 800cb1e:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 800cb22:	f240 4334 	movw	r3, #1076	; 0x434
 800cb26:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cb2a:	601a      	str	r2, [r3, #0]
	if( uxCriticalNesting == 0 )
 800cb2c:	f240 4334 	movw	r3, #1076	; 0x434
 800cb30:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cb34:	681b      	ldr	r3, [r3, #0]
 800cb36:	2b00      	cmp	r3, #0
 800cb38:	d103      	bne.n	800cb42 <vPortExitCritical+0x42>
	{
		portENABLE_INTERRUPTS();
 800cb3a:	f04f 0000 	mov.w	r0, #0
 800cb3e:	f380 8811 	msr	BASEPRI, r0
 800cb42:	4623      	mov	r3, r4
 800cb44:	f64c 3001 	movw	r0, #51969	; 0xcb01
 800cb48:	f6c0 0000 	movt	r0, #2048	; 0x800
 800cb4c:	4619      	mov	r1, r3
 800cb4e:	f000 f869 	bl	800cc24 <__cyg_profile_func_exit>
	}
}
 800cb52:	bd10      	pop	{r4, pc}

0800cb54 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 800cb54:	f3ef 8009 	mrs	r0, PSP
 800cb58:	4b0c      	ldr	r3, [pc, #48]	; (800cb8c <pxCurrentTCBConst>)
 800cb5a:	681a      	ldr	r2, [r3, #0]
 800cb5c:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800cb60:	6010      	str	r0, [r2, #0]
 800cb62:	e92d 4008 	stmdb	sp!, {r3, lr}
 800cb66:	f04f 0030 	mov.w	r0, #48	; 0x30
 800cb6a:	f380 8811 	msr	BASEPRI, r0
 800cb6e:	f7fe fdeb 	bl	800b748 <vTaskSwitchContext>
 800cb72:	f04f 0000 	mov.w	r0, #0
 800cb76:	f380 8811 	msr	BASEPRI, r0
 800cb7a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800cb7e:	6819      	ldr	r1, [r3, #0]
 800cb80:	6808      	ldr	r0, [r1, #0]
 800cb82:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800cb86:	f380 8809 	msr	PSP, r0
 800cb8a:	4770      	bx	lr

0800cb8c <pxCurrentTCBConst>:
 800cb8c:	20000464 	.word	0x20000464

0800cb90 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 800cb90:	b500      	push	{lr}
 800cb92:	b083      	sub	sp, #12
unsigned long ulDummy;

	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 800cb94:	f64e 5304 	movw	r3, #60676	; 0xed04
 800cb98:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800cb9c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800cba0:	601a      	str	r2, [r3, #0]
	#endif

	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
 800cba2:	f04f 0300 	mov.w	r3, #0
 800cba6:	9301      	str	r3, [sp, #4]
 800cba8:	f04f 0030 	mov.w	r0, #48	; 0x30
 800cbac:	f380 8811 	msr	BASEPRI, r0
	{
		vTaskIncrementTick();
 800cbb0:	f7fe fce0 	bl	800b574 <vTaskIncrementTick>
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
 800cbb4:	f04f 0000 	mov.w	r0, #0
 800cbb8:	f380 8811 	msr	BASEPRI, r0
}
 800cbbc:	b003      	add	sp, #12
 800cbbe:	bd00      	pop	{pc}

0800cbc0 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 800cbc0:	b510      	push	{r4, lr}
 800cbc2:	4674      	mov	r4, lr
 800cbc4:	4623      	mov	r3, r4
 800cbc6:	f64c 30c1 	movw	r0, #52161	; 0xcbc1
 800cbca:	f6c0 0000 	movt	r0, #2048	; 0x800
 800cbce:	4619      	mov	r1, r3
 800cbd0:	f000 f81a 	bl	800cc08 <__cyg_profile_func_enter>
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800cbd4:	f24e 0314 	movw	r3, #57364	; 0xe014
 800cbd8:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800cbdc:	f249 023f 	movw	r2, #36927	; 0x903f
 800cbe0:	f2c0 0202 	movt	r2, #2
 800cbe4:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 800cbe6:	f24e 0310 	movw	r3, #57360	; 0xe010
 800cbea:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800cbee:	f04f 0207 	mov.w	r2, #7
 800cbf2:	601a      	str	r2, [r3, #0]
 800cbf4:	4623      	mov	r3, r4
 800cbf6:	f64c 30c1 	movw	r0, #52161	; 0xcbc1
 800cbfa:	f6c0 0000 	movt	r0, #2048	; 0x800
 800cbfe:	4619      	mov	r1, r3
 800cc00:	f000 f810 	bl	800cc24 <__cyg_profile_func_exit>
}
 800cc04:	bd10      	pop	{r4, pc}
 800cc06:	bf00      	nop

0800cc08 <__cyg_profile_func_enter>:
void	__cyg_profile_func_exit(void *func, void *caller)  __attribute__((naked, no_instrument_function));

void
__cyg_profile_func_enter(void *func, void *caller)
{
    asm volatile (
 800cc08:	f3ef 8205 	mrs	r2, IPSR
 800cc0c:	2a00      	cmp	r2, #0
 800cc0e:	d107      	bne.n	800cc20 <L__out>
 800cc10:	45d5      	cmp	sp, sl
 800cc12:	dc05      	bgt.n	800cc20 <L__out>
 800cc14:	f04f 02ac 	mov.w	r2, #172	; 0xac
 800cc18:	f502 42ae 	add.w	r2, r2, #22272	; 0x5700
 800cc1c:	6812      	ldr	r2, [r2, #0]
 800cc1e:	e7fe      	b.n	800cc1e <__cyg_profile_func_enter+0x16>

0800cc20 <L__out>:
 800cc20:	4770      	bx	lr
 800cc22:	bf00      	nop

0800cc24 <__cyg_profile_func_exit>:
}

void
__cyg_profile_func_exit(void *func, void *caller)
{
	asm volatile("bx lr");
 800cc24:	4770      	bx	lr
 800cc26:	bf00      	nop

0800cc28 <msheap_init>:
 * @param   base        The lower boundary of the heap.
 * @param   limit       The upper boundary of the heap.
 */
void
msheap_init(void *base, void *limit)
{
 800cc28:	b510      	push	{r4, lr}
 800cc2a:	b084      	sub	sp, #16
 800cc2c:	4674      	mov	r4, lr
 800cc2e:	9001      	str	r0, [sp, #4]
 800cc30:	9100      	str	r1, [sp, #0]
 800cc32:	4623      	mov	r3, r4
 800cc34:	f64c 4029 	movw	r0, #52265	; 0xcc29
 800cc38:	f6c0 0000 	movt	r0, #2048	; 0x800
 800cc3c:	4619      	mov	r1, r3
 800cc3e:	f7ff ffe3 	bl	800cc08 <__cyg_profile_func_enter>
    heap_base = (marker_t)round_up((uintptr_t)base, marker_size);
 800cc42:	9a01      	ldr	r2, [sp, #4]
 800cc44:	f64d 331c 	movw	r3, #56092	; 0xdb1c
 800cc48:	f6c0 0300 	movt	r3, #2048	; 0x800
 800cc4c:	681b      	ldr	r3, [r3, #0]
 800cc4e:	18d3      	adds	r3, r2, r3
 800cc50:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 800cc54:	f64d 331c 	movw	r3, #56092	; 0xdb1c
 800cc58:	f6c0 0300 	movt	r3, #2048	; 0x800
 800cc5c:	681b      	ldr	r3, [r3, #0]
 800cc5e:	f1c3 0300 	rsb	r3, r3, #0
 800cc62:	4013      	ands	r3, r2
 800cc64:	461a      	mov	r2, r3
 800cc66:	f240 53a0 	movw	r3, #1440	; 0x5a0
 800cc6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cc6e:	601a      	str	r2, [r3, #0]
    heap_limit = (marker_t)round_down((uintptr_t)limit, marker_size) - 1;
 800cc70:	f64d 331c 	movw	r3, #56092	; 0xdb1c
 800cc74:	f6c0 0300 	movt	r3, #2048	; 0x800
 800cc78:	681b      	ldr	r3, [r3, #0]
 800cc7a:	f1c3 0200 	rsb	r2, r3, #0
 800cc7e:	9b00      	ldr	r3, [sp, #0]
 800cc80:	4013      	ands	r3, r2
 800cc82:	f1a3 0304 	sub.w	r3, r3, #4
 800cc86:	461a      	mov	r2, r3
 800cc88:	f240 53a4 	movw	r3, #1444	; 0x5a4
 800cc8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cc90:	601a      	str	r2, [r3, #0]
    ASSERT(3, heap_base);               /* must not be NULL */
    ASSERT(3, heap_limit);              /* must not be NULL */
    ASSERT(3, heap_limit > heap_base);  /* limit must be above base */

    /* Initial size of the free region (includes the heap_base marker) */
    heap_free = heap_limit - heap_base;
 800cc92:	f240 53a4 	movw	r3, #1444	; 0x5a4
 800cc96:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cc9a:	681b      	ldr	r3, [r3, #0]
 800cc9c:	461a      	mov	r2, r3
 800cc9e:	f240 53a0 	movw	r3, #1440	; 0x5a0
 800cca2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cca6:	681b      	ldr	r3, [r3, #0]
 800cca8:	1ad3      	subs	r3, r2, r3
 800ccaa:	ea4f 03a3 	mov.w	r3, r3, asr #2
 800ccae:	461a      	mov	r2, r3
 800ccb0:	f240 53a8 	movw	r3, #1448	; 0x5a8
 800ccb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ccb8:	601a      	str	r2, [r3, #0]
    ASSERT(0, heap_free <= max_free);   /* heap must not be too large */
 800ccba:	f04f 0300 	mov.w	r3, #0
 800ccbe:	9303      	str	r3, [sp, #12]
 800ccc0:	f240 53a8 	movw	r3, #1448	; 0x5a8
 800ccc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ccc8:	681a      	ldr	r2, [r3, #0]
 800ccca:	f64d 3318 	movw	r3, #56088	; 0xdb18
 800ccce:	f6c0 0300 	movt	r3, #2048	; 0x800
 800ccd2:	681b      	ldr	r3, [r3, #0]
 800ccd4:	429a      	cmp	r2, r3
 800ccd6:	d905      	bls.n	800cce4 <msheap_init+0xbc>
 800ccd8:	f64d 3020 	movw	r0, #56096	; 0xdb20
 800ccdc:	f6c0 0000 	movt	r0, #2048	; 0x800
 800cce0:	f000 fd70 	bl	800d7c4 <msheap_panic>
    ASSERT(3, heap_free > 1);           /* heap must be at least 1 marker in size */

    /*
     * Initialise the base and limit markers.
     */
    heap_base->prev.size = 0;
 800cce4:	f240 53a0 	movw	r3, #1440	; 0x5a0
 800cce8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ccec:	681a      	ldr	r2, [r3, #0]
 800ccee:	8813      	ldrh	r3, [r2, #0]
 800ccf0:	f36f 030e 	bfc	r3, #0, #15
 800ccf4:	8013      	strh	r3, [r2, #0]
    heap_base->prev.free = 0;
 800ccf6:	f240 53a0 	movw	r3, #1440	; 0x5a0
 800ccfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ccfe:	681a      	ldr	r2, [r3, #0]
 800cd00:	7853      	ldrb	r3, [r2, #1]
 800cd02:	f36f 13c7 	bfc	r3, #7, #1
 800cd06:	7053      	strb	r3, [r2, #1]
    heap_base->next.size = heap_free;
 800cd08:	f240 53a0 	movw	r3, #1440	; 0x5a0
 800cd0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cd10:	681a      	ldr	r2, [r3, #0]
 800cd12:	f240 53a8 	movw	r3, #1448	; 0x5a8
 800cd16:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cd1a:	681b      	ldr	r3, [r3, #0]
 800cd1c:	b29b      	uxth	r3, r3
 800cd1e:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800cd22:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800cd26:	b299      	uxth	r1, r3
 800cd28:	8853      	ldrh	r3, [r2, #2]
 800cd2a:	f361 030e 	bfi	r3, r1, #0, #15
 800cd2e:	8053      	strh	r3, [r2, #2]
    heap_base->next.free = 1;
 800cd30:	f240 53a0 	movw	r3, #1440	; 0x5a0
 800cd34:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cd38:	681a      	ldr	r2, [r3, #0]
 800cd3a:	78d3      	ldrb	r3, [r2, #3]
 800cd3c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800cd40:	70d3      	strb	r3, [r2, #3]
    heap_limit->prev.size = heap_free;
 800cd42:	f240 53a4 	movw	r3, #1444	; 0x5a4
 800cd46:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cd4a:	681a      	ldr	r2, [r3, #0]
 800cd4c:	f240 53a8 	movw	r3, #1448	; 0x5a8
 800cd50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cd54:	681b      	ldr	r3, [r3, #0]
 800cd56:	b29b      	uxth	r3, r3
 800cd58:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800cd5c:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800cd60:	b299      	uxth	r1, r3
 800cd62:	8813      	ldrh	r3, [r2, #0]
 800cd64:	f361 030e 	bfi	r3, r1, #0, #15
 800cd68:	8013      	strh	r3, [r2, #0]
    heap_limit->prev.free = 1;
 800cd6a:	f240 53a4 	movw	r3, #1444	; 0x5a4
 800cd6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cd72:	681a      	ldr	r2, [r3, #0]
 800cd74:	7853      	ldrb	r3, [r2, #1]
 800cd76:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800cd7a:	7053      	strb	r3, [r2, #1]
    heap_limit->next.size = 0;
 800cd7c:	f240 53a4 	movw	r3, #1444	; 0x5a4
 800cd80:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cd84:	681a      	ldr	r2, [r3, #0]
 800cd86:	8853      	ldrh	r3, [r2, #2]
 800cd88:	f36f 030e 	bfc	r3, #0, #15
 800cd8c:	8053      	strh	r3, [r2, #2]
    heap_limit->next.free = 0;
 800cd8e:	f240 53a4 	movw	r3, #1444	; 0x5a4
 800cd92:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cd96:	681a      	ldr	r2, [r3, #0]
 800cd98:	78d3      	ldrb	r3, [r2, #3]
 800cd9a:	f36f 13c7 	bfc	r3, #7, #1
 800cd9e:	70d3      	strb	r3, [r2, #3]

    free_hint = heap_base;              /* a good place to start ... */
 800cda0:	f240 53a0 	movw	r3, #1440	; 0x5a0
 800cda4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cda8:	681a      	ldr	r2, [r3, #0]
 800cdaa:	f240 53ac 	movw	r3, #1452	; 0x5ac
 800cdae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cdb2:	601a      	str	r2, [r3, #0]

    region_check(heap_base);
 800cdb4:	f240 53a0 	movw	r3, #1440	; 0x5a0
 800cdb8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cdbc:	681b      	ldr	r3, [r3, #0]
 800cdbe:	4618      	mov	r0, r3
 800cdc0:	f000 f94a 	bl	800d058 <region_check>
    region_check(heap_limit);
 800cdc4:	f240 53a4 	movw	r3, #1444	; 0x5a4
 800cdc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cdcc:	681b      	ldr	r3, [r3, #0]
 800cdce:	4618      	mov	r0, r3
 800cdd0:	f000 f942 	bl	800d058 <region_check>
 800cdd4:	4623      	mov	r3, r4
 800cdd6:	f64c 4029 	movw	r0, #52265	; 0xcc29
 800cdda:	f6c0 0000 	movt	r0, #2048	; 0x800
 800cdde:	4619      	mov	r1, r3
 800cde0:	f7ff ff20 	bl	800cc24 <__cyg_profile_func_exit>
}
 800cde4:	b004      	add	sp, #16
 800cde6:	bd10      	pop	{r4, pc}

0800cde8 <msheap_alloc>:

void *
msheap_alloc(uint32_t size)
{
 800cde8:	b530      	push	{r4, r5, lr}
 800cdea:	b087      	sub	sp, #28
 800cdec:	4675      	mov	r5, lr
 800cdee:	9001      	str	r0, [sp, #4]
 800cdf0:	462b      	mov	r3, r5
 800cdf2:	f64c 50e9 	movw	r0, #52713	; 0xcde9
 800cdf6:	f6c0 0000 	movt	r0, #2048	; 0x800
 800cdfa:	4619      	mov	r1, r3
 800cdfc:	f7ff ff04 	bl	800cc08 <__cyg_profile_func_enter>
    marker_t    best;

    ASSERT(3, msheap_check());

    /* convert the passed-in size to the number of marker-size units we need to allocate */
    size += marker_size;
 800ce00:	f64d 331c 	movw	r3, #56092	; 0xdb1c
 800ce04:	f6c0 0300 	movt	r3, #2048	; 0x800
 800ce08:	681b      	ldr	r3, [r3, #0]
 800ce0a:	9a01      	ldr	r2, [sp, #4]
 800ce0c:	18d3      	adds	r3, r2, r3
 800ce0e:	9301      	str	r3, [sp, #4]
    size = round_up(size, marker_size);
 800ce10:	f64d 331c 	movw	r3, #56092	; 0xdb1c
 800ce14:	f6c0 0300 	movt	r3, #2048	; 0x800
 800ce18:	681a      	ldr	r2, [r3, #0]
 800ce1a:	9b01      	ldr	r3, [sp, #4]
 800ce1c:	18d3      	adds	r3, r2, r3
 800ce1e:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 800ce22:	f64d 331c 	movw	r3, #56092	; 0xdb1c
 800ce26:	f6c0 0300 	movt	r3, #2048	; 0x800
 800ce2a:	681b      	ldr	r3, [r3, #0]
 800ce2c:	f1c3 0300 	rsb	r3, r3, #0
 800ce30:	4013      	ands	r3, r2
 800ce32:	9301      	str	r3, [sp, #4]
    size /= marker_size;
 800ce34:	f64d 331c 	movw	r3, #56092	; 0xdb1c
 800ce38:	f6c0 0300 	movt	r3, #2048	; 0x800
 800ce3c:	681b      	ldr	r3, [r3, #0]
 800ce3e:	9a01      	ldr	r2, [sp, #4]
 800ce40:	fbb2 f3f3 	udiv	r3, r2, r3
 800ce44:	9301      	str	r3, [sp, #4]

    /* cannot possibly satisfy this allocation */
    if (size > heap_free)
 800ce46:	f240 53a8 	movw	r3, #1448	; 0x5a8
 800ce4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ce4e:	681b      	ldr	r3, [r3, #0]
 800ce50:	9a01      	ldr	r2, [sp, #4]
 800ce52:	429a      	cmp	r2, r3
 800ce54:	d902      	bls.n	800ce5c <msheap_alloc+0x74>
        return 0;
 800ce56:	f04f 0400 	mov.w	r4, #0
 800ce5a:	e07c      	b.n	800cf56 <msheap_alloc+0x16e>

    /* simple single-pass best-fit search */
restart:
    cursor = free_hint;
 800ce5c:	f240 53ac 	movw	r3, #1452	; 0x5ac
 800ce60:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ce64:	681b      	ldr	r3, [r3, #0]
 800ce66:	9305      	str	r3, [sp, #20]
    best = 0;
 800ce68:	f04f 0300 	mov.w	r3, #0
 800ce6c:	9304      	str	r3, [sp, #16]
    while (cursor != heap_limit) {
 800ce6e:	e03a      	b.n	800cee6 <msheap_alloc+0xfe>

        ASSERT(1, region_check(cursor));
 800ce70:	f04f 0300 	mov.w	r3, #0
 800ce74:	9303      	str	r3, [sp, #12]
 800ce76:	9805      	ldr	r0, [sp, #20]
 800ce78:	f000 f8ee 	bl	800d058 <region_check>
 800ce7c:	4603      	mov	r3, r0
 800ce7e:	2b00      	cmp	r3, #0
 800ce80:	d105      	bne.n	800ce8e <msheap_alloc+0xa6>
 800ce82:	f64d 3054 	movw	r0, #56148	; 0xdb54
 800ce86:	f6c0 0000 	movt	r0, #2048	; 0x800
 800ce8a:	f000 fc9b 	bl	800d7c4 <msheap_panic>

        /* if the region is free and large enough */
        if ((cursor->next.free) && (cursor->next.size >= size)) {
 800ce8e:	9b05      	ldr	r3, [sp, #20]
 800ce90:	78db      	ldrb	r3, [r3, #3]
 800ce92:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800ce96:	b2db      	uxtb	r3, r3
 800ce98:	2b00      	cmp	r3, #0
 800ce9a:	d01a      	beq.n	800ced2 <msheap_alloc+0xea>
 800ce9c:	9b05      	ldr	r3, [sp, #20]
 800ce9e:	885b      	ldrh	r3, [r3, #2]
 800cea0:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800cea4:	b29b      	uxth	r3, r3
 800cea6:	461a      	mov	r2, r3
 800cea8:	9b01      	ldr	r3, [sp, #4]
 800ceaa:	429a      	cmp	r2, r3
 800ceac:	d311      	bcc.n	800ced2 <msheap_alloc+0xea>

            /* if we have no candidate, or the new one is smaller, take it */
            if (!best || (cursor->next.size < best->next.size))
 800ceae:	9b04      	ldr	r3, [sp, #16]
 800ceb0:	2b00      	cmp	r3, #0
 800ceb2:	d00c      	beq.n	800cece <msheap_alloc+0xe6>
 800ceb4:	9b05      	ldr	r3, [sp, #20]
 800ceb6:	885b      	ldrh	r3, [r3, #2]
 800ceb8:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800cebc:	b29b      	uxth	r3, r3
 800cebe:	461a      	mov	r2, r3
 800cec0:	9b04      	ldr	r3, [sp, #16]
 800cec2:	885b      	ldrh	r3, [r3, #2]
 800cec4:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800cec8:	b29b      	uxth	r3, r3
 800ceca:	429a      	cmp	r2, r3
 800cecc:	da01      	bge.n	800ced2 <msheap_alloc+0xea>
                best = cursor;
 800cece:	9b05      	ldr	r3, [sp, #20]
 800ced0:	9304      	str	r3, [sp, #16]
        }

        cursor += cursor->next.size;
 800ced2:	9b05      	ldr	r3, [sp, #20]
 800ced4:	885b      	ldrh	r3, [r3, #2]
 800ced6:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800ceda:	b29b      	uxth	r3, r3
 800cedc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800cee0:	9a05      	ldr	r2, [sp, #20]
 800cee2:	18d3      	adds	r3, r2, r3
 800cee4:	9305      	str	r3, [sp, #20]

    /* simple single-pass best-fit search */
restart:
    cursor = free_hint;
    best = 0;
    while (cursor != heap_limit) {
 800cee6:	f240 53a4 	movw	r3, #1444	; 0x5a4
 800ceea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ceee:	681b      	ldr	r3, [r3, #0]
 800cef0:	9a05      	ldr	r2, [sp, #20]
 800cef2:	429a      	cmp	r2, r3
 800cef4:	d1bc      	bne.n	800ce70 <msheap_alloc+0x88>
        }

        cursor += cursor->next.size;
    }

    if (!best) {
 800cef6:	9b04      	ldr	r3, [sp, #16]
 800cef8:	2b00      	cmp	r3, #0
 800cefa:	d119      	bne.n	800cf30 <msheap_alloc+0x148>
        /* 
         * If we were working from the hint and found nothing, reset
         * the hint and try again
         */
        if (free_hint != heap_base) { 
 800cefc:	f240 53ac 	movw	r3, #1452	; 0x5ac
 800cf00:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cf04:	681a      	ldr	r2, [r3, #0]
 800cf06:	f240 53a0 	movw	r3, #1440	; 0x5a0
 800cf0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cf0e:	681b      	ldr	r3, [r3, #0]
 800cf10:	429a      	cmp	r2, r3
 800cf12:	d00a      	beq.n	800cf2a <msheap_alloc+0x142>
            free_hint = heap_base;
 800cf14:	f240 53a0 	movw	r3, #1440	; 0x5a0
 800cf18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cf1c:	681a      	ldr	r2, [r3, #0]
 800cf1e:	f240 53ac 	movw	r3, #1452	; 0x5ac
 800cf22:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cf26:	601a      	str	r2, [r3, #0]
            goto restart; 
 800cf28:	e798      	b.n	800ce5c <msheap_alloc+0x74>
        }

        /* no space */
        return 0;
 800cf2a:	f04f 0400 	mov.w	r4, #0
 800cf2e:	e012      	b.n	800cf56 <msheap_alloc+0x16e>
    }

    /* split the free region to make space */
    split_region(best, size);
 800cf30:	9804      	ldr	r0, [sp, #16]
 800cf32:	9901      	ldr	r1, [sp, #4]
 800cf34:	f000 faac 	bl	800d490 <split_region>

    /* update free space counter */
    heap_free -= size;
 800cf38:	f240 53a8 	movw	r3, #1448	; 0x5a8
 800cf3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cf40:	681a      	ldr	r2, [r3, #0]
 800cf42:	9b01      	ldr	r3, [sp, #4]
 800cf44:	1ad2      	subs	r2, r2, r3
 800cf46:	f240 53a8 	movw	r3, #1448	; 0x5a8
 800cf4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cf4e:	601a      	str	r2, [r3, #0]

    /* and return a pointer to the allocated region */
    return (void *)(best + 1);
 800cf50:	9b04      	ldr	r3, [sp, #16]
 800cf52:	f103 0404 	add.w	r4, r3, #4
 800cf56:	462b      	mov	r3, r5
 800cf58:	f64c 50e9 	movw	r0, #52713	; 0xcde9
 800cf5c:	f6c0 0000 	movt	r0, #2048	; 0x800
 800cf60:	4619      	mov	r1, r3
 800cf62:	f7ff fe5f 	bl	800cc24 <__cyg_profile_func_exit>
 800cf66:	4623      	mov	r3, r4
}
 800cf68:	4618      	mov	r0, r3
 800cf6a:	b007      	add	sp, #28
 800cf6c:	bd30      	pop	{r4, r5, pc}
 800cf6e:	bf00      	nop

0800cf70 <msheap_free>:

void
msheap_free(void *ptr)
{
 800cf70:	b510      	push	{r4, lr}
 800cf72:	b084      	sub	sp, #16
 800cf74:	4674      	mov	r4, lr
 800cf76:	9001      	str	r0, [sp, #4]
 800cf78:	4623      	mov	r3, r4
 800cf7a:	f64c 7071 	movw	r0, #53105	; 0xcf71
 800cf7e:	f6c0 0000 	movt	r0, #2048	; 0x800
 800cf82:	4619      	mov	r1, r3
 800cf84:	f7ff fe40 	bl	800cc08 <__cyg_profile_func_enter>
    marker_t    marker;

    marker = (marker_t)ptr - 1;
 800cf88:	9b01      	ldr	r3, [sp, #4]
 800cf8a:	f1a3 0304 	sub.w	r3, r3, #4
 800cf8e:	9303      	str	r3, [sp, #12]

    ASSERT(0, region_check(marker));
 800cf90:	f04f 0300 	mov.w	r3, #0
 800cf94:	9302      	str	r3, [sp, #8]
 800cf96:	9803      	ldr	r0, [sp, #12]
 800cf98:	f000 f85e 	bl	800d058 <region_check>
 800cf9c:	4603      	mov	r3, r0
 800cf9e:	2b00      	cmp	r3, #0
 800cfa0:	d105      	bne.n	800cfae <msheap_free+0x3e>
 800cfa2:	f64d 3088 	movw	r0, #56200	; 0xdb88
 800cfa6:	f6c0 0000 	movt	r0, #2048	; 0x800
 800cfaa:	f000 fc0b 	bl	800d7c4 <msheap_panic>
    ASSERT(3, msheap_check());

    /* this region is free, mark it accordingly */
    marker->next.free = 1;
 800cfae:	9a03      	ldr	r2, [sp, #12]
 800cfb0:	78d3      	ldrb	r3, [r2, #3]
 800cfb2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800cfb6:	70d3      	strb	r3, [r2, #3]
    (marker + marker->next.size)->prev.free = 1;
 800cfb8:	9b03      	ldr	r3, [sp, #12]
 800cfba:	885b      	ldrh	r3, [r3, #2]
 800cfbc:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800cfc0:	b29b      	uxth	r3, r3
 800cfc2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800cfc6:	9a03      	ldr	r2, [sp, #12]
 800cfc8:	18d2      	adds	r2, r2, r3
 800cfca:	7853      	ldrb	r3, [r2, #1]
 800cfcc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800cfd0:	7053      	strb	r3, [r2, #1]

    /* account for space we are freeing */
    heap_free += marker->next.size;
 800cfd2:	9b03      	ldr	r3, [sp, #12]
 800cfd4:	885b      	ldrh	r3, [r3, #2]
 800cfd6:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800cfda:	b29b      	uxth	r3, r3
 800cfdc:	461a      	mov	r2, r3
 800cfde:	f240 53a8 	movw	r3, #1448	; 0x5a8
 800cfe2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cfe6:	681b      	ldr	r3, [r3, #0]
 800cfe8:	18d2      	adds	r2, r2, r3
 800cfea:	f240 53a8 	movw	r3, #1448	; 0x5a8
 800cfee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cff2:	601a      	str	r2, [r3, #0]

    /* possibly merge this region and the following */
    merge_region(marker);
 800cff4:	9803      	ldr	r0, [sp, #12]
 800cff6:	f000 fb23 	bl	800d640 <merge_region>

    /* possibly merge this region and the preceeding */
    if (marker->prev.free) {
 800cffa:	9b03      	ldr	r3, [sp, #12]
 800cffc:	785b      	ldrb	r3, [r3, #1]
 800cffe:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800d002:	b2db      	uxtb	r3, r3
 800d004:	2b00      	cmp	r3, #0
 800d006:	d00e      	beq.n	800d026 <msheap_free+0xb6>
        marker -= marker->prev.size;
 800d008:	9b03      	ldr	r3, [sp, #12]
 800d00a:	881b      	ldrh	r3, [r3, #0]
 800d00c:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d010:	b29b      	uxth	r3, r3
 800d012:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800d016:	f1c3 0300 	rsb	r3, r3, #0
 800d01a:	9a03      	ldr	r2, [sp, #12]
 800d01c:	18d3      	adds	r3, r2, r3
 800d01e:	9303      	str	r3, [sp, #12]
        merge_region(marker);
 800d020:	9803      	ldr	r0, [sp, #12]
 800d022:	f000 fb0d 	bl	800d640 <merge_region>

    /*
     * Marker now points to the new free region, so update
     * the free hint if this has opened space earlier in the heap.
     */
    if (marker < free_hint)
 800d026:	f240 53ac 	movw	r3, #1452	; 0x5ac
 800d02a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d02e:	681b      	ldr	r3, [r3, #0]
 800d030:	9a03      	ldr	r2, [sp, #12]
 800d032:	429a      	cmp	r2, r3
 800d034:	d205      	bcs.n	800d042 <msheap_free+0xd2>
        free_hint = marker;
 800d036:	f240 53ac 	movw	r3, #1452	; 0x5ac
 800d03a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d03e:	9a03      	ldr	r2, [sp, #12]
 800d040:	601a      	str	r2, [r3, #0]
 800d042:	4623      	mov	r3, r4
 800d044:	f64c 7071 	movw	r0, #53105	; 0xcf71
 800d048:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d04c:	4619      	mov	r1, r3
 800d04e:	f7ff fde9 	bl	800cc24 <__cyg_profile_func_exit>
}
 800d052:	b004      	add	sp, #16
 800d054:	bd10      	pop	{r4, pc}
 800d056:	bf00      	nop

0800d058 <region_check>:
 * @param   marker      The region to test.
 * @return              0 if the region fails checking, 1 otherwise.
 */
static int
region_check(marker_t marker)
{
 800d058:	b530      	push	{r4, r5, lr}
 800d05a:	b093      	sub	sp, #76	; 0x4c
 800d05c:	4675      	mov	r5, lr
 800d05e:	9001      	str	r0, [sp, #4]
 800d060:	462b      	mov	r3, r5
 800d062:	f24d 0059 	movw	r0, #53337	; 0xd059
 800d066:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d06a:	4619      	mov	r1, r3
 800d06c:	f7ff fdcc 	bl	800cc08 <__cyg_profile_func_enter>
    marker_t    other;

    if (ASSERT_TEST(2, marker) |                            /* not NULL */
 800d070:	f04f 0300 	mov.w	r3, #0
 800d074:	9311      	str	r3, [sp, #68]	; 0x44
 800d076:	9b01      	ldr	r3, [sp, #4]
 800d078:	2b00      	cmp	r3, #0
 800d07a:	d105      	bne.n	800d088 <region_check+0x30>
 800d07c:	f64d 4058 	movw	r0, #56408	; 0xdc58
 800d080:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d084:	f000 fb9e 	bl	800d7c4 <msheap_panic>
 800d088:	9b01      	ldr	r3, [sp, #4]
 800d08a:	2b00      	cmp	r3, #0
 800d08c:	bf14      	ite	ne
 800d08e:	2100      	movne	r1, #0
 800d090:	2101      	moveq	r1, #1
        ASSERT_TEST(2, !((uintptr_t)marker % marker_size)) | /* properly aligned */
 800d092:	f04f 0300 	mov.w	r3, #0
 800d096:	9310      	str	r3, [sp, #64]	; 0x40
 800d098:	9a01      	ldr	r2, [sp, #4]
 800d09a:	f64d 331c 	movw	r3, #56092	; 0xdb1c
 800d09e:	f6c0 0300 	movt	r3, #2048	; 0x800
 800d0a2:	681b      	ldr	r3, [r3, #0]
 800d0a4:	fbb2 f0f3 	udiv	r0, r2, r3
 800d0a8:	fb03 f300 	mul.w	r3, r3, r0
 800d0ac:	1ad3      	subs	r3, r2, r3
 800d0ae:	2b00      	cmp	r3, #0
 800d0b0:	d005      	beq.n	800d0be <region_check+0x66>
 800d0b2:	f64d 407c 	movw	r0, #56444	; 0xdc7c
 800d0b6:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d0ba:	f000 fb83 	bl	800d7c4 <msheap_panic>
 800d0be:	9a01      	ldr	r2, [sp, #4]
 800d0c0:	f64d 331c 	movw	r3, #56092	; 0xdb1c
 800d0c4:	f6c0 0300 	movt	r3, #2048	; 0x800
 800d0c8:	681b      	ldr	r3, [r3, #0]
 800d0ca:	fbb2 f0f3 	udiv	r0, r2, r3
 800d0ce:	fb03 f300 	mul.w	r3, r3, r0
 800d0d2:	1ad3      	subs	r3, r2, r3
 800d0d4:	2b00      	cmp	r3, #0
 800d0d6:	bf0c      	ite	eq
 800d0d8:	2300      	moveq	r3, #0
 800d0da:	2301      	movne	r3, #1
static int
region_check(marker_t marker)
{
    marker_t    other;

    if (ASSERT_TEST(2, marker) |                            /* not NULL */
 800d0dc:	ea41 0203 	orr.w	r2, r1, r3
        ASSERT_TEST(2, !((uintptr_t)marker % marker_size)) | /* properly aligned */
        ASSERT_TEST(2, marker >= heap_base) |               /* within the heap */
 800d0e0:	f04f 0300 	mov.w	r3, #0
 800d0e4:	930f      	str	r3, [sp, #60]	; 0x3c
 800d0e6:	f240 53a0 	movw	r3, #1440	; 0x5a0
 800d0ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d0ee:	681b      	ldr	r3, [r3, #0]
 800d0f0:	9901      	ldr	r1, [sp, #4]
 800d0f2:	4299      	cmp	r1, r3
 800d0f4:	d205      	bcs.n	800d102 <region_check+0xaa>
 800d0f6:	f64d 40bc 	movw	r0, #56508	; 0xdcbc
 800d0fa:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d0fe:	f000 fb61 	bl	800d7c4 <msheap_panic>
 800d102:	f240 53a0 	movw	r3, #1440	; 0x5a0
 800d106:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d10a:	681b      	ldr	r3, [r3, #0]
 800d10c:	9901      	ldr	r1, [sp, #4]
 800d10e:	4299      	cmp	r1, r3
 800d110:	bf2c      	ite	cs
 800d112:	2300      	movcs	r3, #0
 800d114:	2301      	movcc	r3, #1
region_check(marker_t marker)
{
    marker_t    other;

    if (ASSERT_TEST(2, marker) |                            /* not NULL */
        ASSERT_TEST(2, !((uintptr_t)marker % marker_size)) | /* properly aligned */
 800d116:	431a      	orrs	r2, r3
        ASSERT_TEST(2, marker >= heap_base) |               /* within the heap */
        ASSERT_TEST(2, marker <= heap_limit))
 800d118:	f04f 0300 	mov.w	r3, #0
 800d11c:	930e      	str	r3, [sp, #56]	; 0x38
 800d11e:	f240 53a4 	movw	r3, #1444	; 0x5a4
 800d122:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d126:	681b      	ldr	r3, [r3, #0]
 800d128:	9901      	ldr	r1, [sp, #4]
 800d12a:	4299      	cmp	r1, r3
 800d12c:	d905      	bls.n	800d13a <region_check+0xe2>
 800d12e:	f64d 40ec 	movw	r0, #56556	; 0xdcec
 800d132:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d136:	f000 fb45 	bl	800d7c4 <msheap_panic>
 800d13a:	f240 53a4 	movw	r3, #1444	; 0x5a4
 800d13e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d142:	681b      	ldr	r3, [r3, #0]
 800d144:	9901      	ldr	r1, [sp, #4]
 800d146:	4299      	cmp	r1, r3
 800d148:	bf94      	ite	ls
 800d14a:	2300      	movls	r3, #0
 800d14c:	2301      	movhi	r3, #1
{
    marker_t    other;

    if (ASSERT_TEST(2, marker) |                            /* not NULL */
        ASSERT_TEST(2, !((uintptr_t)marker % marker_size)) | /* properly aligned */
        ASSERT_TEST(2, marker >= heap_base) |               /* within the heap */
 800d14e:	4313      	orrs	r3, r2
static int
region_check(marker_t marker)
{
    marker_t    other;

    if (ASSERT_TEST(2, marker) |                            /* not NULL */
 800d150:	2b00      	cmp	r3, #0
 800d152:	d002      	beq.n	800d15a <region_check+0x102>
        ASSERT_TEST(2, !((uintptr_t)marker % marker_size)) | /* properly aligned */
        ASSERT_TEST(2, marker >= heap_base) |               /* within the heap */
        ASSERT_TEST(2, marker <= heap_limit))
        return 0;
 800d154:	f04f 0400 	mov.w	r4, #0
 800d158:	e18e      	b.n	800d478 <region_check+0x420>

    /* validate link to next marker & return link from that marker */
    if (marker->next.size > 0) {
 800d15a:	9b01      	ldr	r3, [sp, #4]
 800d15c:	885b      	ldrh	r3, [r3, #2]
 800d15e:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d162:	b29b      	uxth	r3, r3
 800d164:	2b00      	cmp	r3, #0
 800d166:	f340 8086 	ble.w	800d276 <region_check+0x21e>
        other = marker + marker->next.size;
 800d16a:	9b01      	ldr	r3, [sp, #4]
 800d16c:	885b      	ldrh	r3, [r3, #2]
 800d16e:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d172:	b29b      	uxth	r3, r3
 800d174:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800d178:	9a01      	ldr	r2, [sp, #4]
 800d17a:	18d3      	adds	r3, r2, r3
 800d17c:	930d      	str	r3, [sp, #52]	; 0x34

        if (ASSERT_TEST(2, other > marker) |                        /* must be after */
 800d17e:	f04f 0300 	mov.w	r3, #0
 800d182:	930c      	str	r3, [sp, #48]	; 0x30
 800d184:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800d186:	9b01      	ldr	r3, [sp, #4]
 800d188:	429a      	cmp	r2, r3
 800d18a:	d805      	bhi.n	800d198 <region_check+0x140>
 800d18c:	f64d 5020 	movw	r0, #56608	; 0xdd20
 800d190:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d194:	f000 fb16 	bl	800d7c4 <msheap_panic>
 800d198:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800d19a:	9b01      	ldr	r3, [sp, #4]
 800d19c:	429a      	cmp	r2, r3
 800d19e:	bf8c      	ite	hi
 800d1a0:	2200      	movhi	r2, #0
 800d1a2:	2201      	movls	r2, #1
            ASSERT_TEST(2, other <= heap_limit) |                   /* must be inside the heap */
 800d1a4:	f04f 0300 	mov.w	r3, #0
 800d1a8:	930b      	str	r3, [sp, #44]	; 0x2c
 800d1aa:	f240 53a4 	movw	r3, #1444	; 0x5a4
 800d1ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d1b2:	681b      	ldr	r3, [r3, #0]
 800d1b4:	990d      	ldr	r1, [sp, #52]	; 0x34
 800d1b6:	4299      	cmp	r1, r3
 800d1b8:	d905      	bls.n	800d1c6 <region_check+0x16e>
 800d1ba:	f64d 504c 	movw	r0, #56652	; 0xdd4c
 800d1be:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d1c2:	f000 faff 	bl	800d7c4 <msheap_panic>
 800d1c6:	f240 53a4 	movw	r3, #1444	; 0x5a4
 800d1ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d1ce:	681b      	ldr	r3, [r3, #0]
 800d1d0:	990d      	ldr	r1, [sp, #52]	; 0x34
 800d1d2:	4299      	cmp	r1, r3
 800d1d4:	bf94      	ite	ls
 800d1d6:	2300      	movls	r3, #0
 800d1d8:	2301      	movhi	r3, #1

    /* validate link to next marker & return link from that marker */
    if (marker->next.size > 0) {
        other = marker + marker->next.size;

        if (ASSERT_TEST(2, other > marker) |                        /* must be after */
 800d1da:	431a      	orrs	r2, r3
            ASSERT_TEST(2, other <= heap_limit) |                   /* must be inside the heap */
            ASSERT_TEST(2, marker->next.size == other->prev.size) | /* sizes must match */
 800d1dc:	f04f 0300 	mov.w	r3, #0
 800d1e0:	930a      	str	r3, [sp, #40]	; 0x28
 800d1e2:	9b01      	ldr	r3, [sp, #4]
 800d1e4:	885b      	ldrh	r3, [r3, #2]
 800d1e6:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d1ea:	b299      	uxth	r1, r3
 800d1ec:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800d1ee:	881b      	ldrh	r3, [r3, #0]
 800d1f0:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d1f4:	b29b      	uxth	r3, r3
 800d1f6:	4299      	cmp	r1, r3
 800d1f8:	d005      	beq.n	800d206 <region_check+0x1ae>
 800d1fa:	f64d 507c 	movw	r0, #56700	; 0xdd7c
 800d1fe:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d202:	f000 fadf 	bl	800d7c4 <msheap_panic>
 800d206:	9b01      	ldr	r3, [sp, #4]
 800d208:	885b      	ldrh	r3, [r3, #2]
 800d20a:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d20e:	b299      	uxth	r1, r3
 800d210:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800d212:	881b      	ldrh	r3, [r3, #0]
 800d214:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d218:	b29b      	uxth	r3, r3
 800d21a:	4299      	cmp	r1, r3
 800d21c:	bf0c      	ite	eq
 800d21e:	2300      	moveq	r3, #0
 800d220:	2301      	movne	r3, #1
    /* validate link to next marker & return link from that marker */
    if (marker->next.size > 0) {
        other = marker + marker->next.size;

        if (ASSERT_TEST(2, other > marker) |                        /* must be after */
            ASSERT_TEST(2, other <= heap_limit) |                   /* must be inside the heap */
 800d222:	431a      	orrs	r2, r3
            ASSERT_TEST(2, marker->next.size == other->prev.size) | /* sizes must match */
            ASSERT_TEST(2, marker->next.free == other->prev.free))  /* free state must match */
 800d224:	f04f 0300 	mov.w	r3, #0
 800d228:	9309      	str	r3, [sp, #36]	; 0x24
 800d22a:	9b01      	ldr	r3, [sp, #4]
 800d22c:	78db      	ldrb	r3, [r3, #3]
 800d22e:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800d232:	b2d9      	uxtb	r1, r3
 800d234:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800d236:	785b      	ldrb	r3, [r3, #1]
 800d238:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800d23c:	b2db      	uxtb	r3, r3
 800d23e:	4299      	cmp	r1, r3
 800d240:	d005      	beq.n	800d24e <region_check+0x1f6>
 800d242:	f64d 50c0 	movw	r0, #56768	; 0xddc0
 800d246:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d24a:	f000 fabb 	bl	800d7c4 <msheap_panic>
 800d24e:	9b01      	ldr	r3, [sp, #4]
 800d250:	78db      	ldrb	r3, [r3, #3]
 800d252:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800d256:	b2d9      	uxtb	r1, r3
 800d258:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800d25a:	785b      	ldrb	r3, [r3, #1]
 800d25c:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800d260:	b2db      	uxtb	r3, r3
 800d262:	4299      	cmp	r1, r3
 800d264:	bf0c      	ite	eq
 800d266:	2300      	moveq	r3, #0
 800d268:	2301      	movne	r3, #1
    if (marker->next.size > 0) {
        other = marker + marker->next.size;

        if (ASSERT_TEST(2, other > marker) |                        /* must be after */
            ASSERT_TEST(2, other <= heap_limit) |                   /* must be inside the heap */
            ASSERT_TEST(2, marker->next.size == other->prev.size) | /* sizes must match */
 800d26a:	4313      	orrs	r3, r2

    /* validate link to next marker & return link from that marker */
    if (marker->next.size > 0) {
        other = marker + marker->next.size;

        if (ASSERT_TEST(2, other > marker) |                        /* must be after */
 800d26c:	2b00      	cmp	r3, #0
 800d26e:	d022      	beq.n	800d2b6 <region_check+0x25e>
            ASSERT_TEST(2, other <= heap_limit) |                   /* must be inside the heap */
            ASSERT_TEST(2, marker->next.size == other->prev.size) | /* sizes must match */
            ASSERT_TEST(2, marker->next.free == other->prev.free))  /* free state must match */
            return 0;
 800d270:	f04f 0400 	mov.w	r4, #0
 800d274:	e100      	b.n	800d478 <region_check+0x420>
    } else {
        if (ASSERT_TEST(2, marker == heap_limit))                   /* or it's the end of the heap */
 800d276:	f04f 0300 	mov.w	r3, #0
 800d27a:	9308      	str	r3, [sp, #32]
 800d27c:	f240 53a4 	movw	r3, #1444	; 0x5a4
 800d280:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d284:	681b      	ldr	r3, [r3, #0]
 800d286:	9a01      	ldr	r2, [sp, #4]
 800d288:	429a      	cmp	r2, r3
 800d28a:	d005      	beq.n	800d298 <region_check+0x240>
 800d28c:	f64d 6004 	movw	r0, #56836	; 0xde04
 800d290:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d294:	f000 fa96 	bl	800d7c4 <msheap_panic>
 800d298:	f240 53a4 	movw	r3, #1444	; 0x5a4
 800d29c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d2a0:	681b      	ldr	r3, [r3, #0]
 800d2a2:	9a01      	ldr	r2, [sp, #4]
 800d2a4:	429a      	cmp	r2, r3
 800d2a6:	bf0c      	ite	eq
 800d2a8:	2300      	moveq	r3, #0
 800d2aa:	2301      	movne	r3, #1
 800d2ac:	2b00      	cmp	r3, #0
 800d2ae:	d002      	beq.n	800d2b6 <region_check+0x25e>
            return 0;
 800d2b0:	f04f 0400 	mov.w	r4, #0
 800d2b4:	e0e0      	b.n	800d478 <region_check+0x420>
    }

    /* validate link to previous marker & return link from that marker */
    if (marker->prev.size > 0) {
 800d2b6:	9b01      	ldr	r3, [sp, #4]
 800d2b8:	881b      	ldrh	r3, [r3, #0]
 800d2ba:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d2be:	b29b      	uxth	r3, r3
 800d2c0:	2b00      	cmp	r3, #0
 800d2c2:	f340 8088 	ble.w	800d3d6 <region_check+0x37e>
        other = marker - marker->prev.size;
 800d2c6:	9b01      	ldr	r3, [sp, #4]
 800d2c8:	881b      	ldrh	r3, [r3, #0]
 800d2ca:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d2ce:	b29b      	uxth	r3, r3
 800d2d0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800d2d4:	f1c3 0300 	rsb	r3, r3, #0
 800d2d8:	9a01      	ldr	r2, [sp, #4]
 800d2da:	18d3      	adds	r3, r2, r3
 800d2dc:	930d      	str	r3, [sp, #52]	; 0x34

        if (ASSERT_TEST(2, other < marker) |                        /* must be before */
 800d2de:	f04f 0300 	mov.w	r3, #0
 800d2e2:	9307      	str	r3, [sp, #28]
 800d2e4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800d2e6:	9b01      	ldr	r3, [sp, #4]
 800d2e8:	429a      	cmp	r2, r3
 800d2ea:	d305      	bcc.n	800d2f8 <region_check+0x2a0>
 800d2ec:	f64d 6038 	movw	r0, #56888	; 0xde38
 800d2f0:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d2f4:	f000 fa66 	bl	800d7c4 <msheap_panic>
 800d2f8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800d2fa:	9b01      	ldr	r3, [sp, #4]
 800d2fc:	429a      	cmp	r2, r3
 800d2fe:	bf34      	ite	cc
 800d300:	2200      	movcc	r2, #0
 800d302:	2201      	movcs	r2, #1
            ASSERT_TEST(2, other >= heap_base) |                    /* must be inside the heap */
 800d304:	f04f 0300 	mov.w	r3, #0
 800d308:	9306      	str	r3, [sp, #24]
 800d30a:	f240 53a0 	movw	r3, #1440	; 0x5a0
 800d30e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d312:	681b      	ldr	r3, [r3, #0]
 800d314:	990d      	ldr	r1, [sp, #52]	; 0x34
 800d316:	4299      	cmp	r1, r3
 800d318:	d205      	bcs.n	800d326 <region_check+0x2ce>
 800d31a:	f64d 6064 	movw	r0, #56932	; 0xde64
 800d31e:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d322:	f000 fa4f 	bl	800d7c4 <msheap_panic>
 800d326:	f240 53a0 	movw	r3, #1440	; 0x5a0
 800d32a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d32e:	681b      	ldr	r3, [r3, #0]
 800d330:	990d      	ldr	r1, [sp, #52]	; 0x34
 800d332:	4299      	cmp	r1, r3
 800d334:	bf2c      	ite	cs
 800d336:	2300      	movcs	r3, #0
 800d338:	2301      	movcc	r3, #1

    /* validate link to previous marker & return link from that marker */
    if (marker->prev.size > 0) {
        other = marker - marker->prev.size;

        if (ASSERT_TEST(2, other < marker) |                        /* must be before */
 800d33a:	431a      	orrs	r2, r3
            ASSERT_TEST(2, other >= heap_base) |                    /* must be inside the heap */
            ASSERT_TEST(2, marker->prev.size == other->next.size) | /* sizes must match */
 800d33c:	f04f 0300 	mov.w	r3, #0
 800d340:	9305      	str	r3, [sp, #20]
 800d342:	9b01      	ldr	r3, [sp, #4]
 800d344:	881b      	ldrh	r3, [r3, #0]
 800d346:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d34a:	b299      	uxth	r1, r3
 800d34c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800d34e:	885b      	ldrh	r3, [r3, #2]
 800d350:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d354:	b29b      	uxth	r3, r3
 800d356:	4299      	cmp	r1, r3
 800d358:	d005      	beq.n	800d366 <region_check+0x30e>
 800d35a:	f64d 6094 	movw	r0, #56980	; 0xde94
 800d35e:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d362:	f000 fa2f 	bl	800d7c4 <msheap_panic>
 800d366:	9b01      	ldr	r3, [sp, #4]
 800d368:	881b      	ldrh	r3, [r3, #0]
 800d36a:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d36e:	b299      	uxth	r1, r3
 800d370:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800d372:	885b      	ldrh	r3, [r3, #2]
 800d374:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d378:	b29b      	uxth	r3, r3
 800d37a:	4299      	cmp	r1, r3
 800d37c:	bf0c      	ite	eq
 800d37e:	2300      	moveq	r3, #0
 800d380:	2301      	movne	r3, #1
    /* validate link to previous marker & return link from that marker */
    if (marker->prev.size > 0) {
        other = marker - marker->prev.size;

        if (ASSERT_TEST(2, other < marker) |                        /* must be before */
            ASSERT_TEST(2, other >= heap_base) |                    /* must be inside the heap */
 800d382:	431a      	orrs	r2, r3
            ASSERT_TEST(2, marker->prev.size == other->next.size) | /* sizes must match */
            ASSERT_TEST(2, marker->prev.free == other->next.free))  /* free state must match */
 800d384:	f04f 0300 	mov.w	r3, #0
 800d388:	9304      	str	r3, [sp, #16]
 800d38a:	9b01      	ldr	r3, [sp, #4]
 800d38c:	785b      	ldrb	r3, [r3, #1]
 800d38e:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800d392:	b2d9      	uxtb	r1, r3
 800d394:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800d396:	78db      	ldrb	r3, [r3, #3]
 800d398:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800d39c:	b2db      	uxtb	r3, r3
 800d39e:	4299      	cmp	r1, r3
 800d3a0:	d005      	beq.n	800d3ae <region_check+0x356>
 800d3a2:	f64d 60d8 	movw	r0, #57048	; 0xded8
 800d3a6:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d3aa:	f000 fa0b 	bl	800d7c4 <msheap_panic>
 800d3ae:	9b01      	ldr	r3, [sp, #4]
 800d3b0:	785b      	ldrb	r3, [r3, #1]
 800d3b2:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800d3b6:	b2d9      	uxtb	r1, r3
 800d3b8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800d3ba:	78db      	ldrb	r3, [r3, #3]
 800d3bc:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800d3c0:	b2db      	uxtb	r3, r3
 800d3c2:	4299      	cmp	r1, r3
 800d3c4:	bf0c      	ite	eq
 800d3c6:	2300      	moveq	r3, #0
 800d3c8:	2301      	movne	r3, #1
    if (marker->prev.size > 0) {
        other = marker - marker->prev.size;

        if (ASSERT_TEST(2, other < marker) |                        /* must be before */
            ASSERT_TEST(2, other >= heap_base) |                    /* must be inside the heap */
            ASSERT_TEST(2, marker->prev.size == other->next.size) | /* sizes must match */
 800d3ca:	4313      	orrs	r3, r2

    /* validate link to previous marker & return link from that marker */
    if (marker->prev.size > 0) {
        other = marker - marker->prev.size;

        if (ASSERT_TEST(2, other < marker) |                        /* must be before */
 800d3cc:	2b00      	cmp	r3, #0
 800d3ce:	d022      	beq.n	800d416 <region_check+0x3be>
            ASSERT_TEST(2, other >= heap_base) |                    /* must be inside the heap */
            ASSERT_TEST(2, marker->prev.size == other->next.size) | /* sizes must match */
            ASSERT_TEST(2, marker->prev.free == other->next.free))  /* free state must match */
            return 0;
 800d3d0:	f04f 0400 	mov.w	r4, #0
 800d3d4:	e050      	b.n	800d478 <region_check+0x420>
    } else {
        if (ASSERT_TEST(2, marker == heap_base))                    /* or it's the end of the heap */
 800d3d6:	f04f 0300 	mov.w	r3, #0
 800d3da:	9303      	str	r3, [sp, #12]
 800d3dc:	f240 53a0 	movw	r3, #1440	; 0x5a0
 800d3e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d3e4:	681b      	ldr	r3, [r3, #0]
 800d3e6:	9a01      	ldr	r2, [sp, #4]
 800d3e8:	429a      	cmp	r2, r3
 800d3ea:	d005      	beq.n	800d3f8 <region_check+0x3a0>
 800d3ec:	f64d 701c 	movw	r0, #57116	; 0xdf1c
 800d3f0:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d3f4:	f000 f9e6 	bl	800d7c4 <msheap_panic>
 800d3f8:	f240 53a0 	movw	r3, #1440	; 0x5a0
 800d3fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d400:	681b      	ldr	r3, [r3, #0]
 800d402:	9a01      	ldr	r2, [sp, #4]
 800d404:	429a      	cmp	r2, r3
 800d406:	bf0c      	ite	eq
 800d408:	2300      	moveq	r3, #0
 800d40a:	2301      	movne	r3, #1
 800d40c:	2b00      	cmp	r3, #0
 800d40e:	d002      	beq.n	800d416 <region_check+0x3be>
            return 0;
 800d410:	f04f 0400 	mov.w	r4, #0
 800d414:	e030      	b.n	800d478 <region_check+0x420>
    }

    /* must never be two free regions adjacent */
    if (ASSERT_TEST(2, !(marker->prev.free && marker->next.free)))
 800d416:	f04f 0300 	mov.w	r3, #0
 800d41a:	9302      	str	r3, [sp, #8]
 800d41c:	9b01      	ldr	r3, [sp, #4]
 800d41e:	785b      	ldrb	r3, [r3, #1]
 800d420:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800d424:	b2db      	uxtb	r3, r3
 800d426:	2b00      	cmp	r3, #0
 800d428:	d00c      	beq.n	800d444 <region_check+0x3ec>
 800d42a:	9b01      	ldr	r3, [sp, #4]
 800d42c:	78db      	ldrb	r3, [r3, #3]
 800d42e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800d432:	b2db      	uxtb	r3, r3
 800d434:	2b00      	cmp	r3, #0
 800d436:	d005      	beq.n	800d444 <region_check+0x3ec>
 800d438:	f64d 704c 	movw	r0, #57164	; 0xdf4c
 800d43c:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d440:	f000 f9c0 	bl	800d7c4 <msheap_panic>
 800d444:	9b01      	ldr	r3, [sp, #4]
 800d446:	785b      	ldrb	r3, [r3, #1]
 800d448:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800d44c:	b2db      	uxtb	r3, r3
 800d44e:	2b00      	cmp	r3, #0
 800d450:	d009      	beq.n	800d466 <region_check+0x40e>
 800d452:	9b01      	ldr	r3, [sp, #4]
 800d454:	78db      	ldrb	r3, [r3, #3]
 800d456:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800d45a:	b2db      	uxtb	r3, r3
 800d45c:	2b00      	cmp	r3, #0
 800d45e:	d002      	beq.n	800d466 <region_check+0x40e>
 800d460:	f04f 0301 	mov.w	r3, #1
 800d464:	e001      	b.n	800d46a <region_check+0x412>
 800d466:	f04f 0300 	mov.w	r3, #0
 800d46a:	2b00      	cmp	r3, #0
 800d46c:	d002      	beq.n	800d474 <region_check+0x41c>
        return 0;
 800d46e:	f04f 0400 	mov.w	r4, #0
 800d472:	e001      	b.n	800d478 <region_check+0x420>

    return 1;
 800d474:	f04f 0401 	mov.w	r4, #1
 800d478:	462b      	mov	r3, r5
 800d47a:	f24d 0059 	movw	r0, #53337	; 0xd059
 800d47e:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d482:	4619      	mov	r1, r3
 800d484:	f7ff fbce 	bl	800cc24 <__cyg_profile_func_exit>
 800d488:	4623      	mov	r3, r4
}
 800d48a:	4618      	mov	r0, r3
 800d48c:	b013      	add	sp, #76	; 0x4c
 800d48e:	bd30      	pop	{r4, r5, pc}

0800d490 <split_region>:
 * @param   marker      Marker at the head of the region to be split.
 * @param   size        Size of the portion to be allocated.
 */
static void
split_region(marker_t marker, uint32_t size)
{
 800d490:	b510      	push	{r4, lr}
 800d492:	b088      	sub	sp, #32
 800d494:	4674      	mov	r4, lr
 800d496:	9001      	str	r0, [sp, #4]
 800d498:	9100      	str	r1, [sp, #0]
 800d49a:	4623      	mov	r3, r4
 800d49c:	f24d 4091 	movw	r0, #54417	; 0xd491
 800d4a0:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d4a4:	4619      	mov	r1, r3
 800d4a6:	f7ff fbaf 	bl	800cc08 <__cyg_profile_func_enter>
    marker_t    split, tail;

    ASSERT(1, marker->next.free);           /* must be splitting a free region */
 800d4aa:	f04f 0300 	mov.w	r3, #0
 800d4ae:	9307      	str	r3, [sp, #28]
 800d4b0:	9b01      	ldr	r3, [sp, #4]
 800d4b2:	78db      	ldrb	r3, [r3, #3]
 800d4b4:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800d4b8:	b2db      	uxtb	r3, r3
 800d4ba:	2b00      	cmp	r3, #0
 800d4bc:	d105      	bne.n	800d4ca <split_region+0x3a>
 800d4be:	f64d 7094 	movw	r0, #57236	; 0xdf94
 800d4c2:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d4c6:	f000 f97d 	bl	800d7c4 <msheap_panic>
    ASSERT(1, !marker->prev.free);          /* free region must never follow a free region */
 800d4ca:	f04f 0300 	mov.w	r3, #0
 800d4ce:	9306      	str	r3, [sp, #24]
 800d4d0:	9b01      	ldr	r3, [sp, #4]
 800d4d2:	785b      	ldrb	r3, [r3, #1]
 800d4d4:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800d4d8:	b2db      	uxtb	r3, r3
 800d4da:	2b00      	cmp	r3, #0
 800d4dc:	d005      	beq.n	800d4ea <split_region+0x5a>
 800d4de:	f64d 70c4 	movw	r0, #57284	; 0xdfc4
 800d4e2:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d4e6:	f000 f96d 	bl	800d7c4 <msheap_panic>
    ASSERT(1, marker->next.size >= size);   /* size must fit in region */
 800d4ea:	f04f 0300 	mov.w	r3, #0
 800d4ee:	9305      	str	r3, [sp, #20]
 800d4f0:	9b01      	ldr	r3, [sp, #4]
 800d4f2:	885b      	ldrh	r3, [r3, #2]
 800d4f4:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d4f8:	b29b      	uxth	r3, r3
 800d4fa:	461a      	mov	r2, r3
 800d4fc:	9b00      	ldr	r3, [sp, #0]
 800d4fe:	429a      	cmp	r2, r3
 800d500:	d205      	bcs.n	800d50e <split_region+0x7e>
 800d502:	f64d 70f4 	movw	r0, #57332	; 0xdff4
 800d506:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d50a:	f000 f95b 	bl	800d7c4 <msheap_panic>

    ASSERT(3, size);                        /* split result must be at least one marker in size */

    tail = marker + marker->next.size;
 800d50e:	9b01      	ldr	r3, [sp, #4]
 800d510:	885b      	ldrh	r3, [r3, #2]
 800d512:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d516:	b29b      	uxth	r3, r3
 800d518:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800d51c:	9a01      	ldr	r2, [sp, #4]
 800d51e:	18d3      	adds	r3, r2, r3
 800d520:	9304      	str	r3, [sp, #16]
    ASSERT(1, region_check(tail));          /* validate the following region */
 800d522:	f04f 0300 	mov.w	r3, #0
 800d526:	9303      	str	r3, [sp, #12]
 800d528:	9804      	ldr	r0, [sp, #16]
 800d52a:	f7ff fd95 	bl	800d058 <region_check>
 800d52e:	4603      	mov	r3, r0
 800d530:	2b00      	cmp	r3, #0
 800d532:	d105      	bne.n	800d540 <split_region+0xb0>
 800d534:	f24e 002c 	movw	r0, #57388	; 0xe02c
 800d538:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d53c:	f000 f942 	bl	800d7c4 <msheap_panic>

    /* 
     * The split marker is at the end of the allocated region; it may actually
     * be at the end of the previous free region as well.
     */
    split = marker + size;
 800d540:	9b00      	ldr	r3, [sp, #0]
 800d542:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800d546:	9a01      	ldr	r2, [sp, #4]
 800d548:	18d3      	adds	r3, r2, r3
 800d54a:	9302      	str	r3, [sp, #8]
    
    /* describe the now-allocated region */
    split->prev.size = size;
 800d54c:	9b00      	ldr	r3, [sp, #0]
 800d54e:	b29b      	uxth	r3, r3
 800d550:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800d554:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800d558:	b299      	uxth	r1, r3
 800d55a:	9a02      	ldr	r2, [sp, #8]
 800d55c:	8813      	ldrh	r3, [r2, #0]
 800d55e:	f361 030e 	bfi	r3, r1, #0, #15
 800d562:	8013      	strh	r3, [r2, #0]
    split->prev.free = 0;
 800d564:	9a02      	ldr	r2, [sp, #8]
 800d566:	7853      	ldrb	r3, [r2, #1]
 800d568:	f36f 13c7 	bfc	r3, #7, #1
 800d56c:	7053      	strb	r3, [r2, #1]

    /* if there is a real split, then describe the free region */
    if (split != tail) {        
 800d56e:	9a02      	ldr	r2, [sp, #8]
 800d570:	9b04      	ldr	r3, [sp, #16]
 800d572:	429a      	cmp	r2, r3
 800d574:	d036      	beq.n	800d5e4 <split_region+0x154>
        split->next.size = marker->next.size - size;
 800d576:	9b01      	ldr	r3, [sp, #4]
 800d578:	885b      	ldrh	r3, [r3, #2]
 800d57a:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d57e:	b29b      	uxth	r3, r3
 800d580:	461a      	mov	r2, r3
 800d582:	9b00      	ldr	r3, [sp, #0]
 800d584:	b29b      	uxth	r3, r3
 800d586:	1ad3      	subs	r3, r2, r3
 800d588:	b29b      	uxth	r3, r3
 800d58a:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800d58e:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800d592:	b299      	uxth	r1, r3
 800d594:	9a02      	ldr	r2, [sp, #8]
 800d596:	8853      	ldrh	r3, [r2, #2]
 800d598:	f361 030e 	bfi	r3, r1, #0, #15
 800d59c:	8053      	strh	r3, [r2, #2]
        split->next.free = 1;
 800d59e:	9a02      	ldr	r2, [sp, #8]
 800d5a0:	78d3      	ldrb	r3, [r2, #3]
 800d5a2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800d5a6:	70d3      	strb	r3, [r2, #3]
        tail->prev.size = split->next.size;
 800d5a8:	9b02      	ldr	r3, [sp, #8]
 800d5aa:	885b      	ldrh	r3, [r3, #2]
 800d5ac:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d5b0:	b299      	uxth	r1, r3
 800d5b2:	9a04      	ldr	r2, [sp, #16]
 800d5b4:	8813      	ldrh	r3, [r2, #0]
 800d5b6:	f361 030e 	bfi	r3, r1, #0, #15
 800d5ba:	8013      	strh	r3, [r2, #0]
        tail->prev.free = 1;
 800d5bc:	9a04      	ldr	r2, [sp, #16]
 800d5be:	7853      	ldrb	r3, [r2, #1]
 800d5c0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800d5c4:	7053      	strb	r3, [r2, #1]

        /*
         * Update the allocation speedup hint to
         * point to the new free region if we just used it.
         */
        if (free_hint == marker)
 800d5c6:	f240 53ac 	movw	r3, #1452	; 0x5ac
 800d5ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d5ce:	681a      	ldr	r2, [r3, #0]
 800d5d0:	9b01      	ldr	r3, [sp, #4]
 800d5d2:	429a      	cmp	r2, r3
 800d5d4:	d118      	bne.n	800d608 <split_region+0x178>
            free_hint = split;
 800d5d6:	f240 53ac 	movw	r3, #1452	; 0x5ac
 800d5da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d5de:	9a02      	ldr	r2, [sp, #8]
 800d5e0:	601a      	str	r2, [r3, #0]
 800d5e2:	e011      	b.n	800d608 <split_region+0x178>

        /*
         * If we just allocated all of what the free hint
         * pointed to, reset it to the base of the heap.
         */
        if (free_hint == marker)
 800d5e4:	f240 53ac 	movw	r3, #1452	; 0x5ac
 800d5e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d5ec:	681a      	ldr	r2, [r3, #0]
 800d5ee:	9b01      	ldr	r3, [sp, #4]
 800d5f0:	429a      	cmp	r2, r3
 800d5f2:	d109      	bne.n	800d608 <split_region+0x178>
            free_hint = heap_base;
 800d5f4:	f240 53a0 	movw	r3, #1440	; 0x5a0
 800d5f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d5fc:	681a      	ldr	r2, [r3, #0]
 800d5fe:	f240 53ac 	movw	r3, #1452	; 0x5ac
 800d602:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d606:	601a      	str	r2, [r3, #0]
    }

    /* and update the allocated region */
    marker->next.size = size;
 800d608:	9b00      	ldr	r3, [sp, #0]
 800d60a:	b29b      	uxth	r3, r3
 800d60c:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800d610:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800d614:	b299      	uxth	r1, r3
 800d616:	9a01      	ldr	r2, [sp, #4]
 800d618:	8853      	ldrh	r3, [r2, #2]
 800d61a:	f361 030e 	bfi	r3, r1, #0, #15
 800d61e:	8053      	strh	r3, [r2, #2]
    marker->next.free = 0;
 800d620:	9a01      	ldr	r2, [sp, #4]
 800d622:	78d3      	ldrb	r3, [r2, #3]
 800d624:	f36f 13c7 	bfc	r3, #7, #1
 800d628:	70d3      	strb	r3, [r2, #3]
 800d62a:	4623      	mov	r3, r4
 800d62c:	f24d 4091 	movw	r0, #54417	; 0xd491
 800d630:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d634:	4619      	mov	r1, r3
 800d636:	f7ff faf5 	bl	800cc24 <__cyg_profile_func_exit>

    ASSERT(3, region_check(marker));
    ASSERT(3, region_check(split));
    ASSERT(3, region_check(tail));
}
 800d63a:	b008      	add	sp, #32
 800d63c:	bd10      	pop	{r4, pc}
 800d63e:	bf00      	nop

0800d640 <merge_region>:
 *
 * @param   marker  Marker preceeding the region to be merged.
 */
static void
merge_region(marker_t marker)
{
 800d640:	b510      	push	{r4, lr}
 800d642:	b084      	sub	sp, #16
 800d644:	4674      	mov	r4, lr
 800d646:	9001      	str	r0, [sp, #4]
 800d648:	4623      	mov	r3, r4
 800d64a:	f24d 6041 	movw	r0, #54849	; 0xd641
 800d64e:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d652:	4619      	mov	r1, r3
 800d654:	f7ff fad8 	bl	800cc08 <__cyg_profile_func_enter>
    /* 
     * note - cannot region_check(marker) here as we are
     * actively fixing adjacent free regions.
     */

    other = marker + marker->next.size;
 800d658:	9b01      	ldr	r3, [sp, #4]
 800d65a:	885b      	ldrh	r3, [r3, #2]
 800d65c:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d660:	b29b      	uxth	r3, r3
 800d662:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800d666:	9a01      	ldr	r2, [sp, #4]
 800d668:	18d3      	adds	r3, r2, r3
 800d66a:	9303      	str	r3, [sp, #12]

    /* if this region and the next region are both free, merge */
    if (marker->next.free && other->next.free) {
 800d66c:	9b01      	ldr	r3, [sp, #4]
 800d66e:	78db      	ldrb	r3, [r3, #3]
 800d670:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800d674:	b2db      	uxtb	r3, r3
 800d676:	2b00      	cmp	r3, #0
 800d678:	d031      	beq.n	800d6de <merge_region+0x9e>
 800d67a:	9b03      	ldr	r3, [sp, #12]
 800d67c:	78db      	ldrb	r3, [r3, #3]
 800d67e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800d682:	b2db      	uxtb	r3, r3
 800d684:	2b00      	cmp	r3, #0
 800d686:	d02a      	beq.n	800d6de <merge_region+0x9e>

        /* update region size */
        marker->next.size += other->next.size;
 800d688:	9b01      	ldr	r3, [sp, #4]
 800d68a:	885b      	ldrh	r3, [r3, #2]
 800d68c:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d690:	b29b      	uxth	r3, r3
 800d692:	461a      	mov	r2, r3
 800d694:	9b03      	ldr	r3, [sp, #12]
 800d696:	885b      	ldrh	r3, [r3, #2]
 800d698:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d69c:	b29b      	uxth	r3, r3
 800d69e:	18d3      	adds	r3, r2, r3
 800d6a0:	b29b      	uxth	r3, r3
 800d6a2:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800d6a6:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800d6aa:	b299      	uxth	r1, r3
 800d6ac:	9a01      	ldr	r2, [sp, #4]
 800d6ae:	8853      	ldrh	r3, [r2, #2]
 800d6b0:	f361 030e 	bfi	r3, r1, #0, #15
 800d6b4:	8053      	strh	r3, [r2, #2]

        /* update the marker following the end of the merged regions */
        other = marker + marker->next.size;
 800d6b6:	9b01      	ldr	r3, [sp, #4]
 800d6b8:	885b      	ldrh	r3, [r3, #2]
 800d6ba:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d6be:	b29b      	uxth	r3, r3
 800d6c0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800d6c4:	9a01      	ldr	r2, [sp, #4]
 800d6c6:	18d3      	adds	r3, r2, r3
 800d6c8:	9303      	str	r3, [sp, #12]
        other->prev.size = marker->next.size;
 800d6ca:	9b01      	ldr	r3, [sp, #4]
 800d6cc:	885b      	ldrh	r3, [r3, #2]
 800d6ce:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d6d2:	b299      	uxth	r1, r3
 800d6d4:	9a03      	ldr	r2, [sp, #12]
 800d6d6:	8813      	ldrh	r3, [r2, #0]
 800d6d8:	f361 030e 	bfi	r3, r1, #0, #15
 800d6dc:	8013      	strh	r3, [r2, #0]
 800d6de:	4623      	mov	r3, r4
 800d6e0:	f24d 6041 	movw	r0, #54849	; 0xd641
 800d6e4:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d6e8:	4619      	mov	r1, r3
 800d6ea:	f7ff fa9b 	bl	800cc24 <__cyg_profile_func_exit>
    }
}
 800d6ee:	b004      	add	sp, #16
 800d6f0:	bd10      	pop	{r4, pc}
 800d6f2:	bf00      	nop

0800d6f4 <pvPortMalloc>:
 */
extern void vApplicationMallocFailedHook(void) __attribute__((weak));

void *
pvPortMalloc(size_t s)
{
 800d6f4:	b530      	push	{r4, r5, lr}
 800d6f6:	b085      	sub	sp, #20
 800d6f8:	4674      	mov	r4, lr
 800d6fa:	9001      	str	r0, [sp, #4]
 800d6fc:	4623      	mov	r3, r4
 800d6fe:	f24d 60f5 	movw	r0, #55029	; 0xd6f5
 800d702:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d706:	4619      	mov	r1, r3
 800d708:	f7ff fa7e 	bl	800cc08 <__cyg_profile_func_enter>
	void *p;

	vPortEnterCritical();
 800d70c:	f7ff f9d4 	bl	800cab8 <vPortEnterCritical>
	p = msheap_alloc(s);
 800d710:	9801      	ldr	r0, [sp, #4]
 800d712:	f7ff fb69 	bl	800cde8 <msheap_alloc>
 800d716:	9003      	str	r0, [sp, #12]
	vPortExitCritical();
 800d718:	f7ff f9f2 	bl	800cb00 <vPortExitCritical>

	if (p == NULL && &vApplicationMallocFailedHook != NULL)
 800d71c:	9b03      	ldr	r3, [sp, #12]
 800d71e:	2b00      	cmp	r3, #0
 800d720:	d107      	bne.n	800d732 <pvPortMalloc+0x3e>
 800d722:	f240 0300 	movw	r3, #0
 800d726:	f2c0 0300 	movt	r3, #0
 800d72a:	2b00      	cmp	r3, #0
 800d72c:	d001      	beq.n	800d732 <pvPortMalloc+0x3e>
		vApplicationMallocFailedHook();
 800d72e:	f3af 8000 	nop.w

	return p;
 800d732:	9d03      	ldr	r5, [sp, #12]
 800d734:	4623      	mov	r3, r4
 800d736:	f24d 60f5 	movw	r0, #55029	; 0xd6f5
 800d73a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d73e:	4619      	mov	r1, r3
 800d740:	f7ff fa70 	bl	800cc24 <__cyg_profile_func_exit>
 800d744:	462b      	mov	r3, r5
}
 800d746:	4618      	mov	r0, r3
 800d748:	b005      	add	sp, #20
 800d74a:	bd30      	pop	{r4, r5, pc}

0800d74c <vPortFree>:

void
vPortFree(void *p)
{
 800d74c:	b510      	push	{r4, lr}
 800d74e:	b082      	sub	sp, #8
 800d750:	4674      	mov	r4, lr
 800d752:	9001      	str	r0, [sp, #4]
 800d754:	4623      	mov	r3, r4
 800d756:	f24d 704d 	movw	r0, #55117	; 0xd74d
 800d75a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d75e:	4619      	mov	r1, r3
 800d760:	f7ff fa52 	bl	800cc08 <__cyg_profile_func_enter>
	vPortEnterCritical();
 800d764:	f7ff f9a8 	bl	800cab8 <vPortEnterCritical>
	msheap_free(p);
 800d768:	9801      	ldr	r0, [sp, #4]
 800d76a:	f7ff fc01 	bl	800cf70 <msheap_free>
	vPortExitCritical();
 800d76e:	f7ff f9c7 	bl	800cb00 <vPortExitCritical>
 800d772:	4623      	mov	r3, r4
 800d774:	f24d 704d 	movw	r0, #55117	; 0xd74d
 800d778:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d77c:	4619      	mov	r1, r3
 800d77e:	f7ff fa51 	bl	800cc24 <__cyg_profile_func_exit>
}
 800d782:	b002      	add	sp, #8
 800d784:	bd10      	pop	{r4, pc}
 800d786:	bf00      	nop

0800d788 <vPortInitialiseBlocks>:
	return msheap_free_space();
}

void
vPortInitialiseBlocks(void)
{
 800d788:	b510      	push	{r4, lr}
 800d78a:	4674      	mov	r4, lr
 800d78c:	4623      	mov	r3, r4
 800d78e:	f24d 7089 	movw	r0, #55177	; 0xd789
 800d792:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d796:	4619      	mov	r1, r3
 800d798:	f7ff fa36 	bl	800cc08 <__cyg_profile_func_enter>
	msheap_init(&_sheap, &_eheap);
 800d79c:	f240 50c0 	movw	r0, #1472	; 0x5c0
 800d7a0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800d7a4:	f64f 71fe 	movw	r1, #65534	; 0xfffe
 800d7a8:	f2c2 0101 	movt	r1, #8193	; 0x2001
 800d7ac:	f7ff fa3c 	bl	800cc28 <msheap_init>
 800d7b0:	4623      	mov	r3, r4
 800d7b2:	f24d 7089 	movw	r0, #55177	; 0xd789
 800d7b6:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d7ba:	4619      	mov	r1, r3
 800d7bc:	f7ff fa32 	bl	800cc24 <__cyg_profile_func_exit>
}
 800d7c0:	bd10      	pop	{r4, pc}
 800d7c2:	bf00      	nop

0800d7c4 <msheap_panic>:

#endif /* PIOS_INCLUDE_FREERTOS */

void
msheap_panic(const char *reason)
{
 800d7c4:	b510      	push	{r4, lr}
 800d7c6:	b082      	sub	sp, #8
 800d7c8:	4674      	mov	r4, lr
 800d7ca:	9001      	str	r0, [sp, #4]
 800d7cc:	4623      	mov	r3, r4
 800d7ce:	f24d 70c5 	movw	r0, #55237	; 0xd7c5
 800d7d2:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d7d6:	4619      	mov	r1, r3
 800d7d8:	f7ff fa16 	bl	800cc08 <__cyg_profile_func_enter>
	PIOS_DEBUG_Panic(reason);
 800d7dc:	9801      	ldr	r0, [sp, #4]
 800d7de:	f7fb fc07 	bl	8008ff0 <PIOS_DEBUG_Panic>
 800d7e2:	4623      	mov	r3, r4
 800d7e4:	f24d 70c5 	movw	r0, #55237	; 0xd7c5
 800d7e8:	f6c0 0000 	movt	r0, #2048	; 0x800
 800d7ec:	4619      	mov	r1, r3
 800d7ee:	f7ff fa19 	bl	800cc24 <__cyg_profile_func_exit>
}
 800d7f2:	b002      	add	sp, #8
 800d7f4:	bd10      	pop	{r4, pc}
 800d7f6:	bf00      	nop

0800d7f8 <memcmp>:
 800d7f8:	2a03      	cmp	r2, #3
 800d7fa:	b470      	push	{r4, r5, r6}
 800d7fc:	d926      	bls.n	800d84c <memcmp+0x54>
 800d7fe:	ea41 0500 	orr.w	r5, r1, r0
 800d802:	07ad      	lsls	r5, r5, #30
 800d804:	4603      	mov	r3, r0
 800d806:	460c      	mov	r4, r1
 800d808:	d013      	beq.n	800d832 <memcmp+0x3a>
 800d80a:	7805      	ldrb	r5, [r0, #0]
 800d80c:	780c      	ldrb	r4, [r1, #0]
 800d80e:	3a01      	subs	r2, #1
 800d810:	2300      	movs	r3, #0
 800d812:	42a5      	cmp	r5, r4
 800d814:	d004      	beq.n	800d820 <memcmp+0x28>
 800d816:	e01d      	b.n	800d854 <memcmp+0x5c>
 800d818:	7865      	ldrb	r5, [r4, #1]
 800d81a:	5ccc      	ldrb	r4, [r1, r3]
 800d81c:	42a5      	cmp	r5, r4
 800d81e:	d119      	bne.n	800d854 <memcmp+0x5c>
 800d820:	429a      	cmp	r2, r3
 800d822:	eb00 0403 	add.w	r4, r0, r3
 800d826:	f103 0301 	add.w	r3, r3, #1
 800d82a:	d1f5      	bne.n	800d818 <memcmp+0x20>
 800d82c:	2000      	movs	r0, #0
 800d82e:	bc70      	pop	{r4, r5, r6}
 800d830:	4770      	bx	lr
 800d832:	6825      	ldr	r5, [r4, #0]
 800d834:	681e      	ldr	r6, [r3, #0]
 800d836:	4621      	mov	r1, r4
 800d838:	4618      	mov	r0, r3
 800d83a:	3404      	adds	r4, #4
 800d83c:	3304      	adds	r3, #4
 800d83e:	42ae      	cmp	r6, r5
 800d840:	d104      	bne.n	800d84c <memcmp+0x54>
 800d842:	3a04      	subs	r2, #4
 800d844:	2a03      	cmp	r2, #3
 800d846:	d8f4      	bhi.n	800d832 <memcmp+0x3a>
 800d848:	4621      	mov	r1, r4
 800d84a:	4618      	mov	r0, r3
 800d84c:	2a00      	cmp	r2, #0
 800d84e:	d1dc      	bne.n	800d80a <memcmp+0x12>
 800d850:	4610      	mov	r0, r2
 800d852:	e7ec      	b.n	800d82e <memcmp+0x36>
 800d854:	1b28      	subs	r0, r5, r4
 800d856:	e7ea      	b.n	800d82e <memcmp+0x36>

0800d858 <memcpy>:
 800d858:	2a0f      	cmp	r2, #15
 800d85a:	b4f0      	push	{r4, r5, r6, r7}
 800d85c:	bf98      	it	ls
 800d85e:	4603      	movls	r3, r0
 800d860:	d931      	bls.n	800d8c6 <memcpy+0x6e>
 800d862:	ea41 0300 	orr.w	r3, r1, r0
 800d866:	079b      	lsls	r3, r3, #30
 800d868:	d137      	bne.n	800d8da <memcpy+0x82>
 800d86a:	460c      	mov	r4, r1
 800d86c:	4603      	mov	r3, r0
 800d86e:	4615      	mov	r5, r2
 800d870:	6826      	ldr	r6, [r4, #0]
 800d872:	601e      	str	r6, [r3, #0]
 800d874:	6866      	ldr	r6, [r4, #4]
 800d876:	605e      	str	r6, [r3, #4]
 800d878:	68a6      	ldr	r6, [r4, #8]
 800d87a:	609e      	str	r6, [r3, #8]
 800d87c:	68e6      	ldr	r6, [r4, #12]
 800d87e:	3d10      	subs	r5, #16
 800d880:	60de      	str	r6, [r3, #12]
 800d882:	3410      	adds	r4, #16
 800d884:	3310      	adds	r3, #16
 800d886:	2d0f      	cmp	r5, #15
 800d888:	d8f2      	bhi.n	800d870 <memcpy+0x18>
 800d88a:	f1a2 0410 	sub.w	r4, r2, #16
 800d88e:	f024 040f 	bic.w	r4, r4, #15
 800d892:	f002 020f 	and.w	r2, r2, #15
 800d896:	3410      	adds	r4, #16
 800d898:	2a03      	cmp	r2, #3
 800d89a:	eb00 0304 	add.w	r3, r0, r4
 800d89e:	4421      	add	r1, r4
 800d8a0:	d911      	bls.n	800d8c6 <memcpy+0x6e>
 800d8a2:	1f0e      	subs	r6, r1, #4
 800d8a4:	461d      	mov	r5, r3
 800d8a6:	4614      	mov	r4, r2
 800d8a8:	f856 7f04 	ldr.w	r7, [r6, #4]!
 800d8ac:	3c04      	subs	r4, #4
 800d8ae:	2c03      	cmp	r4, #3
 800d8b0:	f845 7b04 	str.w	r7, [r5], #4
 800d8b4:	d8f8      	bhi.n	800d8a8 <memcpy+0x50>
 800d8b6:	1f14      	subs	r4, r2, #4
 800d8b8:	f024 0403 	bic.w	r4, r4, #3
 800d8bc:	3404      	adds	r4, #4
 800d8be:	f002 0203 	and.w	r2, r2, #3
 800d8c2:	1909      	adds	r1, r1, r4
 800d8c4:	191b      	adds	r3, r3, r4
 800d8c6:	b132      	cbz	r2, 800d8d6 <memcpy+0x7e>
 800d8c8:	3901      	subs	r1, #1
 800d8ca:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800d8ce:	3a01      	subs	r2, #1
 800d8d0:	f803 4b01 	strb.w	r4, [r3], #1
 800d8d4:	d1f9      	bne.n	800d8ca <memcpy+0x72>
 800d8d6:	bcf0      	pop	{r4, r5, r6, r7}
 800d8d8:	4770      	bx	lr
 800d8da:	4603      	mov	r3, r0
 800d8dc:	e7f4      	b.n	800d8c8 <memcpy+0x70>
 800d8de:	bf00      	nop

0800d8e0 <memset>:
 800d8e0:	f010 0f03 	tst.w	r0, #3
 800d8e4:	b470      	push	{r4, r5, r6}
 800d8e6:	4603      	mov	r3, r0
 800d8e8:	d042      	beq.n	800d970 <memset+0x90>
 800d8ea:	2a00      	cmp	r2, #0
 800d8ec:	d03e      	beq.n	800d96c <memset+0x8c>
 800d8ee:	3a01      	subs	r2, #1
 800d8f0:	b2cd      	uxtb	r5, r1
 800d8f2:	e003      	b.n	800d8fc <memset+0x1c>
 800d8f4:	1e54      	subs	r4, r2, #1
 800d8f6:	2a00      	cmp	r2, #0
 800d8f8:	d038      	beq.n	800d96c <memset+0x8c>
 800d8fa:	4622      	mov	r2, r4
 800d8fc:	f803 5b01 	strb.w	r5, [r3], #1
 800d900:	f013 0f03 	tst.w	r3, #3
 800d904:	461c      	mov	r4, r3
 800d906:	d1f5      	bne.n	800d8f4 <memset+0x14>
 800d908:	2a03      	cmp	r2, #3
 800d90a:	d929      	bls.n	800d960 <memset+0x80>
 800d90c:	b2cd      	uxtb	r5, r1
 800d90e:	2a0f      	cmp	r2, #15
 800d910:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800d914:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 800d918:	bf84      	itt	hi
 800d91a:	4623      	movhi	r3, r4
 800d91c:	4616      	movhi	r6, r2
 800d91e:	d911      	bls.n	800d944 <memset+0x64>
 800d920:	3e10      	subs	r6, #16
 800d922:	601d      	str	r5, [r3, #0]
 800d924:	605d      	str	r5, [r3, #4]
 800d926:	609d      	str	r5, [r3, #8]
 800d928:	60dd      	str	r5, [r3, #12]
 800d92a:	3310      	adds	r3, #16
 800d92c:	2e0f      	cmp	r6, #15
 800d92e:	d8f7      	bhi.n	800d920 <memset+0x40>
 800d930:	f1a2 0310 	sub.w	r3, r2, #16
 800d934:	f023 030f 	bic.w	r3, r3, #15
 800d938:	f002 020f 	and.w	r2, r2, #15
 800d93c:	3310      	adds	r3, #16
 800d93e:	2a03      	cmp	r2, #3
 800d940:	441c      	add	r4, r3
 800d942:	d90d      	bls.n	800d960 <memset+0x80>
 800d944:	4626      	mov	r6, r4
 800d946:	4613      	mov	r3, r2
 800d948:	3b04      	subs	r3, #4
 800d94a:	2b03      	cmp	r3, #3
 800d94c:	f846 5b04 	str.w	r5, [r6], #4
 800d950:	d8fa      	bhi.n	800d948 <memset+0x68>
 800d952:	1f13      	subs	r3, r2, #4
 800d954:	f023 0303 	bic.w	r3, r3, #3
 800d958:	3304      	adds	r3, #4
 800d95a:	f002 0203 	and.w	r2, r2, #3
 800d95e:	18e4      	adds	r4, r4, r3
 800d960:	b2c9      	uxtb	r1, r1
 800d962:	b11a      	cbz	r2, 800d96c <memset+0x8c>
 800d964:	3a01      	subs	r2, #1
 800d966:	f804 1b01 	strb.w	r1, [r4], #1
 800d96a:	d1fb      	bne.n	800d964 <memset+0x84>
 800d96c:	bc70      	pop	{r4, r5, r6}
 800d96e:	4770      	bx	lr
 800d970:	4604      	mov	r4, r0
 800d972:	e7c9      	b.n	800d908 <memset+0x28>

0800d974 <strlen>:
 800d974:	f020 0103 	bic.w	r1, r0, #3
 800d978:	f010 0003 	ands.w	r0, r0, #3
 800d97c:	f1c0 0000 	rsb	r0, r0, #0
 800d980:	f851 3b04 	ldr.w	r3, [r1], #4
 800d984:	f100 0c04 	add.w	ip, r0, #4
 800d988:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 800d98c:	f06f 0200 	mvn.w	r2, #0
 800d990:	bf1c      	itt	ne
 800d992:	fa22 f20c 	lsrne.w	r2, r2, ip
 800d996:	4313      	orrne	r3, r2
 800d998:	f04f 0c01 	mov.w	ip, #1
 800d99c:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 800d9a0:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 800d9a4:	eba3 020c 	sub.w	r2, r3, ip
 800d9a8:	ea22 0203 	bic.w	r2, r2, r3
 800d9ac:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 800d9b0:	bf04      	itt	eq
 800d9b2:	f851 3b04 	ldreq.w	r3, [r1], #4
 800d9b6:	3004      	addeq	r0, #4
 800d9b8:	d0f4      	beq.n	800d9a4 <strlen+0x30>
 800d9ba:	f013 0fff 	tst.w	r3, #255	; 0xff
 800d9be:	bf1f      	itttt	ne
 800d9c0:	3001      	addne	r0, #1
 800d9c2:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
 800d9c6:	3001      	addne	r0, #1
 800d9c8:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
 800d9cc:	bf18      	it	ne
 800d9ce:	3001      	addne	r0, #1
 800d9d0:	4770      	bx	lr
 800d9d2:	bf00      	nop

0800d9d4 <strncpy>:
 800d9d4:	ea41 0300 	orr.w	r3, r1, r0
 800d9d8:	f013 0f03 	tst.w	r3, #3
 800d9dc:	b470      	push	{r4, r5, r6}
 800d9de:	bf14      	ite	ne
 800d9e0:	2500      	movne	r5, #0
 800d9e2:	2501      	moveq	r5, #1
 800d9e4:	2a03      	cmp	r2, #3
 800d9e6:	bf94      	ite	ls
 800d9e8:	2500      	movls	r5, #0
 800d9ea:	f005 0501 	andhi.w	r5, r5, #1
 800d9ee:	460b      	mov	r3, r1
 800d9f0:	4604      	mov	r4, r0
 800d9f2:	b17d      	cbz	r5, 800da14 <strncpy+0x40>
 800d9f4:	4619      	mov	r1, r3
 800d9f6:	f853 5b04 	ldr.w	r5, [r3], #4
 800d9fa:	f1a5 3601 	sub.w	r6, r5, #16843009	; 0x1010101
 800d9fe:	ea26 0605 	bic.w	r6, r6, r5
 800da02:	f016 3f80 	tst.w	r6, #2155905152	; 0x80808080
 800da06:	d105      	bne.n	800da14 <strncpy+0x40>
 800da08:	3a04      	subs	r2, #4
 800da0a:	2a03      	cmp	r2, #3
 800da0c:	f844 5b04 	str.w	r5, [r4], #4
 800da10:	d8f0      	bhi.n	800d9f4 <strncpy+0x20>
 800da12:	4619      	mov	r1, r3
 800da14:	b1a2      	cbz	r2, 800da40 <strncpy+0x6c>
 800da16:	780d      	ldrb	r5, [r1, #0]
 800da18:	f804 5b01 	strb.w	r5, [r4], #1
 800da1c:	1e53      	subs	r3, r2, #1
 800da1e:	4622      	mov	r2, r4
 800da20:	b145      	cbz	r5, 800da34 <strncpy+0x60>
 800da22:	b16b      	cbz	r3, 800da40 <strncpy+0x6c>
 800da24:	f811 5f01 	ldrb.w	r5, [r1, #1]!
 800da28:	f802 5b01 	strb.w	r5, [r2], #1
 800da2c:	3b01      	subs	r3, #1
 800da2e:	4614      	mov	r4, r2
 800da30:	2d00      	cmp	r5, #0
 800da32:	d1f6      	bne.n	800da22 <strncpy+0x4e>
 800da34:	2200      	movs	r2, #0
 800da36:	b11b      	cbz	r3, 800da40 <strncpy+0x6c>
 800da38:	3b01      	subs	r3, #1
 800da3a:	f804 2b01 	strb.w	r2, [r4], #1
 800da3e:	d1fb      	bne.n	800da38 <strncpy+0x64>
 800da40:	bc70      	pop	{r4, r5, r6}
 800da42:	4770      	bx	lr
 800da44:	43415453 	.word	0x43415453
 800da48:	564f204b 	.word	0x564f204b
 800da4c:	4c465245 	.word	0x4c465245
 800da50:	0000574f 	.word	0x0000574f
 800da54:	74736554 	.word	0x74736554
 800da58:	00000000 	.word	0x00000000

0800da5c <hextab.1332>:
 800da5c:	33323130 37363534 62613938 66656463     0123456789abcdef
 800da6c:	5241480a 41462044 00544c55 5355420a     .HARD FAULT..BUS
 800da7c:	55414620 0000544c 4153550a 46204547      FAULT...USAGE F
 800da8c:	544c5541 00000000                       AULT....

0800da94 <LED_GPIO_PIN>:
 800da94:	00008000 00004000 45535341 46205452     .....@..ASSERT F
 800daa4:	454c4941 00000044 2073250d 25783040     AILED....%s @0x%
 800dab4:	00000d78 6c756e28 0000296c 454c4449     x...(null)..IDLE
 800dac4:	00000000 00000a0d 09097325 30090930     ........%s..0..0
 800dad4:	0a0d2525 00000000 09097325 09097525     %%......%s..%u..
 800dae4:	25257525 00000a0d 09097325 09097525     %u%%....%s..%u..
 800daf4:	2525313c 00000a0d                       <1%%....

0800dafc <ucExpectedStackBytes.3108>:
 800dafc:	a5a5a5a5 a5a5a5a5 a5a5a5a5 a5a5a5a5     ................
 800db0c:	a5a5a5a5 20726d54 00637653              ....Tmr Svc.

0800db18 <max_free>:
 800db18:	00007fff                                ....

0800db1c <marker_size>:
 800db1c:	00000004 70616568 73736120 69747265     ....heap asserti
 800db2c:	66206e6f 656c6961 32402064 203a3232     on failed @222: 
 800db3c:	70616568 6572665f 3d3c2065 78616d20     heap_free <= max
 800db4c:	6572665f 00000065 70616568 73736120     _free...heap ass
 800db5c:	69747265 66206e6f 656c6961 32402064     ertion failed @2
 800db6c:	203a3636 69676572 635f6e6f 6b636568     66: region_check
 800db7c:	72756328 29726f73 00000000 70616568     (cursor)....heap
 800db8c:	73736120 69747265 66206e6f 656c6961      assertion faile
 800db9c:	33402064 203a3031 69676572 635f6e6f     d @310: region_c
 800dbac:	6b636568 72616d28 2972656b 00000000     heck(marker)....
 800dbbc:	70616568 73736120 69747265 66206e6f     heap assertion f
 800dbcc:	656c6961 33402064 203a3634 69676572     ailed @346: regi
 800dbdc:	635f6e6f 6b636568 72756328 29726f73     on_check(cursor)
 800dbec:	00000000 70616568 73736120 69747265     ....heap asserti
 800dbfc:	66206e6f 656c6961 33402064 203a3535     on failed @355: 
 800dc0c:	69676572 635f6e6f 6b636568 65726628     region_check(fre
 800dc1c:	69685f65 0029746e 70616568 73736120     e_hint).heap ass
 800dc2c:	69747265 66206e6f 656c6961 33402064     ertion failed @3
 800dc3c:	203a3735 65657266 6170735f 3d206563     57: free_space =
 800dc4c:	6568203d 665f7061 00656572 70616568     = heap_free.heap
 800dc5c:	73736120 69747265 66206e6f 656c6961      assertion faile
 800dc6c:	34402064 203a3734 6b72616d 00007265     d @447: marker..
 800dc7c:	70616568 73736120 69747265 66206e6f     heap assertion f
 800dc8c:	656c6961 34402064 203a3834 75282821     ailed @448: !((u
 800dc9c:	70746e69 745f7274 72616d29 2072656b     intptr_t)marker 
 800dcac:	616d2025 72656b72 7a69735f 00002965     % marker_size)..
 800dcbc:	70616568 73736120 69747265 66206e6f     heap assertion f
 800dccc:	656c6961 34402064 203a3934 6b72616d     ailed @449: mark
 800dcdc:	3e207265 6568203d 625f7061 00657361     er >= heap_base.
 800dcec:	70616568 73736120 69747265 66206e6f     heap assertion f
 800dcfc:	656c6961 34402064 203a3035 6b72616d     ailed @450: mark
 800dd0c:	3c207265 6568203d 6c5f7061 74696d69     er <= heap_limit
 800dd1c:	00000000 70616568 73736120 69747265     ....heap asserti
 800dd2c:	66206e6f 656c6961 34402064 203a3735     on failed @457: 
 800dd3c:	6568746f 203e2072 6b72616d 00007265     other > marker..
 800dd4c:	70616568 73736120 69747265 66206e6f     heap assertion f
 800dd5c:	656c6961 34402064 203a3835 6568746f     ailed @458: othe
 800dd6c:	3d3c2072 61656820 696c5f70 0074696d     r <= heap_limit.
 800dd7c:	70616568 73736120 69747265 66206e6f     heap assertion f
 800dd8c:	656c6961 34402064 203a3935 6b72616d     ailed @459: mark
 800dd9c:	3e2d7265 7478656e 7a69732e 3d3d2065     er->next.size ==
 800ddac:	68746f20 3e2d7265 76657270 7a69732e      other->prev.siz
 800ddbc:	00000065 70616568 73736120 69747265     e...heap asserti
 800ddcc:	66206e6f 656c6961 34402064 203a3036     on failed @460: 
 800dddc:	6b72616d 3e2d7265 7478656e 6572662e     marker->next.fre
 800ddec:	3d3d2065 68746f20 3e2d7265 76657270     e == other->prev
 800ddfc:	6572662e 00000065 70616568 73736120     .free...heap ass
 800de0c:	69747265 66206e6f 656c6961 34402064     ertion failed @4
 800de1c:	203a3336 6b72616d 3d207265 6568203d     63: marker == he
 800de2c:	6c5f7061 74696d69 00000000 70616568     ap_limit....heap
 800de3c:	73736120 69747265 66206e6f 656c6961      assertion faile
 800de4c:	34402064 203a3137 6568746f 203c2072     d @471: other < 
 800de5c:	6b72616d 00007265 70616568 73736120     marker..heap ass
 800de6c:	69747265 66206e6f 656c6961 34402064     ertion failed @4
 800de7c:	203a3237 6568746f 3d3e2072 61656820     72: other >= hea
 800de8c:	61625f70 00006573 70616568 73736120     p_base..heap ass
 800de9c:	69747265 66206e6f 656c6961 34402064     ertion failed @4
 800deac:	203a3337 6b72616d 3e2d7265 76657270     73: marker->prev
 800debc:	7a69732e 3d3d2065 68746f20 3e2d7265     .size == other->
 800decc:	7478656e 7a69732e 00000065 70616568     next.size...heap
 800dedc:	73736120 69747265 66206e6f 656c6961      assertion faile
 800deec:	34402064 203a3437 6b72616d 3e2d7265     d @474: marker->
 800defc:	76657270 6572662e 3d3d2065 68746f20     prev.free == oth
 800df0c:	3e2d7265 7478656e 6572662e 00000065     er->next.free...
 800df1c:	70616568 73736120 69747265 66206e6f     heap assertion f
 800df2c:	656c6961 34402064 203a3737 6b72616d     ailed @477: mark
 800df3c:	3d207265 6568203d 625f7061 00657361     er == heap_base.
 800df4c:	70616568 73736120 69747265 66206e6f     heap assertion f
 800df5c:	656c6961 34402064 203a3238 616d2821     ailed @482: !(ma
 800df6c:	72656b72 72703e2d 662e7665 20656572     rker->prev.free 
 800df7c:	6d202626 656b7261 6e3e2d72 2e747865     && marker->next.
 800df8c:	65657266 00000029 70616568 73736120     free)...heap ass
 800df9c:	69747265 66206e6f 656c6961 34402064     ertion failed @4
 800dfac:	203a3939 6b72616d 3e2d7265 7478656e     99: marker->next
 800dfbc:	6572662e 00000065 70616568 73736120     .free...heap ass
 800dfcc:	69747265 66206e6f 656c6961 35402064     ertion failed @5
 800dfdc:	203a3030 72616d21 2d72656b 6572703e     00: !marker->pre
 800dfec:	72662e76 00006565 70616568 73736120     v.free..heap ass
 800dffc:	69747265 66206e6f 656c6961 35402064     ertion failed @5
 800e00c:	203a3130 6b72616d 3e2d7265 7478656e     01: marker->next
 800e01c:	7a69732e 3d3e2065 7a697320 00000065     .size >= size...
 800e02c:	70616568 73736120 69747265 66206e6f     heap assertion f
 800e03c:	656c6961 35402064 203a3630 69676572     ailed @506: regi
 800e04c:	635f6e6f 6b636568 69617428 0000296c     on_check(tail)..
